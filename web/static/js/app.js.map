{
  "version": 3,
  "sources": ["../../../src/main.ts", "../../../src/utils/Logger.ts", "../../../src/utils/ErrorHandler.ts", "../../../src/core/BaseComponent.ts"],
  "sourcesContent": ["/**\n * Main application entry point for GoldBox RPG Engine\n * Initializes all systems and provides the global game interface\n */\n\nimport { logger, GlobalErrorHandler, ComponentManager } from './index';\n\n// Setup global error handling\nGlobalErrorHandler.setupGlobalHandlers();\n\n// Create component manager\nconst componentManager = new ComponentManager();\n\n/**\n * Main application class that coordinates all game systems\n */\nclass GoldBoxRPGApp {\n  private readonly logger = logger.createChildLogger('GoldBoxRPGApp');\n  private initialized = false;\n\n  /**\n   * Initialize the application\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      this.logger.warn('Application already initialized');\n      return;\n    }\n\n    try {\n      this.logger.info('Initializing GoldBox RPG Engine...');\n\n      // Initialize all components\n      await componentManager.initializeAll();\n\n      this.initialized = true;\n      this.logger.info('GoldBox RPG Engine initialized successfully');\n\n      // Emit ready event for legacy JavaScript integration\n      if (typeof window !== 'undefined') {\n        window.dispatchEvent(new CustomEvent('goldbox-ready', {\n          detail: { app: this }\n        }));\n      }\n\n    } catch (error) {\n      this.logger.error('Failed to initialize application:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Cleanup and shutdown the application\n   */\n  async cleanup(): Promise<void> {\n    if (!this.initialized) {\n      return;\n    }\n\n    try {\n      this.logger.info('Shutting down GoldBox RPG Engine...');\n      \n      await componentManager.cleanupAll();\n      \n      this.initialized = false;\n      this.logger.info('GoldBox RPG Engine shut down successfully');\n      \n    } catch (error) {\n      this.logger.error('Error during application cleanup:', error);\n    }\n  }\n\n  /**\n   * Get the component manager for accessing game systems\n   */\n  getComponentManager(): ComponentManager {\n    return componentManager;\n  }\n\n  /**\n   * Check if application is initialized\n   */\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n}\n\n// Create global application instance\nconst app = new GoldBoxRPGApp();\n\n// Auto-initialize when DOM is ready\nif (typeof document !== 'undefined') {\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n      app.initialize().catch(error => {\n        console.error('Failed to auto-initialize application:', error);\n      });\n    });\n  } else {\n    // DOM already loaded\n    app.initialize().catch(error => {\n      console.error('Failed to auto-initialize application:', error);\n    });\n  }\n}\n\n// Cleanup on page unload\nif (typeof window !== 'undefined') {\n  window.addEventListener('beforeunload', () => {\n    app.cleanup().catch(error => {\n      console.error('Error during cleanup:', error);\n    });\n  });\n}\n\n// Export for global access\nexport { app as GoldBoxRPG };\n\n// For legacy JavaScript compatibility\nif (typeof window !== 'undefined') {\n  (window as any).GoldBoxRPG = {\n    app,\n    logger,\n    componentManager,\n    // Expose other utilities for migration period\n    ErrorHandler: GlobalErrorHandler,\n  };\n}\n", "/**\n * Production-safe logging utility with TypeScript support\n * Provides structured logging with performance considerations and environment detection\n */\n\nimport type { LogLevel, LoggerConfig, LogEntry } from '../types/GameTypes';\n\ninterface LogQueueEntry {\n  readonly level: LogLevel;\n  readonly timestamp: number;\n  readonly component?: string;\n  readonly message: string;\n  readonly args: readonly unknown[];\n}\n\nexport class Logger {\n  private readonly config: LoggerConfig;\n  private readonly logQueue: LogQueueEntry[] = [];\n  private readonly maxQueueSize: number = 100;\n  \n  // Bind console methods for performance\n  private readonly consoleDebug: typeof console.debug;\n  private readonly consoleInfo: typeof console.info;\n  private readonly consoleWarn: typeof console.warn;\n  private readonly consoleError: typeof console.error;\n  private readonly consoleGroup: typeof console.group;\n  private readonly consoleGroupCollapsed: typeof console.groupCollapsed;\n  private readonly consoleGroupEnd: typeof console.groupEnd;\n\n  constructor(_component: string = 'Logger') {\n    this.config = this.createConfig();\n    \n    // Bind console methods for performance optimization\n    this.consoleDebug = console.debug.bind(console);\n    this.consoleInfo = console.info.bind(console);\n    this.consoleWarn = console.warn.bind(console);\n    this.consoleError = console.error.bind(console);\n    this.consoleGroup = console.group.bind(console);\n    this.consoleGroupCollapsed = console.groupCollapsed.bind(console);\n    this.consoleGroupEnd = console.groupEnd.bind(console);\n  }\n\n  /**\n   * Creates logger configuration based on environment detection\n   */\n  private createConfig(): LoggerConfig {\n    const isDevelopment = this.detectDevelopmentEnvironment();\n    \n    return {\n      isDevelopment,\n      enabledLevels: this.getEnabledLevels(isDevelopment),\n      maxQueueSize: this.maxQueueSize\n    };\n  }\n\n  /**\n   * Detects if running in development environment\n   */\n  private detectDevelopmentEnvironment(): boolean {\n    if (typeof window === 'undefined') {\n      return false; // Server-side rendering or Node.js\n    }\n\n    const hostname = window.location.hostname;\n    \n    // Development indicators\n    const developmentHosts = [\n      'localhost',\n      '127.0.0.1',\n      '0.0.0.0'\n    ];\n\n    // Check for common development patterns\n    const isDevelopmentHost = developmentHosts.includes(hostname);\n    const isLocalIP = /^192\\.168\\.|^10\\.|^172\\.(1[6-9]|2\\d|3[01])\\./.test(hostname);\n    const isVSCodeLocal = hostname.includes('vscode-local');\n    const isCodespaces = hostname.includes('githubpreview') || hostname.includes('app.github.dev');\n    const isGitpod = hostname.includes('gitpod.io');\n    const isPreviewApp = hostname.includes('preview.app') || hostname.includes('netlify.app');\n    \n    return isDevelopmentHost || isLocalIP || isVSCodeLocal || isCodespaces || isGitpod || isPreviewApp;\n  }\n\n  /**\n   * Gets enabled log levels based on environment\n   */\n  private getEnabledLevels(isDevelopment: boolean): ReadonlySet<LogLevel> {\n    if (isDevelopment) {\n      return new Set(['debug', 'info', 'warn', 'error', 'group']);\n    } else {\n      // Production: only warnings and errors\n      return new Set(['warn', 'error']);\n    }\n  }\n\n  /**\n   * Adds entry to log queue for monitoring\n   */\n  private addToQueue(entry: LogQueueEntry): void {\n    this.logQueue.push(entry);\n    \n    // Maintain queue size limit\n    if (this.logQueue.length > this.maxQueueSize) {\n      this.logQueue.shift();\n    }\n  }\n\n  /**\n   * Logs a debug message (development only)\n   */\n  debug(message: string, ...args: unknown[]): void {\n    this.log('debug', message, ...args);\n  }\n\n  /**\n   * Logs an info message (development only)\n   */\n  info(message: string, ...args: unknown[]): void {\n    this.log('info', message, ...args);\n  }\n\n  /**\n   * Logs a warning message (always enabled)\n   */\n  warn(message: string, ...args: unknown[]): void {\n    this.log('warn', message, ...args);\n  }\n\n  /**\n   * Logs an error message (always enabled)\n   */\n  error(message: string, ...args: unknown[]): void {\n    this.log('error', message, ...args);\n  }\n\n  /**\n   * Starts a console group (development only)\n   */\n  group(label: string, ...args: unknown[]): void {\n    if (this.config.enabledLevels.has('group')) {\n      this.consoleGroup(label, ...args);\n      this.addToQueue({\n        level: 'info',\n        message: `GROUP: ${label}`,\n        timestamp: Date.now(),\n        args: [label, ...args]\n      });\n    }\n  }\n\n  /**\n   * Starts a collapsed console group (development only)\n   */\n  groupCollapsed(label: string, ...args: unknown[]): void {\n    if (this.config.enabledLevels.has('group')) {\n      this.consoleGroupCollapsed(label, ...args);\n      this.addToQueue({\n        level: 'info',\n        message: `GROUP_COLLAPSED: ${label}`,\n        timestamp: Date.now(),\n        args: [label, ...args]\n      });\n    }\n  }\n\n  /**\n   * Ends a console group (development only)\n   */\n  groupEnd(): void {\n    if (this.config.enabledLevels.has('group')) {\n      this.consoleGroupEnd();\n      this.addToQueue({\n        level: 'info',\n        message: 'GROUP_END',\n        timestamp: Date.now(),\n        args: []\n      });\n    }\n  }\n\n  /**\n   * Conditionally logs based on environment and level\n   */\n  private log(level: LogLevel, message: string, ...args: unknown[]): void {\n    if (!this.config.enabledLevels.has(level)) {\n      return;\n    }\n\n    const timestamp = Date.now();\n    const entry: LogQueueEntry = {\n      level,\n      message,\n      timestamp,\n      args\n    };\n\n    this.addToQueue(entry);\n\n    // Log to console based on level\n    switch (level) {\n      case 'debug':\n        this.consoleDebug(message, ...args);\n        break;\n      case 'info':\n        this.consoleInfo(message, ...args);\n        break;\n      case 'warn':\n        this.consoleWarn(message, ...args);\n        break;\n      case 'error':\n        this.consoleError(message, ...args);\n        break;\n    }\n  }\n\n  /**\n   * Enables debug logging temporarily (useful for production debugging)\n   */\n  enableDebug(duration: number = 60000): void {\n    const originalLevels = this.config.enabledLevels;\n    \n    // Create new set with debug enabled\n    const newLevels = new Set<LogLevel>([...originalLevels, 'debug', 'info', 'group']);\n    (this.config as { enabledLevels: ReadonlySet<LogLevel> }).enabledLevels = newLevels;\n\n    this.info(`Debug logging enabled for ${duration}ms`);\n\n    // Restore original levels after duration\n    setTimeout(() => {\n      (this.config as { enabledLevels: ReadonlySet<LogLevel> }).enabledLevels = originalLevels;\n      this.info('Debug logging disabled');\n    }, duration);\n  }\n\n  /**\n   * Gets current logging configuration\n   */\n  getConfig(): Readonly<LoggerConfig> {\n    return this.config;\n  }\n\n  /**\n   * Gets recent log entries from the queue\n   */\n  getRecentLogs(count: number = 50): readonly LogEntry[] {\n    return this.logQueue\n      .slice(-count)\n      .map(({ args, ...entry }) => entry); // Remove args for external access\n  }\n\n  /**\n   * Clears the log queue\n   */\n  clearQueue(): void {\n    this.logQueue.length = 0;\n  }\n\n  /**\n   * Creates a child logger with a component prefix\n   */\n  createChildLogger(component: string): Logger {\n    const childLogger = new Logger(component);\n    \n    // Override log method to include component prefix\n    const originalLog = childLogger.log.bind(childLogger);\n    (childLogger as any).log = (level: LogLevel, message: string, ...args: unknown[]) => {\n      originalLog(level, `[${component}] ${message}`, ...args);\n    };\n\n    return childLogger;\n  }\n\n  /**\n   * Formats a timestamp for logging\n   */\n  static formatTimestamp(timestamp: number): string {\n    return new Date(timestamp).toISOString();\n  }\n\n  /**\n   * Safely stringifies an object for logging\n   */\n  static safeStringify(obj: unknown): string {\n    try {\n      return JSON.stringify(obj, null, 2);\n    } catch (error) {\n      return `[Object: ${String(obj)}]`;\n    }\n  }\n}\n\n// Create and export global logger instance\nexport const logger = new Logger('Global');\n\n// For backward compatibility with existing code\nif (typeof window !== 'undefined' && !logger.getConfig().isDevelopment) {\n  // In production, replace console methods with logger methods\n  console.debug = logger.debug.bind(logger);\n  console.info = logger.info.bind(logger);\n  console.group = logger.group.bind(logger);\n  console.groupEnd = logger.groupEnd.bind(logger);\n  console.groupCollapsed = logger.groupCollapsed.bind(logger);\n  // Leave warn and error as-is for production debugging\n}\n\n// Expose logger globally for manual use\nif (typeof window !== 'undefined') {\n  (window as any).logger = logger;\n}\n", "/**\n * Standardized error handling utility with TypeScript support\n * Provides unified error management across the GoldBox RPG client application\n */\n\nimport type { ErrorMetadata } from '../types/GameTypes';\nimport type { EventEmitterInterface } from '../types/UITypes';\nimport { logger } from './Logger';\n\nexport interface ErrorHandlerOptions {\n  readonly component: string;\n  readonly eventEmitter?: EventEmitterInterface | undefined;\n  readonly userMessageCallback?: ((message: string, type: 'error' | 'warning' | 'info') => void) | undefined;\n  readonly enableStackTrace?: boolean;\n  readonly enableMetadataLogging?: boolean;\n}\n\nexport interface ErrorContext {\n  readonly method: string;\n  readonly timestamp: number;\n  readonly metadata?: ErrorMetadata | undefined;\n  readonly stackTrace?: string | undefined;\n}\n\nexport class ErrorHandler {\n  private readonly component: string;\n  private readonly eventEmitter?: EventEmitterInterface | undefined;\n  private readonly userMessageCallback?: ((message: string, type: 'error' | 'warning' | 'info') => void) | undefined;\n  private readonly enableStackTrace: boolean;\n  private readonly enableMetadataLogging: boolean;\n  private readonly componentLogger: typeof logger;\n\n  constructor(options: ErrorHandlerOptions) {\n    this.component = options.component;\n    this.eventEmitter = options.eventEmitter;\n    this.userMessageCallback = options.userMessageCallback;\n    this.enableStackTrace = options.enableStackTrace ?? true;\n    this.enableMetadataLogging = options.enableMetadataLogging ?? true;\n    \n    // Create component-specific logger\n    this.componentLogger = logger.createChildLogger(this.component);\n  }\n\n  /**\n   * Handles recoverable errors that should not stop execution\n   * Logs error, emits event, and optionally shows user message\n   */\n  handleRecoverableError(\n    error: Error | string,\n    context: string,\n    userMessage?: string,\n    metadata: ErrorMetadata = {}\n  ): void {\n    const errorObj = this.normalizeError(error);\n    const errorContext = this.createErrorContext(context, metadata);\n    \n    // Always log with context\n    this.logError(errorObj, errorContext, 'warn');\n    \n    // Emit error event if event emitter is available\n    if (this.eventEmitter) {\n      this.eventEmitter.emit('error', {\n        error: errorObj,\n        context: errorContext,\n        recoverable: true,\n        userMessage\n      });\n    }\n    \n    // Show user message if callback is provided\n    if (userMessage && this.userMessageCallback) {\n      this.userMessageCallback(userMessage, 'warning');\n    }\n  }\n\n  /**\n   * Handles critical errors that should stop execution\n   * Logs error and throws it to stop execution flow\n   */\n  handleCriticalError(\n    error: Error | string,\n    context: string,\n    metadata: ErrorMetadata = {}\n  ): never {\n    const errorObj = this.normalizeError(error);\n    const errorContext = this.createErrorContext(context, metadata);\n    \n    // Log as error level\n    this.logError(errorObj, errorContext, 'error');\n    \n    // Emit error event if event emitter is available\n    if (this.eventEmitter) {\n      this.eventEmitter.emit('error', {\n        error: errorObj,\n        context: errorContext,\n        recoverable: false\n      });\n    }\n    \n    // Show critical error message\n    if (this.userMessageCallback) {\n      this.userMessageCallback(\n        `Critical error in ${this.component}: ${errorObj.message}`,\n        'error'\n      );\n    }\n    \n    // Always throw to stop execution\n    throw errorObj;\n  }\n\n  /**\n   * Handles initialization errors with cleanup\n   * Logs error, attempts cleanup, and throws\n   */\n  handleInitializationError(\n    error: Error | string,\n    context: string,\n    cleanupFn?: () => void,\n    metadata: ErrorMetadata = {}\n  ): never {\n    const errorObj = this.normalizeError(error);\n    const errorContext = this.createErrorContext(context, metadata);\n    \n    this.componentLogger.error(\n      `Initialization failed in ${context}:`,\n      errorObj,\n      errorContext\n    );\n    \n    // Attempt cleanup if provided\n    if (cleanupFn) {\n      try {\n        cleanupFn();\n        this.componentLogger.info('Cleanup completed after initialization failure');\n      } catch (cleanupError) {\n        this.componentLogger.error('Cleanup failed:', cleanupError);\n      }\n    }\n    \n    // Emit initialization error event\n    if (this.eventEmitter) {\n      this.eventEmitter.emit('initializationError', {\n        error: errorObj,\n        context: errorContext\n      });\n    }\n    \n    throw errorObj;\n  }\n\n  /**\n   * Wraps async operations with standardized error handling\n   */\n  wrapAsync<T, TArgs extends readonly unknown[]>(\n    asyncFn: (...args: TArgs) => Promise<T>,\n    context: string,\n    options: {\n      readonly userMessage?: string;\n      readonly critical?: boolean;\n      readonly metadata?: ErrorMetadata;\n      readonly onError?: (error: Error) => void;\n    } = {}\n  ): (...args: TArgs) => Promise<T> {\n    return async (...args: TArgs): Promise<T> => {\n      try {\n        return await asyncFn(...args);\n      } catch (error) {\n        const normalizedError = this.normalizeError(error);\n        \n        // Call custom error handler if provided\n        if (options.onError) {\n          try {\n            options.onError(normalizedError);\n          } catch (handlerError) {\n            this.componentLogger.error('Error in custom error handler:', handlerError);\n          }\n        }\n        \n        // Handle based on criticality\n        if (options.critical) {\n          this.handleCriticalError(normalizedError, context, options.metadata);\n        } else {\n          this.handleRecoverableError(\n            normalizedError,\n            context,\n            options.userMessage,\n            options.metadata\n          );\n          throw normalizedError; // Re-throw for async flow control\n        }\n      }\n    };\n  }\n\n  /**\n   * Creates a safe wrapper for synchronous operations\n   */\n  wrapSync<T, TArgs extends readonly unknown[]>(\n    syncFn: (...args: TArgs) => T,\n    context: string,\n    options: {\n      readonly userMessage?: string;\n      readonly critical?: boolean;\n      readonly metadata?: ErrorMetadata;\n      readonly defaultValue?: T;\n    } = {}\n  ): (...args: TArgs) => T {\n    return (...args: TArgs): T => {\n      try {\n        return syncFn(...args);\n      } catch (error) {\n        const normalizedError = this.normalizeError(error);\n        \n        if (options.critical) {\n          this.handleCriticalError(normalizedError, context, options.metadata);\n        } else {\n          this.handleRecoverableError(\n            normalizedError,\n            context,\n            options.userMessage,\n            options.metadata\n          );\n          \n          if (options.defaultValue !== undefined) {\n            return options.defaultValue;\n          }\n          throw normalizedError;\n        }\n      }\n    };\n  }\n\n  /**\n   * Normalizes different error types to Error objects\n   */\n  private normalizeError(error: unknown): Error {\n    if (error instanceof Error) {\n      return error;\n    }\n    \n    if (typeof error === 'string') {\n      return new Error(error);\n    }\n    \n    if (error && typeof error === 'object' && 'message' in error) {\n      return new Error(String(error.message));\n    }\n    \n    return new Error(`Unknown error: ${String(error)}`);\n  }\n\n  /**\n   * Creates error context with metadata\n   */\n  private createErrorContext(method: string, metadata: ErrorMetadata = {}): ErrorContext {\n    const stackTrace = this.enableStackTrace ? new Error().stack : undefined;\n    \n    return {\n      method,\n      timestamp: Date.now(),\n      metadata: this.enableMetadataLogging ? metadata : undefined,\n      stackTrace\n    };\n  }\n\n  /**\n   * Logs error with appropriate level and formatting\n   */\n  private logError(\n    error: Error,\n    context: ErrorContext,\n    level: 'warn' | 'error' = 'error'\n  ): void {\n    const logMessage = `${this.component}.${context.method}: ${error.message}`;\n    \n    const logData: Record<string, unknown> = {\n      error: {\n        name: error.name,\n        message: error.message,\n        stack: this.enableStackTrace ? error.stack : undefined\n      },\n      context\n    };\n    \n    if (level === 'error') {\n      this.componentLogger.error(logMessage, logData);\n    } else {\n      this.componentLogger.warn(logMessage, logData);\n    }\n  }\n\n  /**\n   * Gets the component name this error handler is associated with\n   */\n  getComponent(): string {\n    return this.component;\n  }\n\n  /**\n   * Checks if error handling is configured for user messages\n   */\n  hasUserMessageHandler(): boolean {\n    return this.userMessageCallback !== undefined;\n  }\n\n  /**\n   * Checks if error handling is configured for event emission\n   */\n  hasEventEmitter(): boolean {\n    return this.eventEmitter !== undefined;\n  }\n}\n\n/**\n * Creates a new error handler with the specified configuration\n */\nexport function createErrorHandler(options: ErrorHandlerOptions): ErrorHandler {\n  return new ErrorHandler(options);\n}\n\n/**\n * Global error handler factory for common use cases\n */\nexport class GlobalErrorHandler {\n  private static readonly handlers = new Map<string, ErrorHandler>();\n  \n  /**\n   * Gets or creates an error handler for a component\n   */\n  static getHandler(component: string, options?: Partial<ErrorHandlerOptions>): ErrorHandler {\n    if (!this.handlers.has(component)) {\n      this.handlers.set(component, new ErrorHandler({\n        component,\n        ...options\n      }));\n    }\n    \n    return this.handlers.get(component)!;\n  }\n  \n  /**\n   * Sets up global error handlers for unhandled errors\n   */\n  static setupGlobalHandlers(): void {\n    if (typeof window !== 'undefined') {\n      // Handle unhandled promise rejections\n      window.addEventListener('unhandledrejection', (event) => {\n        const handler = this.getHandler('GlobalPromiseRejection');\n        handler.handleRecoverableError(\n          event.reason,\n          'unhandledPromiseRejection',\n          'An unexpected error occurred',\n          { promise: event.promise }\n        );\n      });\n      \n      // Handle uncaught errors\n      window.addEventListener('error', (event) => {\n        const handler = this.getHandler('GlobalError');\n        handler.handleRecoverableError(\n          event.error || new Error(event.message),\n          'uncaughtError',\n          'An unexpected error occurred',\n          {\n            filename: event.filename,\n            lineno: event.lineno,\n            colno: event.colno\n          }\n        );\n      });\n    }\n  }\n  \n  /**\n   * Clears all cached error handlers\n   */\n  static clearHandlers(): void {\n    this.handlers.clear();\n  }\n}\n", "/**\n * Base component class providing common lifecycle and error handling patterns\n * Implements standardized initialization, update, and cleanup for game components\n */\n\nimport type { ComponentLifecycle, Service } from '../types/GameTypes';\nimport type { EventEmitterInterface } from '../types/UITypes';\nimport { EventEmitter } from './EventEmitter';\nimport { createErrorHandler, type ErrorHandler } from '@utils/ErrorHandler';\nimport { logger } from '@utils/Logger';\n\nexport interface BaseComponentOptions {\n  readonly name: string;\n  readonly enableEventEmission?: boolean;\n  readonly enableErrorHandling?: boolean;\n  readonly autoInitialize?: boolean;\n}\n\n/**\n * Base component class that provides:\n * - Standardized lifecycle management\n * - Error handling integration\n * - Event emission capabilities\n * - Initialization state tracking\n */\nexport abstract class BaseComponent implements ComponentLifecycle {\n  protected readonly componentName: string;\n  protected readonly eventEmitter: EventEmitterInterface;\n  protected readonly errorHandler: ErrorHandler;\n  protected readonly componentLogger: typeof logger;\n  \n  private _initialized = false;\n  private _destroyed = false;\n\n  constructor(options: BaseComponentOptions) {\n    this.componentName = options.name;\n    this.componentLogger = logger.createChildLogger(this.componentName);\n    \n    // Initialize event emitter if enabled\n    this.eventEmitter = options.enableEventEmission !== false \n      ? new EventEmitter() \n      : this.createNoOpEventEmitter();\n\n    // Initialize error handler\n    this.errorHandler = createErrorHandler({\n      component: this.componentName,\n      eventEmitter: this.eventEmitter,\n      enableStackTrace: true,\n      enableMetadataLogging: true\n    });\n\n    this.componentLogger.debug(`${this.componentName} component created`);\n\n    // Auto-initialize if requested\n    if (options.autoInitialize === true) {\n      this.safeInitialize();\n    }\n  }\n\n  /**\n   * Gets the component name\n   */\n  get name(): string {\n    return this.componentName;\n  }\n\n  /**\n   * Gets the initialization state\n   */\n  get initialized(): boolean {\n    return this._initialized;\n  }\n\n  /**\n   * Gets the destruction state\n   */\n  get destroyed(): boolean {\n    return this._destroyed;\n  }\n\n  /**\n   * Public initialize method with error handling and state management\n   */\n  async initialize(): Promise<void> {\n    if (this._initialized) {\n      this.componentLogger.warn('Component already initialized');\n      return;\n    }\n\n    if (this._destroyed) {\n      throw new Error('Cannot initialize destroyed component');\n    }\n\n    try {\n      this.componentLogger.info('Initializing component');\n      await this.onInitialize();\n      this._initialized = true;\n      this.eventEmitter.emit('initialized', { component: this.componentName });\n      this.componentLogger.info('Component initialized successfully');\n    } catch (error) {\n      this.errorHandler.handleInitializationError(\n        error instanceof Error ? error : new Error(String(error)),\n        'initialize',\n        () => this.onCleanup(),\n        { componentName: this.componentName }\n      );\n    }\n  }\n\n  /**\n   * Public cleanup method with error handling and state management\n   */\n  async cleanup(): Promise<void> {\n    if (this._destroyed) {\n      this.componentLogger.warn('Component already destroyed');\n      return;\n    }\n\n    try {\n      this.componentLogger.info('Cleaning up component');\n      await this.onCleanup();\n      this._destroyed = true;\n      this._initialized = false;\n      this.eventEmitter.emit('destroyed', { component: this.componentName });\n      this.eventEmitter.clear(); // Prevent memory leaks\n      this.componentLogger.info('Component cleaned up successfully');\n    } catch (error) {\n      this.errorHandler.handleRecoverableError(\n        error instanceof Error ? error : new Error(String(error)),\n        'cleanup',\n        undefined,\n        { componentName: this.componentName }\n      );\n    }\n  }\n\n  /**\n   * Update method for components that need regular updates\n   * Override in subclasses that need update functionality\n   */\n  update(deltaTime: number): void {\n    if (!this._initialized || this._destroyed) {\n      return;\n    }\n\n    try {\n      this.onUpdate(deltaTime);\n    } catch (error) {\n      this.errorHandler.handleRecoverableError(\n        error instanceof Error ? error : new Error(String(error)),\n        'update',\n        undefined,\n        { componentName: this.componentName, deltaTime }\n      );\n    }\n  }\n\n  /**\n   * Safe event emission that catches errors\n   */\n  protected emit<T = unknown>(event: string, data?: T): void {\n    try {\n      this.eventEmitter.emit(event, data);\n    } catch (error) {\n      this.errorHandler.handleRecoverableError(\n        error instanceof Error ? error : new Error(String(error)),\n        'emit',\n        undefined,\n        { event, data }\n      );\n    }\n  }\n\n  /**\n   * Safe event listener registration\n   */\n  protected on<T = unknown>(event: string, callback: (data: T) => void): () => void {\n    const wrappedCallback = this.errorHandler.wrapSync(\n      callback,\n      `eventListener:${event}`,\n      { \n        userMessage: 'An error occurred while handling an event',\n        metadata: { event }\n      }\n    );\n\n    return this.eventEmitter.on(event, wrappedCallback);\n  }\n\n  /**\n   * Assert component is initialized before operations\n   */\n  protected assertInitialized(): void {\n    if (!this._initialized) {\n      throw new Error(`Component ${this.componentName} is not initialized`);\n    }\n    if (this._destroyed) {\n      throw new Error(`Component ${this.componentName} has been destroyed`);\n    }\n  }\n\n  /**\n   * Wraps component methods with error handling\n   */\n  protected wrapMethod<T extends readonly unknown[]>(\n    method: (...args: T) => void,\n    methodName: string\n  ): (...args: T) => void {\n    return this.errorHandler.wrapSync(\n      method,\n      methodName,\n      {\n        metadata: { componentName: this.componentName }\n      }\n    );\n  }\n\n  /**\n   * Wraps async component methods with error handling\n   */\n  protected wrapAsyncMethod<T extends readonly unknown[], R>(\n    method: (...args: T) => Promise<R>,\n    methodName: string\n  ): (...args: T) => Promise<R> {\n    return this.errorHandler.wrapAsync(\n      method,\n      methodName,\n      {\n        metadata: { componentName: this.componentName }\n      }\n    );\n  }\n\n  // Abstract methods that subclasses must implement\n\n  /**\n   * Override to implement component-specific initialization logic\n   */\n  protected abstract onInitialize(): Promise<void> | void;\n\n  /**\n   * Override to implement component-specific cleanup logic\n   */\n  protected abstract onCleanup(): Promise<void> | void;\n\n  /**\n   * Override to implement component-specific update logic\n   * Only called if component is initialized and not destroyed\n   */\n  protected onUpdate(_deltaTime: number): void {\n    // Default implementation does nothing\n    // Subclasses can override if they need update functionality\n  }\n\n  // Private helper methods\n\n  private async safeInitialize(): Promise<void> {\n    try {\n      await this.initialize();\n    } catch (error) {\n      this.componentLogger.error('Auto-initialization failed:', error);\n    }\n  }\n\n  private createNoOpEventEmitter(): EventEmitterInterface {\n    return {\n      on: () => () => {},\n      emit: () => {},\n      off: () => false,\n      removeAllListeners: () => {},\n      clear: () => {},\n      listenerCount: () => 0,\n      eventNames: () => []\n    };\n  }\n}\n\n/**\n * Service base class that extends BaseComponent with service-specific features\n */\nexport abstract class BaseService extends BaseComponent implements Service {\n  constructor(name: string, options: Partial<BaseComponentOptions> = {}) {\n    super({\n      name,\n      enableEventEmission: true,\n      enableErrorHandling: true,\n      ...options\n    });\n  }\n\n  /**\n   * Service-specific start method\n   * Override to implement service startup logic\n   */\n  async start(): Promise<void> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n    await this.onStart();\n    this.emit('started', { service: this.name });\n  }\n\n  /**\n   * Service-specific stop method\n   * Override to implement service shutdown logic\n   */\n  async stop(): Promise<void> {\n    await this.onStop();\n    await this.cleanup();\n    this.emit('stopped', { service: this.name });\n  }\n\n  /**\n   * Override to implement service-specific start logic\n   */\n  protected async onStart(): Promise<void> {\n    // Default implementation does nothing\n  }\n\n  /**\n   * Override to implement service-specific stop logic\n   */\n  protected async onStop(): Promise<void> {\n    // Default implementation does nothing\n  }\n}\n\n/**\n * Component manager for handling multiple components\n */\nexport class ComponentManager {\n  private readonly components = new Map<string, BaseComponent>();\n  private readonly logger = logger.createChildLogger('ComponentManager');\n\n  /**\n   * Register a component\n   */\n  register(component: BaseComponent): void {\n    if (this.components.has(component.name)) {\n      throw new Error(`Component ${component.name} is already registered`);\n    }\n\n    this.components.set(component.name, component);\n    this.logger.debug(`Registered component: ${component.name}`);\n  }\n\n  /**\n   * Get a component by name\n   */\n  get<T extends BaseComponent>(name: string): T | undefined {\n    return this.components.get(name) as T | undefined;\n  }\n\n  /**\n   * Initialize all registered components\n   */\n  async initializeAll(): Promise<void> {\n    this.logger.info('Initializing all components');\n    \n    const initPromises = Array.from(this.components.values()).map(\n      component => component.initialize()\n    );\n\n    await Promise.all(initPromises);\n    this.logger.info('All components initialized');\n  }\n\n  /**\n   * Cleanup all registered components\n   */\n  async cleanupAll(): Promise<void> {\n    this.logger.info('Cleaning up all components');\n    \n    const cleanupPromises = Array.from(this.components.values()).map(\n      component => component.cleanup()\n    );\n\n    await Promise.all(cleanupPromises);\n    this.components.clear();\n    this.logger.info('All components cleaned up');\n  }\n\n  /**\n   * Update all components\n   */\n  updateAll(deltaTime: number): void {\n    for (const component of this.components.values()) {\n      component.update(deltaTime);\n    }\n  }\n\n  /**\n   * Get all registered component names\n   */\n  getComponentNames(): string[] {\n    return Array.from(this.components.keys());\n  }\n\n  /**\n   * Get component count\n   */\n  getComponentCount(): number {\n    return this.components.size;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
