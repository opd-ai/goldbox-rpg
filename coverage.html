
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">goldbox-rpg/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">goldbox-rpg/pkg/config/loader.go (100.0%)</option>
				
				<option value="file2">goldbox-rpg/pkg/game/character.go (71.1%)</option>
				
				<option value="file3">goldbox-rpg/pkg/game/character_creation.go (88.7%)</option>
				
				<option value="file4">goldbox-rpg/pkg/game/classes.go (83.3%)</option>
				
				<option value="file5">goldbox-rpg/pkg/game/default_world.go (100.0%)</option>
				
				<option value="file6">goldbox-rpg/pkg/game/dice.go (93.2%)</option>
				
				<option value="file7">goldbox-rpg/pkg/game/dispel_info.go (100.0%)</option>
				
				<option value="file8">goldbox-rpg/pkg/game/duration.go (100.0%)</option>
				
				<option value="file9">goldbox-rpg/pkg/game/effectbehavior.go (42.6%)</option>
				
				<option value="file10">goldbox-rpg/pkg/game/effectimmunity.go (100.0%)</option>
				
				<option value="file11">goldbox-rpg/pkg/game/effectmanager.go (39.3%)</option>
				
				<option value="file12">goldbox-rpg/pkg/game/effects.go (93.1%)</option>
				
				<option value="file13">goldbox-rpg/pkg/game/equipment.go (100.0%)</option>
				
				<option value="file14">goldbox-rpg/pkg/game/events.go (100.0%)</option>
				
				<option value="file15">goldbox-rpg/pkg/game/item.go (100.0%)</option>
				
				<option value="file16">goldbox-rpg/pkg/game/logger.go (100.0%)</option>
				
				<option value="file17">goldbox-rpg/pkg/game/map.go (100.0%)</option>
				
				<option value="file18">goldbox-rpg/pkg/game/modifier.go (100.0%)</option>
				
				<option value="file19">goldbox-rpg/pkg/game/player.go (52.0%)</option>
				
				<option value="file20">goldbox-rpg/pkg/game/spatial_index.go (87.0%)</option>
				
				<option value="file21">goldbox-rpg/pkg/game/spell.go (73.3%)</option>
				
				<option value="file22">goldbox-rpg/pkg/game/spell_manager.go (55.4%)</option>
				
				<option value="file23">goldbox-rpg/pkg/game/tile.go (100.0%)</option>
				
				<option value="file24">goldbox-rpg/pkg/game/utils.go (70.3%)</option>
				
				<option value="file25">goldbox-rpg/pkg/game/world.go (89.5%)</option>
				
				<option value="file26">goldbox-rpg/pkg/game/world_types.go (100.0%)</option>
				
				<option value="file27">goldbox-rpg/pkg/pcg/demo/metrics_demo.go (0.0%)</option>
				
				<option value="file28">goldbox-rpg/pkg/pcg/items/enchantments.go (85.1%)</option>
				
				<option value="file29">goldbox-rpg/pkg/pcg/items/generator.go (77.8%)</option>
				
				<option value="file30">goldbox-rpg/pkg/pcg/items/templates.go (91.7%)</option>
				
				<option value="file31">goldbox-rpg/pkg/pcg/levels/corridors.go (92.2%)</option>
				
				<option value="file32">goldbox-rpg/pkg/pcg/levels/demo/main.go (0.0%)</option>
				
				<option value="file33">goldbox-rpg/pkg/pcg/levels/generator.go (89.6%)</option>
				
				<option value="file34">goldbox-rpg/pkg/pcg/levels/rooms.go (69.5%)</option>
				
				<option value="file35">goldbox-rpg/pkg/pcg/manager.go (0.0%)</option>
				
				<option value="file36">goldbox-rpg/pkg/pcg/metrics.go (100.0%)</option>
				
				<option value="file37">goldbox-rpg/pkg/pcg/quests/generator.go (92.9%)</option>
				
				<option value="file38">goldbox-rpg/pkg/pcg/quests/narratives.go (97.7%)</option>
				
				<option value="file39">goldbox-rpg/pkg/pcg/quests/objectives.go (88.8%)</option>
				
				<option value="file40">goldbox-rpg/pkg/pcg/registry.go (0.0%)</option>
				
				<option value="file41">goldbox-rpg/pkg/pcg/seed.go (0.0%)</option>
				
				<option value="file42">goldbox-rpg/pkg/pcg/terrain/biomes.go (92.3%)</option>
				
				<option value="file43">goldbox-rpg/pkg/pcg/terrain/cellular_automata.go (95.7%)</option>
				
				<option value="file44">goldbox-rpg/pkg/pcg/terrain/generator.go (0.0%)</option>
				
				<option value="file45">goldbox-rpg/pkg/pcg/terrain/maze.go (89.8%)</option>
				
				<option value="file46">goldbox-rpg/pkg/pcg/types.go (0.0%)</option>
				
				<option value="file47">goldbox-rpg/pkg/pcg/utils/noise.go (90.4%)</option>
				
				<option value="file48">goldbox-rpg/pkg/pcg/utils/pathfinding.go (95.7%)</option>
				
				<option value="file49">goldbox-rpg/pkg/pcg/validation.go (0.0%)</option>
				
				<option value="file50">goldbox-rpg/pkg/server/combat.go (28.6%)</option>
				
				<option value="file51">goldbox-rpg/pkg/server/handlers.go (43.4%)</option>
				
				<option value="file52">goldbox-rpg/pkg/server/movement.go (100.0%)</option>
				
				<option value="file53">goldbox-rpg/pkg/server/process.go (0.0%)</option>
				
				<option value="file54">goldbox-rpg/pkg/server/server.go (20.3%)</option>
				
				<option value="file55">goldbox-rpg/pkg/server/session.go (90.6%)</option>
				
				<option value="file56">goldbox-rpg/pkg/server/spell.go (90.0%)</option>
				
				<option value="file57">goldbox-rpg/pkg/server/spells.go (62.8%)</option>
				
				<option value="file58">goldbox-rpg/pkg/server/state.go (3.9%)</option>
				
				<option value="file59">goldbox-rpg/pkg/server/types.go (100.0%)</option>
				
				<option value="file60">goldbox-rpg/pkg/server/util.go (45.5%)</option>
				
				<option value="file61">goldbox-rpg/pkg/server/websocket.go (55.7%)</option>
				
				<option value="file62">goldbox-rpg/scripts/find_untested_files.go (64.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "goldbox-rpg/pkg/server"
        "log"
        "net"
        "os"
        "path/filepath"
)

func main() <span class="cov0" title="0">{
        // Get absolute path to web directory
        wd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get working directory: %v", err)
        }</span>

        <span class="cov0" title="0">webDir := filepath.Join(wd, "web")

        // Create new server instance
        server, err := server.NewRPCServer(webDir)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize server: %v", err)
        }</span>
        <span class="cov0" title="0">listener, err := net.Listen("tcp", ":8080")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start listener: %v", err)
        }</span>

        // Start server on port 8080
        <span class="cov0" title="0">log.Printf("Starting server on :8080...")
        if err := server.Serve(listener); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server failed to start: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "os"

        "goldbox-rpg/pkg/game" // Updated from internal to pkg

        "gopkg.in/yaml.v3"
)

// LoadItems loads item definitions from a YAML file and returns them as a slice of game.Item.
//
// Parameters:
//   - filename: Path to the YAML file containing item definitions
//
// Returns:
//   - []game.Item: Slice of parsed item objects
//   - error: File read or YAML parsing errors if any occurred
//
// The function reads the entire file contents and unmarshals them as YAML into a slice
// of game.Item structs. It handles two main error cases:
//  1. File read errors (missing file, permissions, etc)
//  2. YAML parsing errors (invalid format, missing required fields)
//
// Related types:
//   - game.Item: The target struct for item definitions
func LoadItems(filename string) ([]game.Item, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var items []game.Item
        if err := yaml.Unmarshal(data, &amp;items); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package game

import (
        "encoding/json"
        "fmt"
        "strings"
        "sync"
)

// Character represents the base attributes for both Players and NPCs
// Contains all attributes, stats, and equipment for game entities
// Character represents a playable character or NPC in the game world.
// It encapsulates all attributes, stats, and inventory management for characters.
//
// Key features:
// - Thread-safe with sync.RWMutex protection
// - Complete attribute system (Strength, Dexterity etc)
// - Combat stats tracking (HP, AC, THAC0)
// - Equipment and inventory management
// - Position tracking in game world
// - Tagging system for special attributes
//
// The Character struct uses YAML tags for persistence and serialization.
// All numeric fields use int type for simplicity and compatibility.
//
// Related types:
// - Position: Represents location in game world
// - Item: Represents equipment and inventory items
// - EquipmentSlot: Equipment slot enumeration
//
// Thread safety:
// All operations that modify Character fields should hold mu.Lock()
// Read operations should hold mu.RLock()
type Character struct {
        mu          sync.RWMutex `yaml:"-"`                // Protects concurrent access to character data
        ID          string       `yaml:"char_id"`          // Unique identifier
        Name        string       `yaml:"char_name"`        // Character's name
        Description string       `yaml:"char_description"` // Character's description
        Position    Position     `yaml:"char_position"`    // Current location in game world

        // Character class
        Class CharacterClass `yaml:"char_class"` // Character's class (Fighter, Mage, etc.)

        // Attributes
        Strength     int `yaml:"attr_strength"`     // Physical power
        Dexterity    int `yaml:"attr_dexterity"`    // Agility and reflexes
        Constitution int `yaml:"attr_constitution"` // Health and stamina
        Intelligence int `yaml:"attr_intelligence"` // Learning and reasoning
        Wisdom       int `yaml:"attr_wisdom"`       // Intuition and perception
        Charisma     int `yaml:"attr_charisma"`     // Leadership and personality

        // Combat stats
        HP         int `yaml:"combat_current_hp"`  // Current hit points
        MaxHP      int `yaml:"combat_max_hp"`      // Maximum hit points
        ArmorClass int `yaml:"combat_armor_class"` // Defense rating
        THAC0      int `yaml:"combat_thac0"`       // To Hit Armor Class 0

        // Action points for turn-based combat
        ActionPoints    int `yaml:"combat_action_points"`     // Current action points available
        MaxActionPoints int `yaml:"combat_max_action_points"` // Maximum action points per turn

        // Character progression
        Level      int   `yaml:"char_level"`      // Current character level
        Experience int64 `yaml:"char_experience"` // Experience points accumulated

        // Equipment and inventory
        Equipment map[EquipmentSlot]Item `yaml:"char_equipment"` // Equipped items by slot
        Inventory []Item                 `yaml:"char_inventory"` // Carried items
        Gold      int                    `yaml:"char_gold"`      // Currency amount

        // Effect management
        EffectManager *EffectManager `yaml:"-"` // Manages active effects on character

        active bool     `yaml:"char_active"` // Whether character is active in game
        tags   []string `yaml:"char_tags"`   // Special attributes or markers
}

// Clone creates and returns a deep copy of the Character.
// This method is thread-safe and creates a completely independent copy
// of the character including all nested structures.
//
// Returns:
//   - *Character: A pointer to the new cloned Character instance
//
// Thread safety:
//   - Uses RLock to ensure safe concurrent access during cloning
func (c *Character) Clone() *Character <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        clone := &amp;Character{
                ID:              c.ID,
                Name:            c.Name,
                Description:     c.Description,
                Position:        c.Position,
                Class:           c.Class,
                Strength:        c.Strength,
                Dexterity:       c.Dexterity,
                Constitution:    c.Constitution,
                Intelligence:    c.Intelligence,
                Wisdom:          c.Wisdom,
                Charisma:        c.Charisma,
                HP:              c.HP,
                MaxHP:           c.MaxHP,
                ArmorClass:      c.ArmorClass,
                THAC0:           c.THAC0,
                ActionPoints:    c.ActionPoints,
                MaxActionPoints: c.MaxActionPoints,
                Level:           c.Level,
                Experience:      c.Experience,
                Equipment:       make(map[EquipmentSlot]Item),
                Inventory:       make([]Item, len(c.Inventory)),
                Gold:            c.Gold,
                active:          c.active,
                tags:            make([]string, len(c.tags)),
        }

        // Deep copy equipment map
        for slot, item := range c.Equipment </span><span class="cov0" title="0">{
                clone.Equipment[slot] = item
        }</span>

        // Deep copy inventory slice
        <span class="cov8" title="1">copy(clone.Inventory, c.Inventory)

        // Deep copy tags slice
        copy(clone.tags, c.tags)

        // Initialize EffectManager for the clone
        clone.ensureEffectManager()

        return clone</span>
}

// GetHealth returns the current hit points (HP) of the Character.
//
// Returns:
//   - int: The current health points value
//
// Related:
//   - Character.HP field
//   - Character.SetHealth (if exists)
func (c *Character) GetHealth() int <span class="cov8" title="1">{
        return c.HP
}</span>

// IsObstacle indicates if this Character should be treated as an obstacle for movement/pathing.
// In the current implementation, all Characters are always considered obstacles.
//
// Returns:
//   - bool: Always returns true since Characters are obstacles by default
//
// Related:
//   - Used by pathing and collision detection systems
func (c *Character) IsObstacle() bool <span class="cov8" title="1">{
        // Characters are considered obstacles for movement/pathing
        return true
}</span>

// SetHealth updates the character's current health points (HP) with the provided value.
// The health value will be constrained between 0 and the character's maximum HP.
//
// Parameters:
//   - health: The new health value to set (integer)
//
// Edge cases handled:
//   - Health below 0 is capped at 0
//   - Health above MaxHP is capped at MaxHP
//
// Related fields:
//   - Character.HP
//   - Character.MaxHP
func (c *Character) SetHealth(health int) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.HP = health
        // Ensure health doesn't go below 0
        if c.HP &lt; 0 </span><span class="cov8" title="1">{
                c.HP = 0
        }</span>
        // Cap health at max health
        <span class="cov8" title="1">if c.HP &gt; c.MaxHP </span><span class="cov8" title="1">{
                c.HP = c.MaxHP
        }</span>
}

// GetActionPoints returns the character's current action points.
// This method is thread-safe.
//
// Returns:
//   - int: The character's current action points
func (c *Character) GetActionPoints() int <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.ActionPoints
}</span>

// SetActionPoints sets the character's current action points.
// This method is thread-safe and ensures action points don't exceed MaxActionPoints or go below 0.
//
// Parameters:
//   - actionPoints: The new action points value to set
func (c *Character) SetActionPoints(actionPoints int) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.ActionPoints = actionPoints
        // Ensure action points don't go below 0
        if c.ActionPoints &lt; 0 </span><span class="cov0" title="0">{
                c.ActionPoints = 0
        }</span>
        // Cap action points at max action points
        <span class="cov0" title="0">if c.ActionPoints &gt; c.MaxActionPoints </span><span class="cov0" title="0">{
                c.ActionPoints = c.MaxActionPoints
        }</span>
}

// GetMaxActionPoints returns the character's maximum action points.
// This method is thread-safe.
//
// Returns:
//   - int: The character's maximum action points
func (c *Character) GetMaxActionPoints() int <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.MaxActionPoints
}</span>

// ConsumeActionPoints deducts the specified amount from the character's current action points.
// This method is thread-safe and ensures action points don't go below 0.
//
// Parameters:
//   - cost: The amount of action points to consume
//
// Returns:
//   - bool: true if the action points were successfully consumed, false if insufficient
func (c *Character) ConsumeActionPoints(cost int) bool <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.ActionPoints &lt; cost </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">c.ActionPoints -= cost
        return true</span>
}

// RestoreActionPoints restores the character's action points to their maximum value.
// This is typically called at the start of a new turn.
// This method is thread-safe.
func (c *Character) RestoreActionPoints() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.ActionPoints = c.MaxActionPoints
}</span>

// Implement GameObject interface methods

// GetID returns the unique identifier string for this Character instance.
// It uses a read lock to safely access the ID field in a concurrent context.
// Returns the character's unique ID string.
// Related: Character struct, ID field
func (c *Character) GetID() string <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.ID
}</span>

// GetName returns the name of the Character.
//
// This method is thread-safe and uses a read lock to safely access the character's name.
//
// Returns:
//   - string: The name of the character
//
// Related:
//   - Character struct
func (c *Character) GetName() string <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Name
}</span>

// GetDescription returns the character's description as a string.
// This method is thread-safe as it uses a read lock when accessing the description field.
// Returns:
//   - string: The character's description text
//
// Related:
//   - Character struct
//   - Character.SetDescription()
func (c *Character) GetDescription() string <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Description
}</span>

// GetPosition returns the current position of the Character.
// This method is thread-safe and uses read locking to protect concurrent access.
// Returns a Position struct containing the character's x,y coordinates.
// Related types:
// - Position struct
func (c *Character) GetPosition() Position <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Position
}</span>

// SetPosition updates the character's position to the specified coordinates after validation.
//
// Parameters:
//   - pos Position: The new position coordinates to set
//
// Returns:
//   - error: nil if successful, error if position is invalid
func (c *Character) SetPosition(pos Position) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Validate position before setting
        if !isValidPosition(pos, 100, 100, 10) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid position: %v", pos)
        }</span>

        <span class="cov8" title="1">c.Position = pos
        return nil</span>
}

// SetPositionWithBounds updates the character's position with map bounds validation.
//
// Parameters:
//   - pos Position: The new position coordinates to set
//   - width, height, maxLevel: map bounds for validation
//
// Returns:
//   - error: nil if successful, error if position is invalid
func (c *Character) SetPositionWithBounds(pos Position, width, height, maxLevel int) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if !isValidPosition(pos, width, height, maxLevel) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid position: %v", pos)
        }</span>

        <span class="cov8" title="1">c.Position = pos
        return nil</span>
}

// IsActive returns the current active state of the Character.
// This method is concurrent-safe through use of a read lock.
//
// Returns:
//   - bool: true if the character is active, false otherwise
//
// Thread-safety: This method uses RLock/RUnlock for concurrent access
func (c *Character) IsActive() bool <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.active
}</span>

// SetActive sets the active state of the character.
// Thread-safe method that controls whether the character is active in the game.
//
// Parameters:
//   - active: bool - The desired active state for the character
//
// Thread safety:
//
//        Uses mutex locking to ensure thread-safe access to the active state
//
// Related:
//   - Character struct (contains the active field being modified)
func (c *Character) SetActive(active bool) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.active = active
}</span>

// GetTags returns a copy of the character's tags list.
//
// This method provides thread-safe access to the character's tags by using a read lock.
// A new slice containing copies of all tags is returned to prevent external modifications
// to the character's internal state.
//
// Returns:
//
//        []string - A new slice containing copies of all the character's tags
//
// Related:
//
//        Character.AddTag() - For adding new tags
//        Character.RemoveTag() - For removing existing tags
func (c *Character) GetTags() []string <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return append([]string{}, c.tags...) // Return copy to prevent modification
}</span>

// ToJSON serializes the Character struct to JSON format with thread safety.
//
// This method acquires a read lock on the character to ensure safe concurrent access
// during serialization.
//
// Returns:
//   - []byte: The JSON encoded representation of the Character
//   - error: Any error that occurred during marshaling
//
// Related:
//   - FromJSON() for deserialization
//   - json.Marshal() from encoding/json
func (c *Character) ToJSON() ([]byte, error) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return json.Marshal(c)
}</span>

// FromJSON unmarshals a JSON byte array into the Character struct.
// This method is thread-safe as it uses a mutex lock.
//
// Parameters:
//   - data []byte: JSON encoded byte array containing character data
//
// Returns:
//   - error: Returns any error that occurred during unmarshaling
//
// Related:
//   - Character.ToJSON() for serialization
//   - json.Unmarshal() from encoding/json package
func (c *Character) FromJSON(data []byte) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        return json.Unmarshal(data, c)
}</span>

// Equipment Management Methods

// EquipItem equips an item from the character's inventory to the specified equipment slot.
// It validates that the item can be equipped in the slot and handles slot conflicts.
//
// Parameters:
//   - itemID: The unique identifier of the item to equip
//   - slot: The equipment slot where the item should be equipped
//
// Returns:
//   - error: Returns nil on success, or an error describing why the item cannot be equipped
//
// Errors:
//   - Returns error if item is not found in inventory
//   - Returns error if item type is not valid for the specified slot
//   - Returns error if slot is already occupied (unless item is stackable)
//   - Returns error if character doesn't meet requirements for the item
//
// Thread safety: This method is thread-safe using mutex locking
func (c *Character) EquipItem(itemID string, slot EquipmentSlot) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        itemIndex, itemToEquip, err := c.findItemInInventory(itemID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.validateItemCanBeEquipped(itemToEquip, slot); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.handleSlotConflict(slot); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">c.equipItemToSlot(itemToEquip, slot)
        c.removeItemFromInventoryByIndex(itemIndex)

        return nil</span>
}

// findItemInInventory searches for the item by ID and returns its index and value.
// Returns an error if not found.
func (c *Character) findItemInInventory(itemID string) (int, Item, error) <span class="cov8" title="1">{
        for i, item := range c.Inventory </span><span class="cov8" title="1">{
                if item.ID == itemID </span><span class="cov8" title="1">{
                        return i, item, nil
                }</span>
        }
        <span class="cov8" title="1">return -1, Item{}, fmt.Errorf("item not found in inventory: %s", itemID)</span>
}

// validateItemCanBeEquipped checks if the item can be equipped in the specified slot.
// Returns an error if validation fails.
func (c *Character) validateItemCanBeEquipped(item Item, slot EquipmentSlot) error <span class="cov8" title="1">{
        if !c.canEquipItemInSlot(item, slot) </span><span class="cov8" title="1">{
                return fmt.Errorf("item %s cannot be equipped in slot %s", item.Name, slot.String())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// handleSlotConflict unequips any existing item in the slot, if present.
// Returns an error if unequipping fails.
func (c *Character) handleSlotConflict(slot EquipmentSlot) error <span class="cov8" title="1">{
        if existingItem, exists := c.Equipment[slot]; exists </span><span class="cov0" title="0">{
                if _, err := c.unequipItemFromSlot(slot); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unequip existing item %s: %v", existingItem.Name, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// equipItemToSlot assigns the item to the specified equipment slot.
func (c *Character) equipItemToSlot(item Item, slot EquipmentSlot) <span class="cov8" title="1">{
        c.Equipment[slot] = item
}</span>

// removeItemFromInventoryByIndex removes the item at the specified index from inventory.
func (c *Character) removeItemFromInventoryByIndex(index int) <span class="cov8" title="1">{
        c.Inventory = append(c.Inventory[:index], c.Inventory[index+1:]...)
}</span>

// UnequipItem removes an item from the specified equipment slot and adds it to the character's inventory.
//
// Parameters:
//   - slot: The equipment slot to unequip
//
// Returns:
//   - *Item: Pointer to the unequipped item, or nil if slot was empty
//   - error: Returns nil on success, or an error if the operation fails
//
// Thread safety: This method is thread-safe using mutex locking
func (c *Character) UnequipItem(slot EquipmentSlot) (*Item, error) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        return c.unequipItemFromSlot(slot)
}</span>

// unequipItemFromSlot is the internal implementation of unequipping an item (requires lock to be held)
func (c *Character) unequipItemFromSlot(slot EquipmentSlot) (*Item, error) <span class="cov8" title="1">{
        // Check if there's an item equipped in this slot
        equippedItem, exists := c.Equipment[slot]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no item equipped in slot %s", slot.String())
        }</span>

        // Add the item back to inventory
        <span class="cov8" title="1">c.Inventory = append(c.Inventory, equippedItem)

        // Remove from equipment slot
        delete(c.Equipment, slot)

        return &amp;equippedItem, nil</span>
}

// CanEquipItem checks if the character can equip the specified item in the given slot.
// This performs all validation checks without actually equipping the item.
//
// Parameters:
//   - itemID: The unique identifier of the item to check
//   - slot: The equipment slot to check compatibility with
//
// Returns:
//   - bool: true if the item can be equipped, false otherwise
//   - error: Returns nil if check was successful, or an error if validation fails
//
// Thread safety: This method is thread-safe using read mutex locking
func (c *Character) CanEquipItem(itemID string, slot EquipmentSlot) (bool, error) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        // Find the item in inventory
        var itemToCheck Item
        found := false
        for _, item := range c.Inventory </span><span class="cov8" title="1">{
                if item.ID == itemID </span><span class="cov8" title="1">{
                        itemToCheck = item
                        found = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return false, fmt.Errorf("item not found in inventory: %s", itemID)
        }</span>

        <span class="cov8" title="1">return c.canEquipItemInSlot(itemToCheck, slot), nil</span>
}

// canEquipItemInSlot is the internal validation logic for equipment compatibility
func (c *Character) canEquipItemInSlot(item Item, slot EquipmentSlot) bool <span class="cov8" title="1">{
        if !c.isItemTypeValidForSlot(item, slot) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">proficiencies := GetClassProficiencies(c.Class)

        if c.isWeaponSlot(slot) </span><span class="cov8" title="1">{
                return c.canEquipWeaponInSlot(item, slot, proficiencies)
        }</span>

        <span class="cov8" title="1">if c.isArmorSlot(slot) </span><span class="cov8" title="1">{
                return c.canEquipArmorInSlot(item, proficiencies)
        }</span>

        <span class="cov0" title="0">return true</span>
}

// isItemTypeValidForSlot checks if the item type is valid for the specified equipment slot.
// It returns true if the item can be placed in the slot based on type compatibility.
func (c *Character) isItemTypeValidForSlot(item Item, slot EquipmentSlot) bool <span class="cov8" title="1">{
        slotValidTypes := c.getSlotValidTypes()

        validTypes, exists := slotValidTypes[slot]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for _, validType := range validTypes </span><span class="cov8" title="1">{
                if item.Type == validType </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// getSlotValidTypes returns the mapping of equipment slots to their valid item types.
// This defines which item types can be equipped in each slot.
func (c *Character) getSlotValidTypes() map[EquipmentSlot][]string <span class="cov8" title="1">{
        return map[EquipmentSlot][]string{
                SlotHead:       {"helmet", "hat", "crown", "circlet"},
                SlotNeck:       {"amulet", "necklace", "pendant"},
                SlotChest:      {"armor", "robe", "shirt", "vest"},
                SlotHands:      {"gloves", "gauntlets", "bracers"},
                SlotRings:      {"ring"},
                SlotLegs:       {"pants", "leggings", "greaves"},
                SlotFeet:       {"boots", "shoes", "sandals"},
                SlotWeaponMain: {"weapon", "sword", "axe", "staff", "bow", "dagger", "mace", "spear", "hammer", "wand"},
                SlotWeaponOff:  {"shield", "weapon", "dagger", "orb"},
        }
}</span>

// isWeaponSlot checks if the given slot is a weapon slot.
// It returns true for main hand and off-hand weapon slots.
func (c *Character) isWeaponSlot(slot EquipmentSlot) bool <span class="cov8" title="1">{
        return slot == SlotWeaponMain || slot == SlotWeaponOff
}</span>

// isArmorSlot checks if the given slot is an armor slot.
// It returns true for head, chest, hands, legs, and feet slots.
func (c *Character) isArmorSlot(slot EquipmentSlot) bool <span class="cov8" title="1">{
        return slot == SlotHead || slot == SlotChest || slot == SlotHands || slot == SlotLegs || slot == SlotFeet
}</span>

// canEquipWeaponInSlot validates if a character can equip a weapon in the specified slot.
// It checks weapon proficiencies and special shield handling for off-hand slots.
func (c *Character) canEquipWeaponInSlot(item Item, slot EquipmentSlot, proficiencies ClassProficiencies) bool <span class="cov8" title="1">{
        // Special handling for shields in off-hand slot
        if slot == SlotWeaponOff &amp;&amp; item.Type == "shield" </span><span class="cov8" title="1">{
                return proficiencies.ShieldProficient
        }</span>

        // Allow generic "weapon" type if character has any weapon proficiencies
        <span class="cov8" title="1">if item.Type == "weapon" &amp;&amp; len(proficiencies.WeaponTypes) &gt; 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check for specific weapon type match
        <span class="cov8" title="1">for _, allowedWeapon := range proficiencies.WeaponTypes </span><span class="cov8" title="1">{
                if item.Type == allowedWeapon </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// canEquipArmorInSlot validates if a character can equip armor in the specified slot.
// It checks armor proficiencies and determines armor type based on item properties.
func (c *Character) canEquipArmorInSlot(item Item, proficiencies ClassProficiencies) bool <span class="cov8" title="1">{
        if !c.isArmorItem(item) </span><span class="cov0" title="0">{
                return true // Non-armor items don't require armor proficiency
        }</span>

        <span class="cov8" title="1">armorType := determineArmorType(item)

        for _, allowedArmor := range proficiencies.ArmorTypes </span><span class="cov8" title="1">{
                if armorType == allowedArmor </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isArmorItem checks if the item is considered armor that requires proficiency.
// It returns true for items that are classified as armor types.
func (c *Character) isArmorItem(item Item) bool <span class="cov8" title="1">{
        return item.Type == "armor" || item.Type == "helmet" || item.Type == "gauntlets" || item.Type == "greaves"
}</span>

// GetEquippedItem returns the item equipped in the specified slot.
//
// Parameters:
//   - slot: The equipment slot to check
//
// Returns:
//   - *Item: Pointer to the equipped item, or nil if slot is empty
//   - bool: true if an item is equipped in the slot, false otherwise
//
// Thread safety: This method is thread-safe using read mutex locking
func (c *Character) GetEquippedItem(slot EquipmentSlot) (*Item, bool) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if item, exists := c.Equipment[slot]; exists </span><span class="cov0" title="0">{
                return &amp;item, true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

// GetAllEquippedItems returns a copy of all currently equipped items.
//
// Returns:
//   - map[EquipmentSlot]Item: A map containing all equipped items by slot
//
// Thread safety: This method is thread-safe using read mutex locking
func (c *Character) GetAllEquippedItems() map[EquipmentSlot]Item <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        equippedItems := make(map[EquipmentSlot]Item)
        for slot, item := range c.Equipment </span><span class="cov0" title="0">{
                equippedItems[slot] = item
        }</span>
        <span class="cov0" title="0">return equippedItems</span>
}

// GetEquipmentSlots returns all available equipment slots for this character.
//
// Returns:
//   - []EquipmentSlot: Slice containing all valid equipment slot types
func (c *Character) GetEquipmentSlots() []EquipmentSlot <span class="cov0" title="0">{
        return []EquipmentSlot{
                SlotHead, SlotNeck, SlotChest, SlotHands, SlotRings,
                SlotLegs, SlotFeet, SlotWeaponMain, SlotWeaponOff,
        }
}</span>

// CalculateEquipmentBonuses calculates the total stat bonuses from all equipped items.
// This examines item properties for stat modifiers and returns the cumulative effect.
//
// Returns:
//   - map[string]int: Map of stat names to their total bonus values
//
// Thread safety: This method is thread-safe using read mutex locking
func (c *Character) CalculateEquipmentBonuses() map[string]int <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        bonuses := make(map[string]int)

        for _, item := range c.Equipment </span><span class="cov8" title="1">{
                c.applyPropertyBonuses(item, bonuses)
                c.applyArmorClassBonus(item, bonuses)
        }</span>

        <span class="cov8" title="1">return bonuses</span>
}

// applyPropertyBonuses parses item properties for stat bonuses and updates the bonuses map.
func (c *Character) applyPropertyBonuses(item Item, bonuses map[string]int) <span class="cov8" title="1">{
        for _, property := range item.Properties </span><span class="cov8" title="1">{
                if len(property) &gt; 2 </span><span class="cov8" title="1">{
                        stat, value, ok := parseStatProperty(property)
                        if ok &amp;&amp; stat != "" </span><span class="cov8" title="1">{
                                bonuses[stat] += value
                        }</span>
                }
        }
}

// applyArmorClassBonus adds AC bonus from armor items to the bonuses map.
func (c *Character) applyArmorClassBonus(item Item, bonuses map[string]int) <span class="cov8" title="1">{
        if item.Type == "armor" &amp;&amp; item.AC &gt; 0 </span><span class="cov8" title="1">{
                bonuses["armor_class"] += item.AC - 10 // Base AC is 10
        }</span>
}

// parseStatProperty parses a property string like "strength+2" or "dexterity-10".
// Returns the stat name, the signed value, and true if parsing succeeded.
func parseStatProperty(property string) (string, int, bool) <span class="cov8" title="1">{
        signPos := -1
        for i := len(property) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if property[i] == '+' || property[i] == '-' </span><span class="cov8" title="1">{
                        signPos = i
                        break</span>
                }
        }
        <span class="cov8" title="1">if signPos &gt; 0 &amp;&amp; signPos &lt; len(property)-1 </span><span class="cov8" title="1">{
                stat := property[:signPos]
                sign := 1
                if property[signPos] == '-' </span><span class="cov8" title="1">{
                        sign = -1
                }</span>
                <span class="cov8" title="1">var modifier int
                _, err := fmt.Sscanf(property[signPos+1:], "%d", &amp;modifier)
                if err == nil </span><span class="cov8" title="1">{
                        return stat, sign * modifier, true
                }</span>
        }
        <span class="cov8" title="1">return "", 0, false</span>
}

// Inventory Management Methods

// AddItemToInventory adds an item to the character's inventory with weight and capacity checking.
//
// Parameters:
//   - item: The Item to add to the inventory
//
// Returns:
//   - error: Returns nil on success, or an error if the item cannot be added
//
// Errors:
//   - Returns error if adding the item would exceed carrying capacity
//   - Returns error if item is invalid
//
// Thread safety: This method is thread-safe using mutex locking
func (c *Character) AddItemToInventory(item Item) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Validate item
        if item.ID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot add item with empty ID")
        }</span>

        // Check carrying capacity (simplified - could be enhanced with strength-based limits)
        <span class="cov8" title="1">currentWeight := c.calculateTotalWeight()
        maxWeight := c.calculateMaxCarryingCapacity()

        if currentWeight+item.Weight &gt; maxWeight </span><span class="cov8" title="1">{
                return fmt.Errorf("adding item %s would exceed carrying capacity (%d/%d weight)",
                        item.Name, currentWeight+item.Weight, maxWeight)
        }</span>

        // Add item to inventory
        <span class="cov8" title="1">c.Inventory = append(c.Inventory, item)
        return nil</span>
}

// RemoveItemFromInventory removes an item from the character's inventory by ID.
//
// Parameters:
//   - itemID: The unique identifier of the item to remove
//
// Returns:
//   - *Item: Pointer to the removed item, or nil if not found
//   - error: Returns nil on success, or an error if the item cannot be removed
//
// Thread safety: This method is thread-safe using mutex locking
func (c *Character) RemoveItemFromInventory(itemID string) (*Item, error) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        for i, item := range c.Inventory </span><span class="cov8" title="1">{
                if item.ID == itemID </span><span class="cov8" title="1">{
                        // Remove item from inventory
                        removedItem := item
                        c.Inventory = append(c.Inventory[:i], c.Inventory[i+1:]...)
                        return &amp;removedItem, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("item not found in inventory: %s", itemID)</span>
}

// FindItemInInventory searches for an item in the character's inventory by ID.
//
// Parameters:
//   - itemID: The unique identifier of the item to find
//
// Returns:
//   - *Item: Pointer to the found item, or nil if not found
//   - int: Index of the item in the inventory, or -1 if not found
//
// Thread safety: This method is thread-safe using read mutex locking
func (c *Character) FindItemInInventory(itemID string) (*Item, int) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        for i, item := range c.Inventory </span><span class="cov0" title="0">{
                if item.ID == itemID </span><span class="cov0" title="0">{
                        return &amp;item, i
                }</span>
        }
        <span class="cov0" title="0">return nil, -1</span>
}

// GetInventory returns a copy of the character's inventory.
//
// Returns:
//   - []Item: A slice containing copies of all inventory items
//
// Thread safety: This method is thread-safe using read mutex locking
func (c *Character) GetInventory() []Item <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        inventory := make([]Item, len(c.Inventory))
        copy(inventory, c.Inventory)
        return inventory
}</span>

// GetInventoryWeight calculates the total weight of all items in the character's inventory.
//
// Returns:
//   - int: Total weight of all inventory items
//
// Thread safety: This method is thread-safe using read mutex locking
func (c *Character) GetInventoryWeight() int <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        return c.calculateTotalWeight()
}</span>

// calculateTotalWeight calculates total weight including inventory and equipped items (requires lock)
func (c *Character) calculateTotalWeight() int <span class="cov8" title="1">{
        totalWeight := 0

        // Add inventory weight
        for _, item := range c.Inventory </span><span class="cov8" title="1">{
                totalWeight += item.Weight
        }</span>

        // Add equipped items weight
        <span class="cov8" title="1">for _, item := range c.Equipment </span><span class="cov8" title="1">{
                totalWeight += item.Weight
        }</span>

        <span class="cov8" title="1">return totalWeight</span>
}

// calculateMaxCarryingCapacity determines maximum weight this character can carry
func (c *Character) calculateMaxCarryingCapacity() int <span class="cov8" title="1">{
        // Base carrying capacity + strength modifier
        baseCapacity := 50
        strengthBonus := (c.Strength - 10) / 2 * 10 // +10 per strength modifier point
        return baseCapacity + strengthBonus
}</span>

// HasItem checks if the character has a specific item in their inventory.
//
// Parameters:
//   - itemID: The unique identifier of the item to check for
//
// Returns:
//   - bool: true if the item is found in inventory, false otherwise
//
// Thread safety: This method is thread-safe using read mutex locking
func (c *Character) HasItem(itemID string) bool <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        for _, item := range c.Inventory </span><span class="cov8" title="1">{
                if item.ID == itemID </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// CountItems counts how many items of a specific type the character has in inventory.
//
// Parameters:
//   - itemType: The type of items to count (e.g. "weapon", "potion")
//
// Returns:
//   - int: Number of items of the specified type
//
// Thread safety: This method is thread-safe using read mutex locking
func (c *Character) CountItems(itemType string) int <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        count := 0
        for _, item := range c.Inventory </span><span class="cov8" title="1">{
                if item.Type == itemType </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

// TransferItemTo transfers an item from this character's inventory to another character's inventory.
//
// Parameters:
//   - itemID: The unique identifier of the item to transfer
//   - targetCharacter: The character to transfer the item to
//
// Returns:
//   - error: Returns nil on success, or an error if the transfer fails
//
// Thread safety: This method is thread-safe using mutex locking on both characters
func (c *Character) TransferItemTo(itemID string, targetCharacter *Character) error <span class="cov8" title="1">{
        // Lock both characters in consistent order to prevent deadlock
        if c.ID &lt; targetCharacter.ID </span><span class="cov8" title="1">{
                c.mu.Lock()
                defer c.mu.Unlock()
                targetCharacter.mu.Lock()
                defer targetCharacter.mu.Unlock()
        }</span> else<span class="cov0" title="0"> {
                targetCharacter.mu.Lock()
                defer targetCharacter.mu.Unlock()
                c.mu.Lock()
                defer c.mu.Unlock()
        }</span>

        // Find and remove item from source inventory
        <span class="cov8" title="1">var transferItem Item
        itemIndex := -1
        for i, item := range c.Inventory </span><span class="cov8" title="1">{
                if item.ID == itemID </span><span class="cov8" title="1">{
                        transferItem = item
                        itemIndex = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if itemIndex == -1 </span><span class="cov8" title="1">{
                return fmt.Errorf("item not found in source inventory: %s", itemID)
        }</span>

        // Check if target can carry the item
        <span class="cov8" title="1">targetCurrentWeight := targetCharacter.calculateTotalWeight()
        targetMaxWeight := targetCharacter.calculateMaxCarryingCapacity()

        if targetCurrentWeight+transferItem.Weight &gt; targetMaxWeight </span><span class="cov0" title="0">{
                return fmt.Errorf("target character cannot carry item %s - would exceed capacity", transferItem.Name)
        }</span>

        // Remove from source
        <span class="cov8" title="1">c.Inventory = append(c.Inventory[:itemIndex], c.Inventory[itemIndex+1:]...)

        // Add to target
        targetCharacter.Inventory = append(targetCharacter.Inventory, transferItem)

        return nil</span>
}

// determineArmorType determines the armor type (light, medium, heavy) based on item properties
func determineArmorType(item Item) string <span class="cov8" title="1">{
        // Check item properties for armor type indicators
        for _, property := range item.Properties </span><span class="cov8" title="1">{
                switch property </span>{
                case "light", "light_armor":<span class="cov8" title="1">
                        return "light"</span>
                case "medium", "medium_armor":<span class="cov0" title="0">
                        return "medium"</span>
                case "heavy", "heavy_armor":<span class="cov8" title="1">
                        return "heavy"</span>
                }
        }

        // Default classification based on item type and name
        <span class="cov8" title="1">itemName := strings.ToLower(item.Name)
        switch </span>{
        case strings.Contains(itemName, "leather") || strings.Contains(itemName, "cloth") || strings.Contains(itemName, "robe"):<span class="cov8" title="1">
                return "light"</span>
        case strings.Contains(itemName, "chain") || strings.Contains(itemName, "scale") || strings.Contains(itemName, "studded"):<span class="cov8" title="1">
                return "medium"</span>
        case strings.Contains(itemName, "plate") || strings.Contains(itemName, "full") || strings.Contains(itemName, "heavy"):<span class="cov8" title="1">
                return "heavy"</span>
        default:<span class="cov8" title="1">
                // Default to light for unspecified armor
                return "light"</span>
        }
}

// ensureEffectManager initializes the EffectManager if it's nil
// Note: Caller must hold the mutex lock
func (c *Character) ensureEffectManager() <span class="cov8" title="1">{
        if c.EffectManager == nil </span><span class="cov8" title="1">{
                baseStats := c.toStats()
                c.EffectManager = NewEffectManager(baseStats)
        }</span>
}

// toStats converts the Character's attributes to a Stats struct
func (c *Character) toStats() *Stats <span class="cov8" title="1">{
        return &amp;Stats{
                Health:       float64(c.HP),
                MaxHealth:    float64(c.MaxHP),
                Strength:     float64(c.Strength),
                Dexterity:    float64(c.Dexterity),
                Intelligence: float64(c.Intelligence),
                // Note: Character doesn't have Mana field, so default to 0
                Mana:    0,
                MaxMana: 0,
                Defense: float64(c.ArmorClass),
                Speed:   10, // Default speed value
        }
}</span>

// GetEffectManager returns the character's effect manager, initializing it if necessary
func (c *Character) GetEffectManager() *EffectManager <span class="cov0" title="0">{
        c.mu.RLock()
        if c.EffectManager != nil </span><span class="cov0" title="0">{
                defer c.mu.RUnlock()
                return c.EffectManager
        }</span>
        <span class="cov0" title="0">c.mu.RUnlock()

        c.mu.Lock()
        defer c.mu.Unlock()
        c.ensureEffectManager()
        return c.EffectManager</span>
}

// EffectHolder interface implementation - delegates to EffectManager

// AddEffect applies an effect to this character
func (c *Character) AddEffect(effect *Effect) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.ensureEffectManager()
        return c.EffectManager.AddEffect(effect)
}</span>

// RemoveEffect removes an effect from this character
func (c *Character) RemoveEffect(effectID string) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.ensureEffectManager()
        return c.EffectManager.RemoveEffect(effectID)
}</span>

// HasEffect checks if this character has an active effect of the specified type
func (c *Character) HasEffect(effectType EffectType) bool <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        if c.EffectManager == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return c.EffectManager.HasEffect(effectType)</span>
}

// GetEffects returns all active effects on this character
func (c *Character) GetEffects() []*Effect <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        if c.EffectManager == nil </span><span class="cov0" title="0">{
                return []*Effect{}
        }</span>
        <span class="cov0" title="0">return c.EffectManager.GetEffects()</span>
}

// GetStats returns the current stats (with effects applied)
func (c *Character) GetStats() *Stats <span class="cov0" title="0">{
        c.mu.RLock()
        if c.EffectManager != nil </span><span class="cov0" title="0">{
                defer c.mu.RUnlock()
                return c.EffectManager.GetStats()
        }</span>
        <span class="cov0" title="0">c.mu.RUnlock()

        c.mu.Lock()
        defer c.mu.Unlock()
        c.ensureEffectManager()
        return c.EffectManager.GetStats()</span>
}

// SetStats updates the current stats
func (c *Character) SetStats(stats *Stats) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.ensureEffectManager()
        c.EffectManager.SetStats(stats)
}</span>

// GetBaseStats returns the base stats (without effects)
func (c *Character) GetBaseStats() *Stats <span class="cov0" title="0">{
        c.mu.RLock()
        if c.EffectManager != nil </span><span class="cov0" title="0">{
                defer c.mu.RUnlock()
                return c.EffectManager.GetBaseStats()
        }</span>
        <span class="cov0" title="0">c.mu.RUnlock()

        c.mu.Lock()
        defer c.mu.Unlock()
        c.ensureEffectManager()
        return c.EffectManager.GetBaseStats()</span>
}

// Experience and Level Progression Methods

// GetLevel returns the character's current level.
//
// Returns:
//   - int: The current level of the character
//
// Thread safety: This method is thread-safe using read mutex locking
func (c *Character) GetLevel() int <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Level
}</span>

// GetExperience returns the character's current experience points.
//
// Returns:
//   - int64: The current experience points of the character
//
// Thread safety: This method is thread-safe using read mutex locking
func (c *Character) GetExperience() int64 <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Experience
}</span>

// AddExperience adds experience points to the character and handles level ups.
//
// Parameters:
//   - xp: The amount of experience points to add
//
// Returns:
//   - bool: true if the character leveled up, false otherwise
//   - error: Returns nil on success, or an error if the operation fails
//
// Thread safety: This method is thread-safe using mutex locking
func (c *Character) AddExperience(xp int64) (bool, error) <span class="cov8" title="1">{
        if xp &lt; 0 </span><span class="cov8" title="1">{
                return false, fmt.Errorf("experience points cannot be negative: %d", xp)
        }</span>

        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()

        oldLevel := c.Level
        c.Experience += xp

        // Check for level up
        newLevel := c.calculateLevelFromExperience()
        if newLevel &gt; oldLevel </span><span class="cov8" title="1">{
                c.Level = newLevel
                // Emit level up event using the existing event system
                if defaultEventSystem != nil </span><span class="cov8" title="1">{
                        emitLevelUpEvent(c.ID, oldLevel, newLevel)
                }</span>
                <span class="cov8" title="1">return true, nil</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}

// SetLevel directly sets the character's level (typically used during character creation).
//
// Parameters:
//   - level: The level to set
//
// Returns:
//   - error: Returns nil on success, or an error if the level is invalid
//
// Thread safety: This method is thread-safe using mutex locking
func (c *Character) SetLevel(level int) error <span class="cov8" title="1">{
        if level &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("level must be at least 1: %d", level)
        }</span>

        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()
        c.Level = level
        return nil</span>
}

// SetExperience directly sets the character's experience points.
//
// Parameters:
//   - xp: The experience points to set
//
// Returns:
//   - error: Returns nil on success, or an error if the experience is invalid
//
// Thread safety: This method is thread-safe using mutex locking
func (c *Character) SetExperience(xp int64) error <span class="cov8" title="1">{
        if xp &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("experience points cannot be negative: %d", xp)
        }</span>

        <span class="cov8" title="1">c.mu.Lock()
        defer c.mu.Unlock()
        c.Experience = xp
        return nil</span>
}

// GetExperienceToNextLevel returns the experience points needed to reach the next level.
//
// Returns:
//   - int64: Experience points needed for next level, or 0 if at max level
//
// Thread safety: This method is thread-safe using read mutex locking
func (c *Character) GetExperienceToNextLevel() int64 <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        nextLevelXP := c.getExperienceRequiredForLevel(c.Level + 1)
        if nextLevelXP == -1 </span><span class="cov0" title="0">{
                return 0 // Max level reached
        }</span>

        <span class="cov8" title="1">remaining := nextLevelXP - c.Experience
        if remaining &lt; 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return remaining</span>
}

// calculateLevelFromExperience determines the appropriate level for current experience
// Note: Caller must hold the mutex lock
func (c *Character) calculateLevelFromExperience() int <span class="cov8" title="1">{
        level := 1
        for </span><span class="cov8" title="1">{
                requiredXP := c.getExperienceRequiredForLevel(level + 1)
                if requiredXP == -1 || c.Experience &lt; requiredXP </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">level++</span>
        }
        <span class="cov8" title="1">return level</span>
}

// getExperienceRequiredForLevel returns the total experience needed for a given level
// Returns -1 if level is beyond maximum
func (c *Character) getExperienceRequiredForLevel(level int) int64 <span class="cov8" title="1">{
        if level &lt;= 1 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if level &gt; 20 </span><span class="cov8" title="1">{ // Max level cap
                return -1
        }</span>

        // Simple experience table - can be enhanced with class-specific tables
        // Uses a standard D&amp;D-style progression: 1000 XP for level 2, then roughly doubles
        <span class="cov8" title="1">switch level </span>{
        case 2:<span class="cov8" title="1">
                return 1000</span>
        case 3:<span class="cov8" title="1">
                return 2000</span>
        case 4:<span class="cov8" title="1">
                return 4000</span>
        case 5:<span class="cov8" title="1">
                return 8000</span>
        case 6:<span class="cov8" title="1">
                return 16000</span>
        case 7:<span class="cov0" title="0">
                return 32000</span>
        case 8:<span class="cov0" title="0">
                return 64000</span>
        case 9:<span class="cov0" title="0">
                return 120000</span>
        case 10:<span class="cov8" title="1">
                return 200000</span>
        default:<span class="cov0" title="0">
                // For levels 11-20, use geometric progression
                baseXP := int64(200000)
                for i := 10; i &lt; level; i++ </span><span class="cov0" title="0">{
                        baseXP = int64(float64(baseXP) * 1.5)
                }</span>
                <span class="cov0" title="0">return baseXP</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package game

import (
        "fmt"
        "math/rand"
        "time"
)

// CharacterCreationConfig defines the parameters for creating a new character.
// It contains all the necessary information to generate a valid character
// including class selection, attribute generation method, and starting equipment.
//
// Fields:
//   - Name: The desired name for the character (must be unique and non-empty)
//   - Class: The character class selection from available CharacterClass enum
//   - AttributeMethod: Method for generating attributes ("roll", "pointbuy", "standard")
//   - CustomAttributes: Optional custom attribute values (used with "custom" method)
//   - StartingEquipment: Whether to equip character with class-appropriate gear
//   - StartingGold: Amount of starting gold (0 = use class default)
//
// Related types:
//   - CharacterClass: Enum defining available character classes
//   - Character: The resulting character struct
//   - ClassConfig: Configuration for character classes
type CharacterCreationConfig struct {
        Name              string                 `yaml:"creation_name"`               // Character name
        Class             CharacterClass         `yaml:"creation_class"`              // Character class
        AttributeMethod   string                 `yaml:"creation_attr_method"`        // Attribute generation method
        CustomAttributes  map[string]int         `yaml:"creation_custom_attrs"`       // Custom attribute values
        StartingEquipment bool                   `yaml:"creation_starting_equipment"` // Include starting equipment
        StartingGold      int                    `yaml:"creation_starting_gold"`      // Starting gold amount
        AdditionalData    map[string]interface{} `yaml:"creation_additional_data"`    // Additional character data
}

// CharacterCreationResult represents the outcome of character creation process.
// It contains the created character and any relevant metadata about the creation.
//
// Fields:
//   - Character: Pointer to the newly created Character instance
//   - Success: Boolean indicating if creation was successful
//   - Errors: Slice of error messages encountered during creation
//   - Warnings: Slice of warning messages (non-fatal issues)
//   - CreationTime: Timestamp when the character was created
//   - GeneratedStats: Map of the final generated attribute values
//
// Related types:
//   - Character: The created character instance
//   - CharacterCreationConfig: Input configuration used for creation
type CharacterCreationResult struct {
        Character      *Character     `yaml:"result_character"`       // Created character
        Success        bool           `yaml:"result_success"`         // Creation success status
        Errors         []string       `yaml:"result_errors"`          // Error messages
        Warnings       []string       `yaml:"result_warnings"`        // Warning messages
        CreationTime   time.Time      `yaml:"result_creation_time"`   // When created
        GeneratedStats map[string]int `yaml:"result_generated_stats"` // Final attribute values
        StartingItems  []Item         `yaml:"result_starting_items"`  // Starting equipment
        PlayerData     *Player        `yaml:"result_player_data"`     // Player-specific data if applicable
}

// CharacterCreator handles the creation of new characters with validation and configuration.
// It provides methods for generating characters using different attribute methods
// and ensures all created characters are valid and properly configured.
//
// Fields:
//   - classConfigs: Map of class configurations for validation and equipment
//   - itemDatabase: Map of available items for starting equipment
//   - rng: Random number generator for attribute rolling
//
// Related types:
//   - ClassConfig: Configuration data for character classes
//   - Item: Game items for starting equipment
type CharacterCreator struct {
        classConfigs map[CharacterClass]ClassConfig `yaml:"creator_class_configs"` // Class configuration data
        itemDatabase map[string]Item                `yaml:"creator_item_database"` // Available items
        rng          *rand.Rand                     `yaml:"-"`                     // Random number generator
}

// NewCharacterCreator initializes a new CharacterCreator with default configurations.
// It sets up class configurations, loads item database, and initializes the random number generator.
//
// Returns:
//   - *CharacterCreator: A fully configured character creator instance
//
// The creator is initialized with:
//   - Default class configurations for all 6 classes
//   - Basic starting equipment items
//   - Seeded random number generator
func NewCharacterCreator() *CharacterCreator <span class="cov8" title="1">{
        creator := &amp;CharacterCreator{
                classConfigs: make(map[CharacterClass]ClassConfig),
                itemDatabase: make(map[string]Item),
                rng:          rand.New(rand.NewSource(time.Now().UnixNano())),
        }

        // Initialize default class configurations
        creator.initializeDefaultClassConfigs()

        // Initialize basic item database
        creator.initializeItemDatabase()

        return creator
}</span>

// CreateCharacter generates a new character based on the provided configuration.
// It validates the configuration, generates attributes, assigns starting equipment,
// and returns a complete character creation result.
//
// Parameters:
//   - config: CharacterCreationConfig containing creation parameters
//
// Returns:
//   - CharacterCreationResult: Complete result with character and metadata
//
// The creation process delegates to specialized methods for each creation step.
func (cc *CharacterCreator) CreateCharacter(config CharacterCreationConfig) CharacterCreationResult <span class="cov8" title="1">{
        result := cc.initializeCreationResult()

        if err := cc.validateCreationInput(config, &amp;result); err != nil </span><span class="cov8" title="1">{
                return result
        }</span>

        <span class="cov8" title="1">attributes, err := cc.processAttributeGeneration(config, &amp;result)
        if err != nil </span><span class="cov8" title="1">{
                return result
        }</span>

        <span class="cov8" title="1">character := cc.buildBaseCharacter(config, attributes)
        cc.calculateDerivedStats(character, config.Class)

        cc.applyStartingEquipment(config, character, &amp;result)
        player := cc.createPlayerData(character)

        cc.finalizeCreationResult(character, player, attributes, &amp;result)
        return result</span>
}

// initializeCreationResult creates and returns a new character creation result with default values.
func (cc *CharacterCreator) initializeCreationResult() CharacterCreationResult <span class="cov8" title="1">{
        return CharacterCreationResult{
                Success:        false,
                Errors:         []string{},
                Warnings:       []string{},
                CreationTime:   time.Now(),
                GeneratedStats: make(map[string]int),
                StartingItems:  []Item{},
        }
}</span>

// validateCreationInput validates the configuration and checks class requirements.
func (cc *CharacterCreator) validateCreationInput(config CharacterCreationConfig, result *CharacterCreationResult) error <span class="cov8" title="1">{
        if err := cc.validateConfig(config); err != nil </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, err.Error())
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// processAttributeGeneration generates and validates character attributes.
func (cc *CharacterCreator) processAttributeGeneration(config CharacterCreationConfig, result *CharacterCreationResult) (map[string]int, error) <span class="cov8" title="1">{
        attributes, err := cc.generateAttributes(config)
        if err != nil </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, fmt.Sprintf("attribute generation failed: %v", err))
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := cc.validateClassRequirements(config.Class, attributes); err != nil </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, fmt.Sprintf("class requirements not met: %v", err))
                return nil, err
        }</span>

        <span class="cov8" title="1">return attributes, nil</span>
}

// buildBaseCharacter creates a new Character instance with the specified configuration and attributes.
func (cc *CharacterCreator) buildBaseCharacter(config CharacterCreationConfig, attributes map[string]int) *Character <span class="cov8" title="1">{
        return &amp;Character{
                ID:           NewUID(),
                Name:         config.Name,
                Description:  fmt.Sprintf("A %s %s", config.Class.String(), "adventurer"),
                Position:     Position{X: 0, Y: 0, Level: 0, Facing: DirectionNorth},
                Class:        config.Class,
                Level:        1, // New characters start at level 1
                Strength:     attributes["strength"],
                Dexterity:    attributes["dexterity"],
                Constitution: attributes["constitution"],
                Intelligence: attributes["intelligence"],
                Wisdom:       attributes["wisdom"],
                Charisma:     attributes["charisma"],
                Equipment:    make(map[EquipmentSlot]Item),
                Inventory:    []Item{},
                Gold:         config.StartingGold,
                active:       true,
                tags:         []string{"player_character"},
        }
}</span>

// applyStartingEquipment assigns starting equipment to the character if requested.
func (cc *CharacterCreator) applyStartingEquipment(config CharacterCreationConfig, character *Character, result *CharacterCreationResult) <span class="cov8" title="1">{
        if config.StartingEquipment </span><span class="cov8" title="1">{
                startingItems := cc.getStartingEquipment(config.Class)
                result.StartingItems = startingItems
                character.Inventory = append(character.Inventory, startingItems...)
        }</span>
}

// createPlayerData creates player-specific data associated with the character.
func (cc *CharacterCreator) createPlayerData(character *Character) *Player <span class="cov8" title="1">{
        return &amp;Player{
                Character:   *character.Clone(),
                Level:       1,
                Experience:  0,
                QuestLog:    []Quest{},
                KnownSpells: []Spell{},
        }
}</span>

// finalizeCreationResult populates the final result with successful creation data.
func (cc *CharacterCreator) finalizeCreationResult(character *Character, player *Player, attributes map[string]int, result *CharacterCreationResult) <span class="cov8" title="1">{
        result.Character = character
        result.PlayerData = player
        result.Success = true
        result.GeneratedStats = attributes
}</span>

// generateAttributes creates character attributes based on the specified method.
// Supports multiple generation methods for different gameplay styles.
//
// Parameters:
//   - config: Character creation configuration
//
// Returns:
//   - map[string]int: Generated attribute values
//   - error: Error if generation fails
//
// Supported methods:
//   - "roll": 4d6 drop lowest for each attribute
//   - "pointbuy": Point-buy system with 27 points
//   - "standard": Standard array (15,14,13,12,10,8)
//   - "custom": Use provided custom values
func (cc *CharacterCreator) generateAttributes(config CharacterCreationConfig) (map[string]int, error) <span class="cov8" title="1">{
        attributes := make(map[string]int)

        switch config.AttributeMethod </span>{
        case "roll":<span class="cov8" title="1">
                attributes["strength"] = cc.rollAttribute()
                attributes["dexterity"] = cc.rollAttribute()
                attributes["constitution"] = cc.rollAttribute()
                attributes["intelligence"] = cc.rollAttribute()
                attributes["wisdom"] = cc.rollAttribute()
                attributes["charisma"] = cc.rollAttribute()</span>

        case "pointbuy":<span class="cov8" title="1">
                return cc.generatePointBuyAttributes()</span>

        case "standard":<span class="cov8" title="1">
                standardArray := []int{15, 14, 13, 12, 10, 8}
                attributeNames := []string{"strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"}
                for i, name := range attributeNames </span><span class="cov8" title="1">{
                        attributes[name] = standardArray[i]
                }</span>

        case "custom":<span class="cov8" title="1">
                if config.CustomAttributes == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("custom attributes not provided")
                }</span>
                <span class="cov8" title="1">for key, value := range config.CustomAttributes </span><span class="cov8" title="1">{
                        if value &lt; 3 || value &gt; 18 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("attribute %s value %d out of range (3-18)", key, value)
                        }</span>
                        <span class="cov8" title="1">attributes[key] = value</span>
                }

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown attribute method: %s", config.AttributeMethod)</span>
        }

        <span class="cov8" title="1">return attributes, nil</span>
}

// rollAttribute generates a single attribute using 4d6 drop lowest method.
// This is the classic D&amp;D attribute generation method.
//
// Returns:
//   - int: Generated attribute value (3-18)
func (cc *CharacterCreator) rollAttribute() int <span class="cov8" title="1">{
        rolls := make([]int, 4)
        for i := 0; i &lt; 4; i++ </span><span class="cov8" title="1">{
                rolls[i] = cc.rng.Intn(6) + 1
        }</span>

        // Find minimum and remove it
        <span class="cov8" title="1">minValue := rolls[0]
        minIndex := 0
        for i := 1; i &lt; 4; i++ </span><span class="cov8" title="1">{
                if rolls[i] &lt; minValue </span><span class="cov8" title="1">{
                        minValue = rolls[i]
                        minIndex = i
                }</span>
        }

        <span class="cov8" title="1">total := 0
        for i := 0; i &lt; 4; i++ </span><span class="cov8" title="1">{
                if i != minIndex </span><span class="cov8" title="1">{
                        total += rolls[i]
                }</span>
        }

        <span class="cov8" title="1">return total</span>
}

// generatePointBuyAttributes creates attributes using a point-buy system.
// Starts with base scores of 8 and distributes 27 points.
//
// Returns:
//   - map[string]int: Generated attributes
//   - error: Error if point allocation fails
func (cc *CharacterCreator) generatePointBuyAttributes() (map[string]int, error) <span class="cov8" title="1">{
        attributes := map[string]int{
                "strength":     8,
                "dexterity":    8,
                "constitution": 8,
                "intelligence": 8,
                "wisdom":       8,
                "charisma":     8,
        }

        // Simple random distribution for demo
        remainingPoints := 27
        attributeNames := []string{"strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"}

        for remainingPoints &gt; 0 &amp;&amp; len(attributeNames) &gt; 0 </span><span class="cov8" title="1">{
                attrIndex := cc.rng.Intn(len(attributeNames))
                attrName := attributeNames[attrIndex]

                if attributes[attrName] &lt; 15 </span><span class="cov8" title="1">{
                        pointCost := 1
                        if attributes[attrName] &gt;= 13 </span><span class="cov8" title="1">{
                                pointCost = 2
                        }</span>

                        <span class="cov8" title="1">if remainingPoints &gt;= pointCost </span><span class="cov8" title="1">{
                                attributes[attrName]++
                                remainingPoints -= pointCost
                        }</span> else<span class="cov0" title="0"> {
                                // Remove this attribute from consideration
                                attributeNames = append(attributeNames[:attrIndex], attributeNames[attrIndex+1:]...)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Remove maxed attribute from consideration
                        attributeNames = append(attributeNames[:attrIndex], attributeNames[attrIndex+1:]...)
                }</span>
        }

        <span class="cov8" title="1">return attributes, nil</span>
}

// validateConfig checks if the character creation configuration is valid.
//
// Parameters:
//   - config: Configuration to validate
//
// Returns:
//   - error: Validation error if configuration is invalid
func (cc *CharacterCreator) validateConfig(config CharacterCreationConfig) error <span class="cov8" title="1">{
        if config.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("character name cannot be empty")
        }</span>

        <span class="cov8" title="1">if len(config.Name) &gt; 50 </span><span class="cov8" title="1">{
                return fmt.Errorf("character name too long (max 50 characters)")
        }</span>

        <span class="cov8" title="1">validMethods := map[string]bool{
                "roll":     true,
                "pointbuy": true,
                "standard": true,
                "custom":   true,
        }

        if !validMethods[config.AttributeMethod] </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid attribute method: %s", config.AttributeMethod)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateClassRequirements checks if generated attributes meet class requirements.
//
// Parameters:
//   - class: Character class to validate against
//   - attributes: Generated attribute map
//
// Returns:
//   - error: Error if requirements not met
func (cc *CharacterCreator) validateClassRequirements(class CharacterClass, attributes map[string]int) error <span class="cov8" title="1">{
        classConfig, exists := cc.classConfigs[class]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("unknown character class: %v", class)
        }</span>

        <span class="cov8" title="1">if attributes["strength"] &lt; classConfig.Requirements.MinStr </span><span class="cov8" title="1">{
                return fmt.Errorf("insufficient strength for %s (need %d, have %d)",
                        class.String(), classConfig.Requirements.MinStr, attributes["strength"])
        }</span>

        <span class="cov8" title="1">if attributes["dexterity"] &lt; classConfig.Requirements.MinDex </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient dexterity for %s (need %d, have %d)",
                        class.String(), classConfig.Requirements.MinDex, attributes["dexterity"])
        }</span>

        <span class="cov8" title="1">if attributes["constitution"] &lt; classConfig.Requirements.MinCon </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient constitution for %s (need %d, have %d)",
                        class.String(), classConfig.Requirements.MinCon, attributes["constitution"])
        }</span>

        <span class="cov8" title="1">if attributes["intelligence"] &lt; classConfig.Requirements.MinInt </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient intelligence for %s (need %d, have %d)",
                        class.String(), classConfig.Requirements.MinInt, attributes["intelligence"])
        }</span>

        <span class="cov8" title="1">if attributes["wisdom"] &lt; classConfig.Requirements.MinWis </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient wisdom for %s (need %d, have %d)",
                        class.String(), classConfig.Requirements.MinWis, attributes["wisdom"])
        }</span>

        <span class="cov8" title="1">if attributes["charisma"] &lt; classConfig.Requirements.MinCha </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient charisma for %s (need %d, have %d)",
                        class.String(), classConfig.Requirements.MinCha, attributes["charisma"])
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// calculateDerivedStats computes secondary stats like HP and AC based on class and attributes.
//
// Parameters:
//   - character: Character to calculate stats for
//   - class: Character's class
func (cc *CharacterCreator) calculateDerivedStats(character *Character, class CharacterClass) <span class="cov8" title="1">{
        // Calculate hit points based on class and constitution
        baseHP := map[CharacterClass]int{
                ClassFighter: 10,
                ClassMage:    4,
                ClassCleric:  8,
                ClassThief:   6,
                ClassRanger:  8,
                ClassPaladin: 10,
        }

        conBonus := (character.Constitution - 10) / 2
        character.MaxHP = baseHP[class] + conBonus
        character.HP = character.MaxHP

        // Calculate armor class (base 10 + dex modifier)
        dexBonus := (character.Dexterity - 10) / 2
        character.ArmorClass = 10 + dexBonus

        // Calculate THAC0 (simplified)
        character.THAC0 = 20 // Base for level 1 character

        // Initialize action points based on level and dexterity (level 1 for new characters)
        character.MaxActionPoints = calculateMaxActionPoints(character.Level, character.Dexterity)
        character.ActionPoints = character.MaxActionPoints // Start with full action points
}</span>

// getStartingEquipment returns appropriate starting items for a character class.
//
// Parameters:
//   - class: Character class
//
// Returns:
//   - []Item: List of starting equipment items
func (cc *CharacterCreator) getStartingEquipment(class CharacterClass) []Item <span class="cov8" title="1">{
        equipment := []Item{}

        switch class </span>{
        case ClassFighter:<span class="cov8" title="1">
                equipment = append(equipment, cc.itemDatabase["weapon_shortsword"])
                equipment = append(equipment, cc.itemDatabase["armor_leather"])</span>
        case ClassMage:<span class="cov8" title="1">
                // Mages get minimal equipment
                break</span>
        case ClassCleric:<span class="cov0" title="0">
                equipment = append(equipment, cc.itemDatabase["armor_leather"])</span>
        case ClassThief:<span class="cov8" title="1">
                equipment = append(equipment, cc.itemDatabase["weapon_shortsword"])</span>
        case ClassRanger:<span class="cov0" title="0">
                equipment = append(equipment, cc.itemDatabase["weapon_shortsword"])
                equipment = append(equipment, cc.itemDatabase["armor_leather"])</span>
        case ClassPaladin:<span class="cov0" title="0">
                equipment = append(equipment, cc.itemDatabase["weapon_shortsword"])
                equipment = append(equipment, cc.itemDatabase["armor_leather"])</span>
        }

        <span class="cov8" title="1">return equipment</span>
}

// initializeDefaultClassConfigs sets up default configurations for all character classes.
func (cc *CharacterCreator) initializeDefaultClassConfigs() <span class="cov8" title="1">{
        classDefinitions := cc.createClassDefinitionMap()
        cc.populateClassConfigs(classDefinitions)
}</span>

// createClassDefinitionMap returns a complete map of all character class definitions.
func (cc *CharacterCreator) createClassDefinitionMap() map[CharacterClass]classDefinition <span class="cov8" title="1">{
        return map[CharacterClass]classDefinition{
                ClassFighter: cc.createFighterDefinition(),
                ClassMage:    cc.createMageDefinition(),
                ClassCleric:  cc.createClericDefinition(),
                ClassThief:   cc.createThiefDefinition(),
                ClassRanger:  cc.createRangerDefinition(),
                ClassPaladin: cc.createPaladinDefinition(),
        }
}</span>

// populateClassConfigs converts class definitions to class configs and stores them.
func (cc *CharacterCreator) populateClassConfigs(definitions map[CharacterClass]classDefinition) <span class="cov8" title="1">{
        for classType, definition := range definitions </span><span class="cov8" title="1">{
                cc.classConfigs[classType] = cc.buildClassConfig(classType, definition)
        }</span>
}

// createFighterDefinition builds the Fighter class definition.
func (cc *CharacterCreator) createFighterDefinition() classDefinition <span class="cov8" title="1">{
        return classDefinition{
                name:         "Fighter",
                description:  "A warrior skilled in combat and tactics",
                hitDice:      "1d10",
                baseSkills:   []string{"Weapon Mastery", "Combat Tactics"},
                abilities:    []string{"Second Wind", "Action Surge"},
                requirements: classRequirements{str: 13},
        }
}</span>

// createMageDefinition builds the Mage class definition.
func (cc *CharacterCreator) createMageDefinition() classDefinition <span class="cov8" title="1">{
        return classDefinition{
                name:         "Mage",
                description:  "A spellcaster who manipulates arcane forces",
                hitDice:      "1d4",
                baseSkills:   []string{"Spellcraft", "Arcane Knowledge"},
                abilities:    []string{"Cantrips", "Spell Casting"},
                requirements: classRequirements{int: 13},
        }
}</span>

// createClericDefinition builds the Cleric class definition.
func (cc *CharacterCreator) createClericDefinition() classDefinition <span class="cov8" title="1">{
        return classDefinition{
                name:         "Cleric",
                description:  "A divine spellcaster and healer",
                hitDice:      "1d8",
                baseSkills:   []string{"Divine Magic", "Healing"},
                abilities:    []string{"Turn Undead", "Divine Casting"},
                requirements: classRequirements{wis: 13},
        }
}</span>

// createThiefDefinition builds the Thief class definition.
func (cc *CharacterCreator) createThiefDefinition() classDefinition <span class="cov8" title="1">{
        return classDefinition{
                name:         "Thief",
                description:  "A stealthy character skilled in subterfuge",
                hitDice:      "1d6",
                baseSkills:   []string{"Stealth", "Lockpicking", "Trap Detection"},
                abilities:    []string{"Sneak Attack", "Thieves Tools"},
                requirements: classRequirements{dex: 13},
        }
}</span>

// createRangerDefinition builds the Ranger class definition.
func (cc *CharacterCreator) createRangerDefinition() classDefinition <span class="cov8" title="1">{
        return classDefinition{
                name:         "Ranger",
                description:  "A wilderness warrior and tracker",
                hitDice:      "1d8",
                baseSkills:   []string{"Tracking", "Survival", "Archery"},
                abilities:    []string{"Favored Enemy", "Natural Magic"},
                requirements: classRequirements{dex: 13, wis: 13},
        }
}</span>

// createPaladinDefinition builds the Paladin class definition.
func (cc *CharacterCreator) createPaladinDefinition() classDefinition <span class="cov8" title="1">{
        return classDefinition{
                name:         "Paladin",
                description:  "A holy warrior dedicated to justice",
                hitDice:      "1d10",
                baseSkills:   []string{"Divine Magic", "Combat", "Leadership"},
                abilities:    []string{"Lay on Hands", "Divine Smite"},
                requirements: classRequirements{str: 13, cha: 13},
        }
}</span>

// buildClassConfig constructs a ClassConfig from a class type and definition.
func (cc *CharacterCreator) buildClassConfig(classType CharacterClass, definition classDefinition) ClassConfig <span class="cov8" title="1">{
        return ClassConfig{
                Type:         classType,
                Name:         definition.name,
                Description:  definition.description,
                HitDice:      definition.hitDice,
                BaseSkills:   definition.baseSkills,
                Abilities:    definition.abilities,
                Requirements: cc.buildClassRequirements(definition.requirements),
        }
}</span>

// buildClassRequirements converts simple requirements to the full requirements struct.
func (cc *CharacterCreator) buildClassRequirements(reqs classRequirements) struct {
        MinStr int `yaml:"min_strength"`
        MinDex int `yaml:"min_dexterity"`
        MinCon int `yaml:"min_constitution"`
        MinInt int `yaml:"min_intelligence"`
        MinWis int `yaml:"min_wisdom"`
        MinCha int `yaml:"min_charisma"`
} <span class="cov8" title="1">{
        return struct {
                MinStr int `yaml:"min_strength"`
                MinDex int `yaml:"min_dexterity"`
                MinCon int `yaml:"min_constitution"`
                MinInt int `yaml:"min_intelligence"`
                MinWis int `yaml:"min_wisdom"`
                MinCha int `yaml:"min_charisma"`
        }{
                MinStr: reqs.str,
                MinDex: reqs.dex,
                MinCon: reqs.con,
                MinInt: reqs.int,
                MinWis: reqs.wis,
                MinCha: reqs.cha,
        }
}</span>

// classDefinition holds the configuration data for a character class.
type classDefinition struct {
        name         string
        description  string
        hitDice      string
        baseSkills   []string
        abilities    []string
        requirements classRequirements
}

// classRequirements holds the attribute requirements for a character class.
type classRequirements struct {
        str int // Strength requirement
        dex int // Dexterity requirement
        con int // Constitution requirement
        int int // Intelligence requirement
        wis int // Wisdom requirement
        cha int // Charisma requirement
}

// initializeItemDatabase sets up the basic item database for starting equipment.
func (cc *CharacterCreator) initializeItemDatabase() <span class="cov8" title="1">{
        cc.itemDatabase["weapon_shortsword"] = Item{
                ID:         "weapon_shortsword",
                Name:       "Short Sword",
                Type:       "weapon",
                Damage:     "1d6",
                Weight:     2,
                Value:      10,
                Properties: []string{"finesse", "light"},
        }

        cc.itemDatabase["armor_leather"] = Item{
                ID:     "armor_leather",
                Name:   "Leather Armor",
                Type:   "armor",
                AC:     11,
                Weight: 10,
                Value:  10,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package game

// CharacterClass represents available character classes
// CharacterClass represents the character's role or profession in the game.
// It is implemented as an enumerated type using integers for efficient storage
// and comparison operations.
//
// The specific class values and their gameplay implications should be defined
// as constants using this type. Each class may have different abilities,
// starting stats, and progression paths.
//
// Related types:
// - Character struct (which likely contains this as a field)
// - Any class-specific ability or skill types
type CharacterClass int

// CharacterClass constants are defined in constants.go

// String returns the string representation of a CharacterClass.
// It converts the CharacterClass enum value to its corresponding human-readable name.
//
// Returns:
//
//        string: The name of the character class as a string ("Fighter", "Mage", etc.)
//
// Notable Cases:
//   - Assumes valid enum values within array bounds
//   - Will panic if given an invalid CharacterClass value
//
// Related Types:
//   - CharacterClass type (enum)
func (cc CharacterClass) String() string <span class="cov8" title="1">{
        return [...]string{
                "Fighter",
                "Mage",
                "Cleric",
                "Thief",
                "Ranger",
                "Paladin",
        }[cc]
}</span>

// ClassConfig represents the configuration for a character class in the game.
// It defines all the attributes, requirements and abilities that make up a class.
//
// Fields:
//   - Type: The enumerated class type identifier (CharacterClass)
//   - Name: Human-readable display name of the class
//   - Description: Full text description and background lore of the class
//   - HitDice: Dice expression for calculating hit points per level (e.g. "1d10")
//   - BaseSkills: List of default skills granted by the class
//   - Abilities: List of special abilities granted by the class
//   - Requirements: Struct containing minimum ability score requirements:
//   - MinStr: Minimum Strength score needed
//   - MinDex: Minimum Dexterity score needed
//   - MinCon: Minimum Constitution score needed
//   - MinInt: Minimum Intelligence score needed
//   - MinWis: Minimum Wisdom score needed
//   - MinCha: Minimum Charisma score needed
//
// This struct is typically populated from YAML configuration files.
// The Requirements struct ensures characters meet minimum ability scores
// before being allowed to take levels in this class.
//
// Related types:
//   - CharacterClass enum type (defines valid class types)
//   - Character struct (uses ClassConfig for character creation)
type ClassConfig struct {
        Type         CharacterClass `yaml:"class_type"`        // The class enumeration value
        Name         string         `yaml:"class_name"`        // Display name of the class
        Description  string         `yaml:"class_description"` // Class description and background
        HitDice      string         `yaml:"class_hit_dice"`    // Hit points per level (e.g., "1d10")
        BaseSkills   []string       `yaml:"class_base_skills"` // Default skills for the class
        Abilities    []string       `yaml:"class_abilities"`   // Special class abilities
        Requirements struct {
                MinStr int `yaml:"min_strength"`     // Minimum strength requirement
                MinDex int `yaml:"min_dexterity"`    // Minimum dexterity requirement
                MinCon int `yaml:"min_constitution"` // Minimum constitution requirement
                MinInt int `yaml:"min_intelligence"` // Minimum intelligence requirement
                MinWis int `yaml:"min_wisdom"`       // Minimum wisdom requirement
                MinCha int `yaml:"min_charisma"`     // Minimum charisma requirement
        } `yaml:"class_requirements"` // Minimum stat requirements
}

// ClassProficiencies represents weapon and armor proficiencies for a class
// ClassProficiencies defines what equipment and items a character class can use.
// It specifies allowed weapons, armor types and any special restrictions.
//
// Fields:
//   - Class: The character class these proficiencies apply to
//   - WeaponTypes: List of weapon categories this class can use (e.g. "sword", "bow")
//   - ArmorTypes: List of armor categories this class can wear (e.g. "light", "heavy")
//   - ShieldProficient: Whether the class is trained in shield usage
//   - Restrictions: Any special limitations on equipment usage
//
// Related types:
//   - CharacterClass: The class enum these proficiencies are linked to
//
// Example:
//
//        Fighter proficiencies would allow all weapons and armor types with shield use
//        Mage proficiencies would be limited to staves/wands and light armor with no shields
type ClassProficiencies struct {
        Class            CharacterClass `yaml:"class_type"`             // Associated character class
        WeaponTypes      []string       `yaml:"allowed_weapons"`        // Allowed weapon types
        ArmorTypes       []string       `yaml:"allowed_armor"`          // Allowed armor types
        ShieldProficient bool           `yaml:"can_use_shields"`        // Whether class can use shields
        Restrictions     []string       `yaml:"equipment_restrictions"` // Special equipment restrictions
}

// GetClassProficiencies returns the default proficiencies for a character class
// This defines what equipment types each class can use
func GetClassProficiencies(class CharacterClass) ClassProficiencies <span class="cov8" title="1">{
        classProficiencies := map[CharacterClass]ClassProficiencies{
                ClassFighter: {
                        Class:            ClassFighter,
                        WeaponTypes:      []string{"sword", "axe", "mace", "bow", "dagger", "spear", "hammer"},
                        ArmorTypes:       []string{"light", "medium", "heavy"},
                        ShieldProficient: true,
                        Restrictions:     []string{},
                },
                ClassMage: {
                        Class:            ClassMage,
                        WeaponTypes:      []string{"staff", "dagger", "wand"},
                        ArmorTypes:       []string{}, // Mages cannot wear armor
                        ShieldProficient: false,
                        Restrictions:     []string{"no armor", "no shields"},
                },
                ClassCleric: {
                        Class:            ClassCleric,
                        WeaponTypes:      []string{"mace", "staff", "dagger"},
                        ArmorTypes:       []string{"light", "medium", "heavy"},
                        ShieldProficient: true,
                        Restrictions:     []string{"no edged weapons"},
                },
                ClassThief: {
                        Class:            ClassThief,
                        WeaponTypes:      []string{"dagger", "sword", "bow"},
                        ArmorTypes:       []string{"light"},
                        ShieldProficient: false,
                        Restrictions:     []string{"no heavy weapons", "no heavy armor"},
                },
                ClassRanger: {
                        Class:            ClassRanger,
                        WeaponTypes:      []string{"bow", "sword", "dagger", "spear"},
                        ArmorTypes:       []string{"light", "medium"},
                        ShieldProficient: true,
                        Restrictions:     []string{},
                },
                ClassPaladin: {
                        Class:            ClassPaladin,
                        WeaponTypes:      []string{"sword", "mace", "spear", "bow", "dagger"},
                        ArmorTypes:       []string{"light", "medium", "heavy"},
                        ShieldProficient: true,
                        Restrictions:     []string{},
                },
        }

        proficiencies, exists := classProficiencies[class]
        if !exists </span><span class="cov0" title="0">{
                // Return empty proficiencies for unknown classes
                return ClassProficiencies{Class: class}
        }</span>

        <span class="cov8" title="1">return proficiencies</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// pkg/game/default_world.go

package game

// DefaultWorld constants are defined in constants.go

// CreateDefaultWorld initializes a new world with a basic test level
func CreateDefaultWorld() *World <span class="cov8" title="1">{
        world := NewWorld()

        // Create default level
        level := &amp;Level{
                ID:         "default_level",
                Name:       "Test Chamber",
                Width:      DefaultWorldWidth,
                Height:     DefaultWorldHeight,
                Tiles:      make([][]Tile, DefaultWorldHeight),
                Properties: make(map[string]interface{}),
        }

        // Initialize tiles
        for y := 0; y &lt; level.Height; y++ </span><span class="cov8" title="1">{
                level.Tiles[y] = make([]Tile, level.Width)
                for x := 0; x &lt; level.Width; x++ </span><span class="cov8" title="1">{
                        // Create walls around the edges
                        if x == 0 || x == level.Width-1 || y == 0 || y == level.Height-1 </span><span class="cov8" title="1">{
                                level.Tiles[y][x] = Tile{
                                        Type:        TileWall,
                                        Walkable:    false,
                                        Transparent: false,
                                        Properties:  make(map[string]interface{}),
                                        Sprite:      "wall",
                                        Color:       RGB{128, 128, 128}, // Gray walls
                                        BlocksSight: true,
                                }
                        }</span> else<span class="cov8" title="1"> {
                                // Create floor tiles in the middle
                                level.Tiles[y][x] = Tile{
                                        Type:        TileFloor,
                                        Walkable:    true,
                                        Transparent: true,
                                        Properties:  make(map[string]interface{}),
                                        Sprite:      "floor",
                                        Color:       RGB{200, 200, 200}, // Light gray floor
                                        BlocksSight: false,
                                }
                        }</span>
                }
        }

        // Add the level to the world
        <span class="cov8" title="1">world.Levels = []Level{*level}

        // Add some test objects
        // world.AddObject(testObj)

        return world</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package game

import (
        "fmt"
        "math/rand"
        "regexp"
        "strconv"
        "strings"
        "time"
)

// DiceRoll represents the result of rolling dice
type DiceRoll struct {
        Rolls    []int // Individual die results
        Total    int   // Sum of all rolls
        Modifier int   // Modifier applied to the total
        Final    int   // Final result (Total + Modifier)
}

// DiceRoller handles rolling dice with various expressions
type DiceRoller struct {
        rng *rand.Rand
}

// NewDiceRoller creates a new dice roller with a random seed
func NewDiceRoller() *DiceRoller <span class="cov8" title="1">{
        return &amp;DiceRoller{
                rng: rand.New(rand.NewSource(time.Now().UnixNano())),
        }
}</span>

// NewDiceRollerWithSeed creates a new dice roller with a specific seed (for testing)
func NewDiceRollerWithSeed(seed int64) *DiceRoller <span class="cov8" title="1">{
        return &amp;DiceRoller{
                rng: rand.New(rand.NewSource(seed)),
        }
}</span>

// Roll parses and rolls a dice expression like "3d6+2", "1d20", "2d4-1"
func (dr *DiceRoller) Roll(expression string) (*DiceRoll, error) <span class="cov8" title="1">{
        if expression == "" </span><span class="cov8" title="1">{
                return &amp;DiceRoll{}, nil
        }</span>

        // Clean up the expression
        <span class="cov8" title="1">expression = strings.ReplaceAll(expression, " ", "")
        expression = strings.ToLower(expression)

        // Regex to parse dice expressions like "3d6+2", "1d20-1", "2d4"
        re := regexp.MustCompile(`^(\d+)d(\d+)([+-]\d+)?$`)
        matches := re.FindStringSubmatch(expression)

        if len(matches) &lt; 3 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid dice expression: %s", expression)
        }</span>

        // Parse number of dice
        <span class="cov8" title="1">numDice, err := strconv.Atoi(matches[1])
        if err != nil || numDice &lt;= 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid number of dice: %s", matches[1])
        }</span>

        // Parse die size
        <span class="cov8" title="1">dieSize, err := strconv.Atoi(matches[2])
        if err != nil || dieSize &lt;= 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid die size: %s", matches[2])
        }</span>

        // Parse modifier (optional)
        <span class="cov8" title="1">var modifier int
        if len(matches) &gt;= 4 &amp;&amp; matches[3] != "" </span><span class="cov8" title="1">{
                modifier, err = strconv.Atoi(matches[3])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid modifier: %s", matches[3])
                }</span>
        }

        // Roll the dice
        <span class="cov8" title="1">rolls := make([]int, numDice)
        total := 0

        for i := 0; i &lt; numDice; i++ </span><span class="cov8" title="1">{
                roll := dr.rng.Intn(dieSize) + 1
                rolls[i] = roll
                total += roll
        }</span>

        <span class="cov8" title="1">final := total + modifier

        return &amp;DiceRoll{
                Rolls:    rolls,
                Total:    total,
                Modifier: modifier,
                Final:    final,
        }, nil</span>
}

// RollMultiple rolls multiple dice expressions and returns the sum
func (dr *DiceRoller) RollMultiple(expressions []string) (*DiceRoll, error) <span class="cov8" title="1">{
        var allRolls []int
        var totalSum int
        var totalModifier int

        for _, expr := range expressions </span><span class="cov8" title="1">{
                if expr == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">roll, err := dr.Roll(expr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to roll %s: %w", expr, err)
                }</span>

                <span class="cov8" title="1">allRolls = append(allRolls, roll.Rolls...)
                totalSum += roll.Total
                totalModifier += roll.Modifier</span>
        }

        <span class="cov8" title="1">final := totalSum + totalModifier

        return &amp;DiceRoll{
                Rolls:    allRolls,
                Total:    totalSum,
                Modifier: totalModifier,
                Final:    final,
        }, nil</span>
}

// String returns a string representation of the dice roll
func (dr *DiceRoll) String() string <span class="cov8" title="1">{
        if len(dr.Rolls) == 0 </span><span class="cov8" title="1">{
                return "0"
        }</span>

        <span class="cov8" title="1">rollStr := fmt.Sprintf("%v", dr.Rolls)
        if dr.Modifier == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s = %d", rollStr, dr.Total)
        }</span> else<span class="cov8" title="1"> if dr.Modifier &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s + %d = %d", rollStr, dr.Modifier, dr.Final)
        }</span> else<span class="cov8" title="1"> {
                return fmt.Sprintf("%s - %d = %d", rollStr, -dr.Modifier, dr.Final)
        }</span>
}

// CalculateDiceAverage calculates the average result for a dice expression without rolling
func CalculateDiceAverage(expression string) (float64, error) <span class="cov8" title="1">{
        if expression == "" </span><span class="cov8" title="1">{
                return 0, nil
        }</span>

        // Clean up the expression
        <span class="cov8" title="1">expression = strings.ReplaceAll(expression, " ", "")
        expression = strings.ToLower(expression)

        // Regex to parse dice expressions
        re := regexp.MustCompile(`^(\d+)d(\d+)([+-]\d+)?$`)
        matches := re.FindStringSubmatch(expression)

        if len(matches) &lt; 3 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid dice expression: %s", expression)
        }</span>

        // Parse values
        <span class="cov8" title="1">numDice, err := strconv.Atoi(matches[1])
        if err != nil || numDice &lt;= 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid number of dice: %s", matches[1])
        }</span>

        <span class="cov8" title="1">dieSize, err := strconv.Atoi(matches[2])
        if err != nil || dieSize &lt;= 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid die size: %s", matches[2])
        }</span>

        <span class="cov8" title="1">var modifier int
        if len(matches) &gt;= 4 &amp;&amp; matches[3] != "" </span><span class="cov8" title="1">{
                modifier, err = strconv.Atoi(matches[3])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("invalid modifier: %s", matches[3])
                }</span>
        }

        // Calculate average: (dieSize + 1) / 2 is the average of a single die
        <span class="cov8" title="1">avgPerDie := float64(dieSize+1) / 2.0
        totalAvg := float64(numDice)*avgPerDie + float64(modifier)

        return totalAvg, nil</span>
}

// GlobalDiceRoller is the global dice roller instance used throughout the game
var GlobalDiceRoller = NewDiceRoller()
</pre>
		
		<pre class="file" id="file7" style="display: none">package game

// DispelInfo contains metadata about how a game effect can be dispelled or removed.
//
// Fields:
//   - Priority: Determines the order in which effects are dispelled (higher priority = dispelled first)
//   - Types: List of dispel types that can remove this effect (e.g. magic, poison, curse)
//   - Removable: Whether the effect can be removed at all
//
// Related types:
//   - DispelPriority: Priority level constants (0-100)
//   - DispelType: Type of dispel (magic, curse, poison, etc)
//   - Effect: Contains DispelInfo as a field
//
// Example usage:
//
//        info := DispelInfo{
//            Priority: DispelPriorityNormal,
//            Types: []DispelType{DispelMagic},
//            Removable: true,
//        }
//
// Moved from: effects.go
type DispelInfo struct {
        Priority  DispelPriority `yaml:"dispel_priority"`
        Types     []DispelType   `yaml:"dispel_types"`
        Removable bool           `yaml:"dispel_removable"`
}

// NewDispelInfo creates a new DispelInfo with the specified parameters.
// Moved from: effects.go
func NewDispelInfo(priority DispelPriority, types []DispelType, removable bool) *DispelInfo <span class="cov8" title="1">{
        return &amp;DispelInfo{
                Priority:  priority,
                Types:     types,
                Removable: removable,
        }
}</span>

// CanBeDispelledBy checks if this effect can be removed by the given dispel type.
// Moved from: effects.go
func (di *DispelInfo) CanBeDispelledBy(dispelType DispelType) bool <span class="cov8" title="1">{
        if !di.Removable </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, t := range di.Types </span><span class="cov8" title="1">{
                if t == dispelType || t == DispelAll </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return dispelType == DispelAll</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package game

import (
        "fmt"
        "time"
)

// Duration represents a game time duration
// Duration represents time duration in a game context, combining different time measurements.
// It can track duration in rounds, turns, and real-world time simultaneously.
//
// Fields:
//   - Rounds: Number of combat/game rounds the duration lasts
//   - Turns: Number of player/character turns the duration lasts
//   - RealTime: Actual real-world time duration (uses time.Duration)
//
// The zero value represents an instant/immediate duration with no lasting effect.
// All fields are optional and can be combined - e.g. "2 rounds and 30 seconds"
// Moved from: effects.go
type Duration struct {
        Rounds   int           `yaml:"duration_rounds"`
        Turns    int           `yaml:"duration_turns"`
        RealTime time.Duration `yaml:"duration_real"`
}

// NewDuration creates a new Duration with the specified parameters.
// Moved from: effects.go
func NewDuration(rounds, turns int, realTime time.Duration) Duration <span class="cov8" title="1">{
        return Duration{
                Rounds:   rounds,
                Turns:    turns,
                RealTime: realTime,
        }
}</span>

// IsExpired checks if the duration has elapsed.
// For game purposes, this checks if all duration components are zero or negative.
// Moved from: effects.go
func (d Duration) IsExpired() bool <span class="cov8" title="1">{
        return d.Rounds &lt;= 0 &amp;&amp; d.Turns &lt;= 0 &amp;&amp; d.RealTime &lt;= 0
}</span>

// String returns a human-readable representation of the duration.
// Moved from: effects.go
func (d Duration) String() string <span class="cov8" title="1">{
        if d.Rounds &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d rounds", d.Rounds)
        }</span>
        <span class="cov8" title="1">if d.Turns &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d turns", d.Turns)
        }</span>
        <span class="cov8" title="1">if d.RealTime &gt; 0 </span><span class="cov8" title="1">{
                return d.RealTime.String()
        }</span>
        <span class="cov8" title="1">return "instant"</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package game

import (
        "time"

        "github.com/sirupsen/logrus"
)

// DamageEffect represents a damage-dealing effect in the game system.
// It extends the base Effect struct with damage-specific attributes.
//
// Fields:
//   - Effect: Pointer to the base Effect struct containing common effect properties
//   - DamageType: The type of damage dealt (e.g. physical, magical, etc)
//   - BaseDamage: The base amount of damage before scaling
//   - DamageScale: Multiplier applied to the base damage
//   - PenetrationPct: Percentage of target's defense that is ignored
//
// Related types:
//   - Effect: Base effect type this extends
//   - DamageType: Enum of possible damage types
//
// Example usage:
//
//        damageEffect := &amp;DamageEffect{
//          Effect: &amp;Effect{},
//          DamageType: Physical,
//          BaseDamage: 10.0,
//          DamageScale: 1.5,
//          PenetrationPct: 0.25,
//        }
type DamageEffect struct {
        Effect         *Effect    `yaml:",inline"` // Change to pointer
        DamageType     DamageType `yaml:"damage_type"`
        BaseDamage     float64    `yaml:"base_damage"`
        DamageScale    float64    `yaml:"damage_scale"`
        PenetrationPct float64    `yaml:"penetration_pct"`
}

// GetEffect returns the Effect object associated with this DamageEffect.
// This is an accessor method that provides access to the underlying Effect field.
//
// Returns:
//   - *Effect: A pointer to the Effect object contained within this DamageEffect
//
// Related types:
//   - Effect type
//   - DamageEffect type
func (de *DamageEffect) GetEffect() *Effect <span class="cov8" title="1">{
        return de.Effect
}</span>

// CreatePoisonEffect creates a new poison damage effect with the specified base damage and duration.
// This is a convenience function for creating poison effects that deal damage over time.
func CreatePoisonEffect(baseDamage float64, duration time.Duration) *DamageEffect <span class="cov8" title="1">{
        return &amp;DamageEffect{
                Effect: NewEffect(EffectPoison, Duration{
                        Rounds:   0,
                        Turns:    0,
                        RealTime: duration,
                }, baseDamage),
                DamageType:     DamagePoison,
                BaseDamage:     baseDamage,
                DamageScale:    0.8,
                PenetrationPct: 0,
        }
}</span>

// CreateBurningEffect creates a new fire-based damage effect that deals damage over time
//
// Parameters:
//   - baseDamage: Base damage per tick (float64) that will be dealt
//   - duration: How long the burning effect lasts (time.Duration)
//
// Returns:
//
//        *DamageEffect - A configured burning damage effect with:
//        - Fire damage type
//        - 20% damage scaling multiplier
//        - No armor penetration
//        - Real-time based duration tracking
//
// Related:
//   - DamageEffect
//   - EffectBurning constant
//   - DamageFire constant
func CreateBurningEffect(baseDamage float64, duration time.Duration) *DamageEffect <span class="cov8" title="1">{
        return &amp;DamageEffect{
                Effect: NewEffect(EffectBurning, Duration{
                        Rounds:   0,
                        Turns:    0,
                        RealTime: duration,
                }, baseDamage),
                DamageType:     DamageFire,
                BaseDamage:     baseDamage,
                DamageScale:    1.2,
                PenetrationPct: 0,
        }
}</span>

// CreateBleedingEffect creates a new bleeding damage effect that deals continuous physical damage over time
//
// Parameters:
//   - baseDamage: Base amount of physical damage dealt per tick (float64, must be &gt;= 0)
//   - duration: How long the bleeding effect lasts (time.Duration)
//
// Returns:
//
//        *DamageEffect - A configured bleeding damage effect that:
//        - Deals physical damage over time
//        - Ignores 50% of armor via penetration
//        - Scales at 1.0x base damage
//
// Related:
//   - DamageEffect struct
//   - NewEffect() - Base effect constructor
//   - EffectBleeding constant
//   - DamagePhysical constant
func CreateBleedingEffect(baseDamage float64, duration time.Duration) *DamageEffect <span class="cov8" title="1">{
        return &amp;DamageEffect{
                Effect: NewEffect(EffectBleeding, Duration{
                        Rounds:   0,
                        Turns:    0,
                        RealTime: duration,
                }, baseDamage),
                DamageType:     DamagePhysical,
                BaseDamage:     baseDamage,
                DamageScale:    1.0,
                PenetrationPct: 0.5, // Bleeding ignores 50% of armor
        }
}</span>

// Add method to check if Effect is DamageEffect

// AsDamageEffect attempts to convert a generic Effect into a DamageEffect.
//
// Parameters:
//   - e: A pointer to the Effect to convert
//
// Returns:
//   - *DamageEffect: A pointer to the created DamageEffect if conversion was successful
//   - bool: True if conversion was successful, false otherwise
//
// The function will only convert effects of type EffectPoison, EffectBurning, or EffectBleeding.
// For all other effect types, it returns nil and false.
//
// The resulting DamageEffect will:
// - Inherit the base Effect properties
// - Use the original Effect's DamageType and Magnitude
// - Have DamageScale and PenetrationPct set to 0
//
// Related types:
//   - Effect
//   - DamageEffect
//   - EffectType (EffectPoison, EffectBurning, EffectBleeding)
func AsDamageEffect(e *Effect) (*DamageEffect, bool) <span class="cov8" title="1">{
        if e == nil </span><span class="cov8" title="1">{
                return nil, false
        }</span>
        <span class="cov8" title="1">switch e.Type </span>{
        case EffectPoison, EffectBurning, EffectBleeding:<span class="cov8" title="1">
                return &amp;DamageEffect{
                        Effect:         e,
                        DamageType:     e.DamageType,
                        BaseDamage:     e.Magnitude,
                        DamageScale:    0,
                        PenetrationPct: 0,
                }, true</span>
        default:<span class="cov8" title="1">
                return nil, false</span>
        }
}

// Extend EffectManager with specific effect processing

// processDamageEffect applies damage and additional effects from a DamageEffect to the target.
// It checks if the effect should tick based on the current time, calculates the final damage
// accounting for stacks, scaling and resistance, and applies specific status effects based on
// the effect type.
//
// Parameters:
//   - effect: *DamageEffect - Contains damage and effect properties to be applied
//   - currentTime: time.Time - Current game time used to check effect tick timing
//
// Notable effects by type:
//   - EffectBurning: Reduces max mana by 5%
//   - EffectBleeding: Applies 50% healing debuff
//   - EffectPoison: Applies 2% stat reduction
//   - Other effect types are reserved for future implementation
//
// Panics if an unexpected EffectType is provided.
//
// Related types:
//   - DamageEffect
//   - Effect
//   - EffectType
func (em *EffectManager) processDamageEffect(effect *DamageEffect, currentTime time.Time) <span class="cov0" title="0">{
        if !effect.Effect.ShouldTick(currentTime) </span><span class="cov0" title="0">{
                return
        }</span>

        // Calculate damage based on stacks and scaling
        <span class="cov0" title="0">baseDamage := effect.BaseDamage * effect.DamageScale * float64(effect.Effect.Stacks)

        // Apply damage type modifiers
        finalDamage := em.calculateDamageWithResistance(baseDamage, effect)

        // Apply the damage
        em.currentStats.Health -= finalDamage

        // Handle additional effect-specific behaviors
        switch effect.Effect.Type </span>{
        case EffectBurning:<span class="cov0" title="0">
                em.currentStats.MaxMana *= 0.95</span>
        case EffectBleeding:<span class="cov0" title="0">
                em.applyHealingDebuff(0.5)</span>
        case EffectPoison:<span class="cov0" title="0">
                em.applyStatDebuff(0.98)</span>
        case EffectDamageOverTime:<span class="cov0" title="0"></span>
        case EffectHealOverTime:<span class="cov0" title="0"></span>
        case EffectRoot:<span class="cov0" title="0"></span>
        case EffectStatBoost:<span class="cov0" title="0"></span>
        case EffectStatPenalty:<span class="cov0" title="0"></span>
        case EffectStun:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                logrus.WithField("effectType", effect.Effect.Type).Error("unsupported effect type in processDamageEffect")</span>
        }
}

// Helper methods for damage calculation

// calculateDamageWithResistance calculates the final damage value after applying defense and resistance.
//
// Parameters:
//   - baseDamage (float64): The initial damage amount to be modified
//   - effect (*DamageEffect): Effect struct containing DamageType and PenetrationPct
//
// Returns:
//
//        float64: The final calculated damage value after applying defenses and resistances
//
// The calculation follows these steps:
// 1. Gets defense from currentStats and resistance for the damage type
// 2. Applies penetration percentage to reduce effective defense
// 3. Calculates damage reduction using standard formula: 1 - (defense/(defense + 100))
// 4. Applies resistance as a direct multiplier
//
// Related:
//   - DamageEffect struct
//   - getResistanceForDamageType method
func (em *EffectManager) calculateDamageWithResistance(baseDamage float64, effect *DamageEffect) float64 <span class="cov8" title="1">{
        // Get defense and resistances
        defense := em.currentStats.Defense
        resistance := em.getResistanceForDamageType(effect.DamageType)

        // Apply penetration
        effectiveDefense := defense * (1 - effect.PenetrationPct)

        // Calculate damage reduction with protection against division by zero
        var damageReduction float64
        denominator := effectiveDefense + 100
        if denominator == 0 </span><span class="cov8" title="1">{
                // Handle edge case where effectiveDefense = -100
                // In this case, assume maximum damage (no reduction)
                damageReduction = 1.0
        }</span> else<span class="cov0" title="0"> {
                damageReduction = 1 - (effectiveDefense / denominator)
        }</span>
        <span class="cov8" title="1">resistanceMultiplier := 1 - resistance

        return baseDamage * damageReduction * resistanceMultiplier</span>
}

// getResistanceForDamageType returns the resistance value for a given damage type.
// The resistance value reduces damage taken of that type, with higher values providing more protection.
//
// Parameters:
//   - dmgType: The type of damage to get resistance for (e.g. DamageFire, DamagePoison)
//
// Returns:
//
//        float64 representing the resistance value (0.0 - 1.0) where:
//        - 0.0 means no resistance (full damage taken)
//        - Higher values mean more resistance (less damage taken)
//
// Notes:
// - Currently only handles Fire and Poison damage types
// - All other damage types return 0 (no resistance)
// - Could be expanded to check equipment buffs and other modifiers
//
// Related:
// - DamageType enum
// - EffectType enum (for resistance mapping)
func (em *EffectManager) getResistanceForDamageType(dmgType DamageType) float64 <span class="cov8" title="1">{
        // This could be expanded to check equipment, buffs, etc.
        switch dmgType </span>{
        case DamageFire:<span class="cov8" title="1">
                return em.resistances[EffectBurning]</span>
        case DamagePoison:<span class="cov0" title="0">
                return em.resistances[EffectPoison]</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// Status effect utility methods

// applyStatDebuff applies a multiplier to reduce all base stats (Strength, Dexterity, Intelligence)
// of the current stats object managed by the EffectManager.
//
// Parameters:
//   - multiplier: float64 - The multiplier to apply to all stats (should be &lt; 1.0 for debuffs)
//
// The function directly modifies the currentStats object and does not return a value.
//
// Note: This method assumes positive multiplier values. Negative multipliers would invert stats.
// Stats are not clamped to any min/max values after multiplication.
//
// Related:
// - EffectManager.currentStats field
// - Stats struct containing the base stats
func (em *EffectManager) applyStatDebuff(multiplier float64) <span class="cov0" title="0">{
        em.currentStats.Strength *= multiplier
        em.currentStats.Dexterity *= multiplier
        em.currentStats.Intelligence *= multiplier
}</span>

// applyHealingDebuff applies a healing modifier multiplier to the effect manager
// that will scale any future healing effects.
//
// Parameters:
//   - multiplier: float64 - Scaling factor to modify healing effects. Values less than 1.0
//     reduce healing, values greater than 1.0 increase healing.
//
// This method updates the internal healingModifier field which is used by other
// methods when calculating healing amounts. The modifier persists until changed again.
//
// Related:
//   - EffectManager.healingModifier field
//   - Methods that apply healing effects should check this modifier
func (em *EffectManager) applyHealingDebuff(multiplier float64) <span class="cov0" title="0">{
        // Store healing modifier in the manager
        em.healingModifier = multiplier
}</span>

// Update the main effect processing to handle damage effects
// processEffectTick processes a single tick of an effect on the target entity.
//
// It handles different types of effects including:
// - Damage effects (via processDamageEffect)
// - Damage over time
// - Healing over time
// - Status effects (bleeding, burning, poison, root, stun)
// - Stat modifications (boosts and penalties)
//
// Parameters:
//   - effect: *Effect - The effect to process, containing type, magnitude, stacks etc.
//
// Notable behaviors:
// - For damage effects, delegates to processDamageEffect
// - For healing, applies healing modifier and caps at max health
// - Panics on unknown effect types
//
// Related types:
// - Effect
// - DamageEffect
func (em *EffectManager) processEffectTick(effect *Effect) <span class="cov0" title="0">{
        if damageEffect, ok := ToDamageEffect(effect); ok </span><span class="cov0" title="0">{
                em.processDamageEffect(damageEffect, time.Now())
                return
        }</span>

        // Handle other effect types...
        <span class="cov0" title="0">switch effect.Type </span>{
        case EffectDamageOverTime:<span class="cov0" title="0">
                em.currentStats.Health -= effect.Magnitude * float64(effect.Stacks)</span>
        case EffectHealOverTime:<span class="cov0" title="0">
                healing := effect.Magnitude * float64(effect.Stacks)
                if em.healingModifier != 0 </span><span class="cov0" title="0">{
                        healing *= em.healingModifier
                }</span>
                <span class="cov0" title="0">em.currentStats.Health = min(
                        em.currentStats.Health+healing,
                        em.currentStats.MaxHealth,
                )</span>
        case EffectBleeding:<span class="cov0" title="0"></span>
        case EffectBurning:<span class="cov0" title="0"></span>
        case EffectPoison:<span class="cov0" title="0"></span>
        case EffectRoot:<span class="cov0" title="0"></span>
        case EffectStatBoost:<span class="cov0" title="0"></span>
        case EffectStatPenalty:<span class="cov0" title="0"></span>
        case EffectStun:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                logrus.WithField("effectType", effect.Type).Error("unsupported effect type in processEffectTick")</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package game

import (
        "fmt"
        "sort"
        "time"
)

// initializeDefaultImmunities sets up the default immunity data for various effect types
// in the EffectManager. It populates the immunities map with predefined immunity configurations
// for common effect types like poison.
//
// This method is called internally during EffectManager initialization and should not need
// to be called directly.
//
// Current default immunities:
// - Poison: 25% resistance, partial immunity, no duration limit
//
// Related types:
// - EffectType: Enum defining possible effect types
// - ImmunityData: Struct containing immunity configuration
// - ImmunityType: Enum defining immunity types (full vs partial)
func (em *EffectManager) initializeDefaultImmunities() <span class="cov8" title="1">{
        // Example default immunities
        em.immunities[EffectPoison] = &amp;ImmunityData{
                Type:       ImmunityPartial,
                Duration:   0,
                Resistance: 0.25,
                ExpiresAt:  time.Time{},
        }
}</span>

// AddImmunity adds an immunity to a specific effect type to the EffectManager.
// If the immunity has a duration &gt; 0, it is added as a temporary immunity
// that will expire after the specified duration. Otherwise, it is added
// as a permanent immunity.
//
// Parameters:
//   - effectType: The type of effect to become immune to
//   - immunity: ImmunityData struct containing duration and other immunity properties
//
// The immunity is stored in either tempImmunities or immunities map based on duration.
// If duration &gt; 0, ExpiresAt is calculated as current time + duration.
//
// Thread-safe through mutex locking.
//
// Related:
//   - ImmunityData struct
//   - EffectType type
func (em *EffectManager) AddImmunity(effectType EffectType, immunity ImmunityData) <span class="cov8" title="1">{
        em.mu.Lock()
        defer em.mu.Unlock()

        if immunity.Duration &gt; 0 </span><span class="cov8" title="1">{
                immunity.ExpiresAt = time.Now().Add(immunity.Duration)
                em.tempImmunities[effectType] = &amp;immunity
        }</span> else<span class="cov8" title="1"> {
                em.immunities[effectType] = &amp;immunity
        }</span>
}

// CheckImmunity checks if there is an active immunity against the given effect type.
// It first checks temporary immunities, then permanent immunities.
//
// Parameters:
//   - effectType: The type of effect to check immunity against
//
// Returns:
//   - *ImmunityData: Contains immunity details including:
//   - Type: The type of immunity (temporary, permanent, or none)
//   - Duration: How long the immunity lasts (0 for permanent)
//   - Resistance: Resistance level against the effect (0-100)
//   - ExpiresAt: When the immunity expires (empty for permanent)
//
// Thread-safety:
// This method is thread-safe as it uses a read lock when accessing the immunity maps.
//
// Notable behaviors:
// - Automatically cleans up expired temporary immunities when encountered
// - Returns a default ImmunityData with ImmunityNone if no immunity exists
// - Temporary immunities take precedence over permanent ones
//
// Related types:
// - ImmunityData
// - EffectType
func (em *EffectManager) CheckImmunity(effectType EffectType) *ImmunityData <span class="cov8" title="1">{
        em.mu.RLock()
        defer em.mu.RUnlock()

        // Check temporary immunities first
        if immunity, exists := em.tempImmunities[effectType]; exists </span><span class="cov8" title="1">{
                if time.Now().Before(immunity.ExpiresAt) </span><span class="cov8" title="1">{
                        return immunity
                }</span>
                // Clean up expired temporary immunity
                <span class="cov8" title="1">delete(em.tempImmunities, effectType)</span>
        }

        // Check permanent immunities
        <span class="cov8" title="1">if immunity, exists := em.immunities[effectType]; exists </span><span class="cov8" title="1">{
                return immunity
        }</span>

        <span class="cov8" title="1">return &amp;ImmunityData{
                Type:       ImmunityNone,
                Duration:   0,
                Resistance: 0,
                ExpiresAt:  time.Time{},
        }</span>
}

// DispelEffects removes a specified number of active effects of a given dispel type from the entity.
// It handles effect removal based on their dispel priority, with higher priority effects being removed first.
//
// Parameters:
//   - dispelType: The type of dispel to apply (e.g., magic, curse, etc.). Using DispelAll will target all dispellable effects
//   - count: Maximum number of effects to remove. Must be &gt;= 0
//
// Returns:
//   - []string: Slice containing the IDs of all removed effects
//
// Notable behaviors:
//   - Thread-safe due to mutex locking
//   - Only removes effects marked as removable
//   - Automatically recalculates stats if any effects were removed
//   - If count exceeds available effects, removes all eligible effects
//
// Related types:
//   - DispelType: Enum defining different types of dispel
//   - DispelPriority: Defines removal priority of effects
//   - Effect.DispelInfo: Contains dispel-related properties of an effect
func (em *EffectManager) DispelEffects(dispelType DispelType, count int) []string <span class="cov8" title="1">{
        em.mu.Lock()
        defer em.mu.Unlock()

        // Collect eligible effects
        type dispelCandidate struct {
                id       string
                effect   *Effect
                priority DispelPriority
        }

        var candidates []dispelCandidate

        for id, effect := range em.activeEffects </span><span class="cov8" title="1">{
                if !effect.DispelInfo.Removable </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, dType := range effect.DispelInfo.Types </span><span class="cov8" title="1">{
                        if dType == dispelType || dispelType == DispelAll </span><span class="cov8" title="1">{
                                candidates = append(candidates, dispelCandidate{
                                        id:       id,
                                        effect:   effect,
                                        priority: effect.DispelInfo.Priority,
                                })
                                break</span>
                        }
                }
        }

        // Sort by priority (highest first)
        <span class="cov8" title="1">sort.Slice(candidates, func(i, j int) bool </span><span class="cov8" title="1">{
                return candidates[i].priority &gt; candidates[j].priority
        }</span>)

        // Remove effects
        <span class="cov8" title="1">removed := make([]string, 0, count)
        for i := 0; i &lt; len(candidates) &amp;&amp; i &lt; count; i++ </span><span class="cov8" title="1">{
                delete(em.activeEffects, candidates[i].id)
                removed = append(removed, candidates[i].id)
        }</span>

        <span class="cov8" title="1">if len(removed) &gt; 0 </span><span class="cov8" title="1">{
                em.recalculateStats()
        }</span>

        <span class="cov8" title="1">return removed</span>
}

// Helper function to create effect with dispel info

// NewEffectWithDispel creates a new Effect with dispel information.
// It extends NewEffect by adding dispel information to handle dispelling/cleansing mechanics.
//
// Parameters:
//   - effectType: The type of effect to create (e.g. buff, debuff, etc)
//   - duration: How long the effect lasts
//   - magnitude: The strength/intensity of the effect
//   - dispelInfo: Information about how this effect can be dispelled/cleansed
//
// Returns:
//
//        A pointer to the newly created Effect with dispel information
//
// Related:
//   - NewEffect - Base effect creation function
//   - Effect - The main effect struct
//   - DispelInfo - Struct containing dispel rules and mechanics
func NewEffectWithDispel(effectType EffectType, duration Duration, magnitude float64, dispelInfo DispelInfo) *Effect <span class="cov8" title="1">{
        effect := NewEffect(effectType, duration, magnitude)
        effect.DispelInfo = dispelInfo
        return effect
}</span>

// CreatePoisonEffectWithDispel creates a poison damage effect that can be dispelled.
// It extends the basic poison effect by adding dispel information.
//
// Parameters:
//   - baseDamage: The base damage per tick (must be &gt;= 0)
//   - duration: How long the poison effect lasts (must be &gt; 0)
//
// Returns:
//
//        A DamageEffect pointer configured as a dispellable poison effect
//
// Related:
//   - CreatePoisonEffect - Base poison effect creator
//   - DispelInfo - Structure defining dispel properties
//   - DamageEffect - Base damage effect type
//
// The effect can be removed by poison or magic dispel types with normal priority.
func CreatePoisonEffectWithDispel(baseDamage float64, duration time.Duration) *DamageEffect <span class="cov8" title="1">{
        effect := CreatePoisonEffect(baseDamage, duration)
        effect.Effect.DispelInfo = DispelInfo{
                Priority:  DispelPriorityNormal,
                Types:     []DispelType{DispelPoison, DispelMagic},
                Removable: true,
        }
        return effect
}</span>

// ApplyEffect attempts to apply the given effect to the target, taking into account any immunities.
// It handles different types of immunities including complete immunity, reflection, and partial resistance.
//
// Parameters:
//   - effect: *Effect - The effect to be applied, containing type and magnitude information
//
// Returns:
//   - error: Returns an error if the effect cannot be applied (immunity/reflection) or if internal application fails
//
// Error cases:
//   - Returns error if target has complete immunity to the effect type
//   - Returns error if effect is reflected
//   - Panics if an unknown immunity type is encountered
//
// Related:
//   - CheckImmunity() - Called internally to determine immunity status
//   - applyEffectInternal() - Called to handle actual effect application
func (em *EffectManager) ApplyEffect(effect *Effect) error <span class="cov8" title="1">{
        immunity := em.CheckImmunity(effect.Type)

        switch immunity.Type </span>{
        case ImmunityComplete:<span class="cov8" title="1">
                return fmt.Errorf("target is immune to %s effects", effect.Type)</span>

        case ImmunityReflect:<span class="cov8" title="1">
                // Handle reflection logic
                return fmt.Errorf("effect reflected")</span>

        case ImmunityPartial:<span class="cov8" title="1">
                effect.Magnitude *= (1 - immunity.Resistance)</span>
        case ImmunityNone:<span class="cov8" title="1"></span>
                // No immunity, proceed normally
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown immunity type: %v", immunity.Type)</span>
        }

        // Continue with normal effect application...
        <span class="cov8" title="1">return em.applyEffectInternal(effect)</span>
}

// ExampleEffectDispel demonstrates how to create, apply and dispel effects in the game.
// It shows:
// - Creating a poison effect with damage and duration
// - Creating a curse effect with dispel properties
// - Applying effects to an effect manager
// - Dispelling effects based on priority
//
// This example illustrates the dispel system workflow:
// 1. Create effects with dispel properties
// 2. Apply them to an effect manager
// 3. Selectively remove effects using dispel type and count
//
// Related types:
// - Effect: Base effect interface
// - EffectManager: Manages active effects
// - DispelInfo: Controls how effects can be dispelled
// - DispelType: Categories of dispel effects (curse, magic, etc)
//
// The example does not handle errors from ApplyEffect() for simplicity.
// In production code, these errors should be properly handled.
func ExampleEffectDispel() <span class="cov8" title="1">{
        em := NewEffectManager(NewDefaultStats())

        // Add some effects
        poison := CreatePoisonEffect(10, 30*time.Second)
        curse := NewEffectWithDispel(EffectStatPenalty,
                Duration{
                        Rounds:   0,
                        Turns:    0,
                        RealTime: 60 * time.Second,
                },
                -5,
                DispelInfo{
                        Priority:  DispelPriorityHigh,
                        Types:     []DispelType{DispelCurse, DispelMagic},
                        Removable: true,
                },
        )

        // Apply effects using their base Effect
        _ = em.ApplyEffect(poison.GetEffect())
        _ = em.ApplyEffect(curse)

        // Dispel highest priority effects
        removed := em.DispelEffects(DispelMagic, 1)
        _ = removed // Use removed to avoid unused variable warning
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package game

import (
        "fmt"
        "time"
)

// EffectHolder represents an entity that can have effects applied
// EffectHolder defines an interface for entities that can have effects applied to them.
// An effect holder maintains both current stats (which include effect modifications)
// and base stats (original values before effects).
//
// Implementations must handle:
// - Effect management (add/remove/query)
// - Current stats that can be modified by effects
// - Base stats that represent original unmodified values
//
// Related types:
// - Effect: Represents a single effect that can be applied
// EffectHolder interface is defined in types.go
// - Stats: Contains the actual stat values
// - EffectType: Enumeration of possible effect types

// Stats represents an entity's modifiable attributes
// Stats represents a character's base and derived statistics in the game.
// It contains both primary attributes that can be directly modified
// and secondary (calculated) attributes that are derived from the primary ones.
//
// Primary attributes:
//   - Health: Current health points
//   - Mana: Current mana points
//   - Strength: Physical power and carrying capacity
//   - Dexterity: Agility and precision
//   - Intelligence: Mental capability and magical aptitude
//
// Calculated attributes:
//   - MaxHealth: Maximum possible health points
//   - MaxMana: Maximum possible mana points
//   - Defense: Damage reduction capability
//   - Speed: Movement and action speed
//
// The Stats struct is used throughout the game systems including:
// - Combat calculations
// - Character progression
// - Status effect application
// - Equipment bonuses
type Stats struct {
        Health       float64
        Mana         float64
        Strength     float64
        Dexterity    float64
        Intelligence float64
        // Add other stats as needed

        // Calculated stats
        MaxHealth float64
        MaxMana   float64
        Defense   float64
        Speed     float64
}

// NewDefaultStats creates and returns a new Stats structure initialized with default values.
// It sets baseline stats that are commonly used as a starting point for new game entities.
//
// Returns:
//   - *Stats: A pointer to a new Stats structure with the following default values:
//     Health: 100, Mana: 100, Strength: 10, Dexterity: 10, Intelligence: 10,
//     MaxHealth: 100, MaxMana: 100, Defense: 10, Speed: 10
//
// Related types:
//   - Stats struct: The base structure containing all stat fields
func NewDefaultStats() *Stats <span class="cov8" title="1">{
        return &amp;Stats{
                Health:       100,
                Mana:         100,
                Strength:     10,
                Dexterity:    10,
                Intelligence: 10,
                MaxHealth:    100,
                MaxMana:      100,
                Defense:      10,
                Speed:        10,
        }
}</span>

// RemoveEffect removes an effect by ID
// RemoveEffect deactivates and removes an effect from the active effects list by its ID.
//
// Parameters:
//   - effectID: string - The unique identifier of the effect to remove
//
// Returns:
//   - error: Returns nil if effect was successfully removed, or an error if effect was not found
//
// Notable behavior:
// - Locks the EffectManager mutex during operation to ensure thread safety
// - Sets effect's IsActive flag to false before removal
// - Triggers recalculation of stats after removing the effect
// - Returns error if effect ID does not exist in activeEffects map
//
// Related:
// - recalculateStats() - Called after effect removal to update stats
func (em *EffectManager) RemoveEffect(effectID string) error <span class="cov0" title="0">{
        em.mu.Lock()
        defer em.mu.Unlock()

        if effect, exists := em.activeEffects[effectID]; exists </span><span class="cov0" title="0">{
                effect.IsActive = false
                delete(em.activeEffects, effectID)
                em.recalculateStats()
                return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("effect not found: %s", effectID)</span>
}

// UpdateEffects processes all active effects
// UpdateEffects processes and maintains active effects based on the current time.
// It handles effect expiration, periodic effect ticks, and stat recalculation.
//
// Parameters:
//   - currentTime time.Time: The current game time to check effects against
//
// The method performs the following:
// - Removes expired effects from activeEffects
// - Triggers periodic effect ticks when appropriate
// - Recalculates stats if any effects were removed
//
// Thread-safety: Uses mutex locking to safely modify shared state
//
// Related:
// - EffectManager.processEffectTick()
// - EffectManager.recalculateStats()
func (em *EffectManager) UpdateEffects(currentTime time.Time) <span class="cov0" title="0">{
        em.mu.Lock()
        defer em.mu.Unlock()

        needsRecalc := false

        for id, effect := range em.activeEffects </span><span class="cov0" title="0">{
                // Check expiration
                if effect.IsExpired(currentTime) </span><span class="cov0" title="0">{
                        delete(em.activeEffects, id)
                        needsRecalc = true
                        continue</span>
                }

                // Process periodic effects
                <span class="cov0" title="0">if effect.ShouldTick(currentTime) </span><span class="cov0" title="0">{
                        em.processEffectTick(effect)
                }</span>
        }

        <span class="cov0" title="0">if needsRecalc </span><span class="cov0" title="0">{
                em.recalculateStats()
        }</span>
}

// recalculateStats applies all active effects to base stats
// recalculateStats recalculates entity stats by applying all active effect modifiers.
// It processes effects in the following order:
// 1. Collects all additive, multiplicative and set modifiers from active effects
// 2. Applies modifiers in order: additive -&gt; multiplicative -&gt; set
//
// The method updates em.currentStats with the newly calculated stats.
// Base stats are preserved in em.baseStats.
//
// Related types:
// - ModOperation (pkg/game/effect.go)
// - Stats (pkg/game/stats.go)
//
// Note: Effect magnitudes are multiplied by stack count when applying modifiers.
func (em *EffectManager) recalculateStats() <span class="cov8" title="1">{
        // Start with base stats
        newStats := em.baseStats.Clone()

        // First pass: collect all modifiers
        addMods := make(map[string]float64)
        multMods := make(map[string]float64)
        setMods := make(map[string]float64)

        for _, effect := range em.activeEffects </span><span class="cov8" title="1">{
                magnitude := effect.Magnitude * float64(effect.Stacks)

                for _, mod := range effect.Modifiers </span><span class="cov0" title="0">{
                        switch mod.Operation </span>{
                        case ModAdd:<span class="cov0" title="0">
                                addMods[mod.Stat] += mod.Value * magnitude</span>
                        case ModMultiply:<span class="cov0" title="0">
                                multMods[mod.Stat] = (multMods[mod.Stat] + 1) * (mod.Value * magnitude)</span>
                        case ModSet:<span class="cov0" title="0">
                                if current, exists := setMods[mod.Stat]; !exists || mod.Value &gt; current </span><span class="cov0" title="0">{
                                        setMods[mod.Stat] = mod.Value * magnitude
                                }</span>
                        }
                }
        }

        // Apply modifications in order: add -&gt; multiply -&gt; set
        <span class="cov8" title="1">em.applyStatModifiers(newStats, addMods, multMods, setMods)

        em.currentStats = newStats</span>
}

// Helper methods

// applyStatModifiers applies additive, multiplicative and set modifiers to a Stats object's attributes.
//
// Parameters:
//   - stats: *Stats - Pointer to the Stats object to be modified
//   - addMods: map[string]float64 - Map of stat names to values to be added
//   - multMods: map[string]float64 - Map of stat names to multiplication factors
//   - setMods: map[string]float64 - Map of stat names to values to directly set
//
// The function processes modifiers in order: additive -&gt; multiplicative -&gt; set.
// Stats that don't have corresponding modifiers remain unchanged.
// Stats names must match the lowercase string keys: "health", "mana", "strength", etc.
//
// Related types:
//   - Stats struct containing the modifiable attributes
func (em *EffectManager) applyStatModifiers(stats *Stats, addMods, multMods, setMods map[string]float64) <span class="cov8" title="1">{
        // Helper function to apply mods to a stat
        applyStat := func(current *float64, statName string) </span><span class="cov8" title="1">{
                if add, ok := addMods[statName]; ok </span><span class="cov0" title="0">{
                        *current += add
                }</span>
                <span class="cov8" title="1">if mult, ok := multMods[statName]; ok </span><span class="cov0" title="0">{
                        *current *= mult
                }</span>
                <span class="cov8" title="1">if set, ok := setMods[statName]; ok </span><span class="cov0" title="0">{
                        *current = set
                }</span>
        }

        // Apply to each stat
        <span class="cov8" title="1">applyStat(&amp;stats.Health, "health")
        applyStat(&amp;stats.Mana, "mana")
        applyStat(&amp;stats.Strength, "strength")
        applyStat(&amp;stats.Dexterity, "dexterity")
        applyStat(&amp;stats.Intelligence, "intelligence")</span>
        // Apply to other stats
}

// Clone creates and returns a deep copy of a Stats object
// Clone duplicates all stat values into a new Stats instance.
//
// Returns:
//   - *Stats: A new Stats instance with identical values to the original
//
// Notable behavior:
// - Creates a completely independent copy of the Stats object
// - All fields are copied by value since they are primitive types
//
// Related types:
// - Stats struct: The base structure containing all stat fields
// - NewDefaultStats(): Factory method for creating Stats objects
func (s *Stats) Clone() *Stats <span class="cov8" title="1">{
        return &amp;Stats{
                Health:       s.Health,
                Mana:         s.Mana,
                Strength:     s.Strength,
                Dexterity:    s.Dexterity,
                Intelligence: s.Intelligence,
                MaxHealth:    s.MaxHealth,
                MaxMana:      s.MaxMana,
                Defense:      s.Defense,
                Speed:        s.Speed,
        }
}</span>

// Helper function for min value
// min returns the smaller of two float64 numbers.
//
// Parameters:
//   - a: first float64 number to compare
//   - b: second float64 number to compare
//
// Returns:
//   - float64: the smaller of a and b
//
// minFloat function is now defined in utils.go

// AllowsStacking determines whether effects of this type can stack with each other.
// This method controls which effect types can have multiple instances active at once
// on the same target.
//
// Returns:
//   - true if effects of this type can stack (EffectDamageOverTime, EffectHealOverTime, EffectStatBoost)
//   - false for all other effect types
//
// Related types:
//   - EffectType: The enum type this method belongs to
//   - Effect: The main effect struct that uses this stacking behavior
func (et EffectType) AllowsStacking() bool <span class="cov8" title="1">{
        switch et </span>{
        case EffectDamageOverTime, EffectHealOverTime, EffectStatBoost:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// applyEffectInternal applies an effect to an entity's active effects list, handling stacking
// and magnitude-based replacement of existing effects.
//
// Parameters:
//   - effect: *Effect - The effect to be applied. Must not be nil.
//
// Returns:
//   - error: Returns nil on successful application, or an error if:
//   - A weaker non-stacking effect is applied when a stronger one exists
//   - The effect parameter is nil
//
// Behavior:
//   - For stackable effects: Increments stack count on existing effect
//   - For non-stackable effects: Replaces existing if new effect is stronger
//   - For new effect types: Adds to active effects list
//   - Recalculates stats after any changes
//
// Related:
//   - Effect.Type.AllowsStacking()
//   - EffectManager.recalculateStats()
func (em *EffectManager) applyEffectInternal(effect *Effect) error <span class="cov8" title="1">{
        em.mu.Lock()
        defer em.mu.Unlock()

        // Check for existing effect of same type
        for _, existing := range em.activeEffects </span><span class="cov8" title="1">{
                if existing.Type == effect.Type </span><span class="cov8" title="1">{
                        switch </span>{
                        case effect.Type.AllowsStacking():<span class="cov8" title="1">
                                existing.Stacks++
                                return nil</span>
                        case effect.Magnitude &gt; existing.Magnitude:<span class="cov0" title="0">
                                // Replace if new effect is stronger
                                delete(em.activeEffects, existing.ID)
                                break</span>
                        default:<span class="cov0" title="0">
                                return fmt.Errorf("cannot apply weaker effect of same type")</span>
                        }
                }
        }

        // Add new effect
        <span class="cov8" title="1">effect.StartTime = time.Now()
        effect.IsActive = true
        em.activeEffects[effect.ID] = effect

        // Recalculate stats
        em.recalculateStats()

        return nil</span>
}

// EffectHolder interface implementation

// HasEffect checks if the entity has an active effect of the specified type
func (em *EffectManager) HasEffect(effectType EffectType) bool <span class="cov0" title="0">{
        em.mu.RLock()
        defer em.mu.RUnlock()

        for _, effect := range em.activeEffects </span><span class="cov0" title="0">{
                if effect.Type == effectType &amp;&amp; effect.IsActive </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// AddEffect applies an effect to the entity
func (em *EffectManager) AddEffect(effect *Effect) error <span class="cov0" title="0">{
        return em.ApplyEffect(effect)
}</span>

// GetEffects returns a slice of all active effects
func (em *EffectManager) GetEffects() []*Effect <span class="cov0" title="0">{
        em.mu.RLock()
        defer em.mu.RUnlock()

        effects := make([]*Effect, 0, len(em.activeEffects))
        for _, effect := range em.activeEffects </span><span class="cov0" title="0">{
                if effect.IsActive </span><span class="cov0" title="0">{
                        effects = append(effects, effect)
                }</span>
        }
        <span class="cov0" title="0">return effects</span>
}

// GetStats returns the current stats (with effects applied)
func (em *EffectManager) GetStats() *Stats <span class="cov0" title="0">{
        em.mu.RLock()
        defer em.mu.RUnlock()
        return em.currentStats.Clone()
}</span>

// SetStats updates the current stats
func (em *EffectManager) SetStats(stats *Stats) <span class="cov0" title="0">{
        em.mu.Lock()
        defer em.mu.Unlock()
        em.currentStats = stats.Clone()
}</span>

// GetBaseStats returns the base stats (without effects)
func (em *EffectManager) GetBaseStats() *Stats <span class="cov0" title="0">{
        em.mu.RLock()
        defer em.mu.RUnlock()
        return em.baseStats.Clone()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package game provides core RPG mechanics and systems for the GoldBox RPG Engine.
// This includes character management, effects, combat, spells, equipment, and world interactions.
package game

import (
        "sync"
        "time"
)

// Core types

// EffectType represents a type of effect that can be applied to a game entity
// in the RPG system. It is implemented as a string to allow for easy extensibility
// and readable effect definitions.
type EffectType string

// DamageType represents different types of damage that can be dealt in combat
type DamageType string

// DispelType represents different methods of dispelling effects
type DispelType string

// ImmunityType represents different types of immunity that characters can have
type ImmunityType int

// DispelPriority represents the priority level for effect dispelling
type DispelPriority int

// Constants
// EffectDamageOverTime represents an effect that deals damage to a target over a period of time.
// It is commonly used for effects like poison, burning, or bleeding that deal periodic damage.
// Effect constants are defined in constants.go
// Related effects: EffectPoison, EffectBurning, EffectBleeding
// Related damage types: DamagePhysical, DamageFire, DamagePoison

// Duration struct is defined in duration.go

// Effect represents a game effect
// Effect represents a game effect that can be applied to entities, modifying their stats or behavior over time.
// It contains all the information needed to track, apply and manage status effects in the game.
//
// Fields:
//   - ID: Unique identifier for the effect
//   - Type: Category/type of the effect (e.g. buff, debuff, dot)
//   - Name: Display name of the effect
//   - Description: Detailed description of what the effect does
//   - StartTime: When the effect was applied
//   - Duration: How long the effect lasts
//   - TickRate: How often the effect triggers/updates
//   - Magnitude: Strength/value of the effect
//   - DamageType: Type of damage if effect deals damage
//   - SourceID: ID of entity that applied the effect
//   - SourceType: Type of entity that applied the effect
//   - TargetID: ID of entity the effect is applied to
//   - StatAffected: Which stat the effect modifies
//   - IsActive: Whether effect is currently active
//   - Stacks: Number of times effect has stacked
//   - Tags: Labels for categorizing/filtering effects
//   - DispelInfo: Rules for removing/dispelling the effect
//   - Modifiers: List of stat/attribute modifications
//
// Related types:
//   - EffectType: Type definition for effect categories
//   - Duration: Custom time duration type
//   - DamageType: Enumeration of damage types
//   - DispelInfo: Rules for dispelling effects
//   - Modifier: Definition of stat modifications
type Effect struct {
        ID          string     `yaml:"effect_id"`
        Type        EffectType `yaml:"effect_type"`
        Name        string     `yaml:"effect_name"`
        Description string     `yaml:"effect_desc"`

        StartTime time.Time `yaml:"effect_start"`
        Duration  Duration  `yaml:"effect_duration"`
        TickRate  Duration  `yaml:"effect_tick_rate"`

        Magnitude  float64    `yaml:"effect_magnitude"`
        DamageType DamageType `yaml:"damage_type,omitempty"`

        SourceID   string `yaml:"effect_source"`
        SourceType string `yaml:"effect_source_type"`

        TargetID     string `yaml:"effect_target"`
        StatAffected string `yaml:"effect_stat_affected"`

        IsActive bool     `yaml:"effect_active"`
        Stacks   int      `yaml:"effect_stacks"`
        Tags     []string `yaml:"effect_tags"`

        DispelInfo DispelInfo `yaml:"dispel_info"`
        Modifiers  []Modifier `yaml:"effect_modifiers"`
}

// Modifier represents a modification to a game statistic or attribute.
// It defines how a specific stat should be modified through a mathematical operation.
//
// Fields:
//   - Stat: The name/identifier of the stat being modified
//   - Value: The numeric value to apply in the modification
//   - Operation: The type of mathematical operation to perform (e.g. add, multiply)
//
// Related types:
//   - ModOpType: Enum defining valid modification operations
//
// Usage example:
//
//        mod := Modifier{
//          Stat: "health",
//          Value: 10,
//          Operation: ModAdd,
//        }
// Modifier struct is defined in modifier.go

// ModOpType represents the type of modification operation that can be applied to game attributes.
// It is implemented as a string type to allow for extensible operation types while maintaining
// type safety through constant definitions.
type ModOpType string

// ModOpType constants define supported mathematical operations for modifying stats/attributes.
// These are used by the Modifier type to specify how a stat value should be changed.
//
// Supported operations:
// - ModAdd: Adds the modifier value to the base stat
// - ModMultiply: Multiplies the base stat by the modifier value
// - ModSet: Sets the stat directly to the modifier value, ignoring the base value
//
// Related types:
// - Modifier: Uses these operations to define stat modifications
// ModOpType constants are defined in constants.go
// - Effect: Contains Modifiers that use these operations

// DispelInfo contains metadata about how a game effect can be dispelled or removed.
//
// Fields:
//   - Priority: Determines the order in which effects are dispelled (higher priority = dispelled first)
//   - Types: List of dispel types that can remove this effect (e.g. magic, poison, curse)
//   - Removable: Whether the effect can be removed at all
//
// Related types:
//   - DispelPriority: Priority level constants (0-100)
//   - DispelType: Type of dispel (magic, curse, poison, etc)
//   - Effect: Contains DispelInfo as a field
//
// Example usage:
//
//        info := DispelInfo{
//            Priority: DispelPriorityNormal,
//            Types: []DispelType{DispelMagic},
//            Removable: true,
//        }
// DispelInfo struct is defined in dispel_info.go

// ImmunityData represents immunity effects that can be applied to game entities.
// It tracks the type, duration, resistance level and expiration time of immunities.
//
// Fields:
//   - Type: The type/category of immunity effect (ImmunityType)
//   - Duration: How long the immunity lasts (time.Duration)
//   - Resistance: A value between 0-1 representing immunity strength
//   - ExpiresAt: Timestamp when immunity effect ends
//
// Related types:
//   - ImmunityType: Enumeration of possible immunity types
//
// The immunity effect expires when current time exceeds ExpiresAt.
// Resistance of 1.0 means complete immunity, while 0.0 means no immunity.
type ImmunityData struct {
        Type       ImmunityType
        Duration   time.Duration
        Resistance float64
        ExpiresAt  time.Time
}

// EffectManager handles all temporary and permanent effects applied to an entity in the game.
// It manages active effects, base and current stats, immunities, resistances, and healing modifiers.
//
// The manager maintains thread-safe access to its data structures through a mutex.
//
// Fields:
//   - activeEffects: Maps effect IDs to Effect instances currently applied
//   - baseStats: Original unmodified stats of the entity
//   - currentStats: Current stats after applying all active effects
//   - immunities: Permanent immunity data mapped by effect type
//   - tempImmunities: Temporary immunity data mapped by effect type
//   - resistances: Damage/effect resistance multipliers (0-1) mapped by effect type
//   - healingModifier: Multiplier affecting all healing received (1.0 = normal healing)
//
// Related types:
//   - Effect: Represents a single effect instance
//   - Stats: Contains all modifiable entity statistics
//   - EffectType: Enumeration of possible effect types
//   - ImmunityData: Contains immunity duration and source information
type EffectManager struct {
        activeEffects   map[string]*Effect
        baseStats       *Stats
        currentStats    *Stats
        immunities      map[EffectType]*ImmunityData
        tempImmunities  map[EffectType]*ImmunityData
        resistances     map[EffectType]float64
        healingModifier float64
        mu              sync.RWMutex
}

// NewEffectManager creates and initializes a new EffectManager instance.
//
// Parameters:
//   - baseStats: A pointer to Stats representing the base statistics that will be modified by effects.
//     Must not be nil as it serves as the foundation for all stat calculations.
//
// Returns:
//   - *EffectManager: A new EffectManager instance with initialized maps for active effects,
//     immunities, temporary immunities, and resistances. The current stats are initialized
//     as a clone of the base stats.
//
// Related types:
//   - Stats: Base statistical values
//   - Effect: Individual effect instances
//   - EffectType: Types of effects that can be applied
//   - ImmunityData: Immunity information for effect types
//
// Note:
//   - Automatically initializes default immunities via initializeDefaultImmunities()
//   - All maps are initialized as empty but non-nil
func NewEffectManager(baseStats *Stats) *EffectManager <span class="cov8" title="1">{
        em := &amp;EffectManager{
                activeEffects:  make(map[string]*Effect),
                baseStats:      baseStats,
                currentStats:   baseStats.Clone(),
                immunities:     make(map[EffectType]*ImmunityData),
                tempImmunities: make(map[EffectType]*ImmunityData),
                resistances:    make(map[EffectType]float64),
        }
        em.initializeDefaultImmunities()
        return em
}</span>

// Effect creation helpers

// NewEffect creates a new Effect instance with the specified type, duration and magnitude.
//
// Parameters:
//   - effectType: The type of effect to create (EffectType)
//   - duration: How long the effect lasts (Duration struct with Rounds, Turns, RealTime)
//   - magnitude: The strength/amount of the effect (float64)
//
// Returns:
//   - *Effect: A pointer to the newly created Effect instance with default values
//
// The effect is initialized with:
//   - A new unique ID
//   - Active status
//   - 1 stack
//   - Default dispel info (lowest priority, not removable)
//   - Empty slices for tags and modifiers
//   - Current time as start time
//   - Empty strings for name, description and other string fields
//
// Related types:
//   - Effect struct
//   - EffectType type
//   - Duration struct
//   - DispelInfo struct
func NewEffect(effectType EffectType, duration Duration, magnitude float64) *Effect <span class="cov8" title="1">{
        return &amp;Effect{
                ID:          NewUID(),
                Type:        effectType,
                Name:        "",
                Description: "",
                StartTime:   time.Now(),
                Duration:    duration,
                TickRate: Duration{
                        Rounds:   0,
                        Turns:    0,
                        RealTime: 0,
                },
                Magnitude:    magnitude,
                DamageType:   "",
                SourceID:     "",
                SourceType:   "",
                TargetID:     "",
                StatAffected: "",
                IsActive:     true,
                Stacks:       1,
                Tags:         []string{},
                DispelInfo: DispelInfo{
                        Priority:  DispelPriorityLowest,
                        Types:     []DispelType{},
                        Removable: false,
                },
                Modifiers: []Modifier{},
        }
}</span>

// CreateDamageEffect creates a new damage-dealing Effect with the specified parameters.
//
// Parameters:
//   - effectType: The type of effect being created (e.g. poison, bleed, etc)
//   - damageType: The type of damage this effect deals (e.g. physical, magic, etc)
//   - damage: Amount of damage dealt per tick (must be &gt;= 0)
//   - duration: How long the effect lasts in real time
//
// Returns:
//
//        A new *Effect configured to deal periodic damage of the specified type
//
// The effect will tick once per second (defined in TickRate).
// Related types:
//   - Effect
//   - EffectType
//   - DamageType
//   - Duration
func CreateDamageEffect(effectType EffectType, damageType DamageType, damage float64, duration time.Duration) *Effect <span class="cov8" title="1">{
        effect := NewEffect(effectType, Duration{
                Rounds:   0,
                Turns:    0,
                RealTime: duration,
        }, damage)
        effect.DamageType = damageType
        effect.TickRate = Duration{
                Rounds:   0,
                Turns:    0,
                RealTime: time.Second,
        }
        return effect
}</span>

// IsExpired checks if the effect has expired based on either real time duration or number of rounds.
//
// Parameters:
//   - currentTime time.Time: The current time to check against the effect's start time
//
// Returns:
//   - bool: true if the effect has expired, false otherwise
//
// Notes:
// - For real-time based effects (Duration.RealTime &gt; 0), checks if currentTime is after startTime + duration
// - For round-based effects (Duration.Rounds &gt; 0), currently returns false (TODO: implementation needed)
// - If neither duration type is set, effect never expires (returns false)
//
// Related:
// - Duration struct containing RealTime and Rounds fields
// - Effect struct containing StartTime and Duration fields
func (e *Effect) IsExpired(currentTime time.Time) bool <span class="cov8" title="1">{
        if e.Duration.RealTime &gt; 0 </span><span class="cov8" title="1">{
                return currentTime.After(e.StartTime.Add(e.Duration.RealTime))
        }</span>
        <span class="cov8" title="1">if e.Duration.Rounds &gt; 0 </span><span class="cov8" title="1">{
                // Handle round-based expiration
                return false // TODO: Implement round-based expiration
        }</span>
        <span class="cov8" title="1">if e.Duration.Turns &gt; 0 </span><span class="cov0" title="0">{
                // Handle turn-based expiration
                return false // TODO: Implement turn-based expiration
        }</span>

        // Negative durations are permanent effects (never expire)
        <span class="cov8" title="1">if e.Duration.RealTime &lt; 0 || e.Duration.Rounds &lt; 0 || e.Duration.Turns &lt; 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Zero duration = instant effect (expires immediately)
        <span class="cov8" title="1">if e.Duration.RealTime == 0 &amp;&amp; e.Duration.Rounds == 0 &amp;&amp; e.Duration.Turns == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// ShouldTick determines if the effect should trigger based on its tick rate.
// It checks if enough real time has elapsed since the effect started for the next tick to occur.
//
// Parameters:
//   - currentTime time.Time: The current timestamp to check against
//
// Returns:
//   - bool: true if the effect should tick, false otherwise
//
// Edge cases:
//   - Returns false if TickRate.RealTime is 0 to prevent infinite ticking
//   - Uses modulo operation to determine regular intervals based on TickRate.RealTime
//
// Related:
//   - Effect.StartTime field
//   - Effect.TickRate struct
func (e *Effect) ShouldTick(currentTime time.Time) bool <span class="cov8" title="1">{
        if e.TickRate.RealTime == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">timeSinceStart := currentTime.Sub(e.StartTime)
        return timeSinceStart%e.TickRate.RealTime == 0</span>
}

// EffectTyper is an interface that defines a contract for types that have an associated effect type.
// It provides a common way to identify and categorize different types of effects in the game.
//
// Returns:
//   - EffectType: The type classification of the effect
//
// EffectTyper interface is defined in types.go
// Related types:
//   - EffectType: The enumeration of possible effect types

// GetEffectType returns the type of the Effect.
//
// Returns:
//   - EffectType: The type classification of this effect.
//
// Related types:
//   - EffectType: An enumeration defining different effect categories
//   - Effect: The parent struct containing effect data
func (e *Effect) GetEffectType() EffectType <span class="cov8" title="1">{
        return e.Type
}</span>

// GetEffectType returns the type of this DamageEffect
//
// Returns:
//   - EffectType: The type of effect this DamageEffect represents
//
// Related:
//   - EffectType interface
//   - Effect.Type field
func (de *DamageEffect) GetEffectType() EffectType <span class="cov8" title="1">{
        return de.Effect.Type
}</span>

// ToEffect converts a DamageEffect to an Effect by returning the underlying Effect field.
// This method allows DamageEffect to be used as an Effect type.
//
// Returns:
//   - *Effect: The underlying Effect pointer contained in the DamageEffect struct
//
// Related Types:
//   - Effect
//   - DamageEffect
func (de *DamageEffect) ToEffect() *Effect <span class="cov8" title="1">{
        return de.Effect
}</span>

// ToDamageEffect attempts to convert a generic Effect to a DamageEffect.
//
// Parameters:
//   - e *Effect: The effect to convert. Must not be nil.
//
// Returns:
//   - *DamageEffect: The converted damage effect if successful, nil otherwise
//   - bool: true if conversion was successful, false if effect type is not convertible
//
// The function only converts poison, burning and bleeding effect types.
// All other effect types will return nil and false.
//
// Related types:
//   - Effect
//   - DamageEffect
//   - EffectType (EffectPoison, EffectBurning, EffectBleeding)
func ToDamageEffect(e *Effect) (*DamageEffect, bool) <span class="cov8" title="1">{
        switch e.Type </span>{
        case EffectPoison, EffectBurning, EffectBleeding:<span class="cov8" title="1">
                return &amp;DamageEffect{
                        Effect:         e,
                        DamageType:     e.DamageType,
                        BaseDamage:     e.Magnitude,
                        DamageScale:    0,
                        PenetrationPct: 0,
                }, true</span>
        default:<span class="cov8" title="1">
                return nil, false</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package game

// EquipmentSlot represents the different slots where equipment/items can be equipped on a character.
// This type is used as an enum to identify valid equipment positions (e.g. weapon slot, armor slot, etc).
type EquipmentSlot int

// EquipmentSlot constants are defined in constants.go

// String returns a human-readable string representation of an EquipmentSlot.
// This method maps the numeric equipment slot enum value to its corresponding
// string name from a fixed array of slot names.
//
// Returns:
//   - string: The name of the equipment slot (one of: Head, Neck, Chest, Hands,
//     Rings, Legs, Feet, MainHand, OffHand), or "Unknown" for invalid values
//
// This method handles invalid enum values gracefully by returning "Unknown"
// instead of panicking.
func (es EquipmentSlot) String() string <span class="cov8" title="1">{
        slotNames := [...]string{
                "Head",
                "Neck",
                "Chest",
                "Hands",
                "Rings",
                "Legs",
                "Feet",
                "MainHand",
                "OffHand",
        }

        if int(es) &gt;= 0 &amp;&amp; int(es) &lt; len(slotNames) </span><span class="cov8" title="1">{
                return slotNames[es]
        }</span>
        <span class="cov8" title="1">return "Unknown"</span>
}

// EquipmentSlotConfig defines the configuration for an equipment slot in the game.
// It specifies what types of items can be equipped and any special requirements.
//
// Fields:
//   - Slot: The type of equipment slot (e.g. weapon, armor, etc)
//   - Name: Human readable display name for the equipment slot
//   - Description: Detailed description of what items can be equipped in this slot
//   - AllowedTypes: List of item type IDs that can be equipped in this slot
//   - Restricted: If true, additional requirements must be met to use this slot
//
// Related types:
//   - EquipmentSlot (enum type for slot categories)
//   - Item (for equippable items)
type EquipmentSlotConfig struct {
        Slot         EquipmentSlot `yaml:"slot_type"`        // Type of equipment slot
        Name         string        `yaml:"slot_name"`        // Display name for the slot
        Description  string        `yaml:"slot_description"` // Description of what can be equipped
        AllowedTypes []string      `yaml:"allowed_types"`    // Types of items that can be equipped
        Restricted   bool          `yaml:"slot_restricted"`  // Whether slot has special requirements
}

// EquipmentSet represents a character's complete set of equipped items across different slots.
// This struct maintains the relationship between a character and their equipped items.
//
// Fields:
//   - CharacterID: Unique identifier string for the character who owns this equipment set
//   - Slots: Map containing the configuration for each equipment slot, keyed by EquipmentSlot type
//
// The Slots map allows for flexible equipment configurations while enforcing slot-specific
// validation rules defined in EquipmentSlotConfig.
//
// Related types:
//   - EquipmentSlot: Enum defining valid equipment slot types
//   - EquipmentSlotConfig: Configuration for individual equipment slots
type EquipmentSet struct {
        CharacterID string                                `yaml:"character_id"`    // ID of character owning the equipment
        Slots       map[EquipmentSlot]EquipmentSlotConfig `yaml:"equipment_slots"` // Map of all equipment slots
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package game

import (
        "sync"
)

// EventType represents different types of game events
// EventType represents the type of an event in the game.
// It is implemented as an integer enum to allow for efficient comparison and switching.
// The specific event type values should be defined as constants using this type.
//
// Related types:
//   - Event interface (if exists)
//   - Any concrete event types that use this enum
type EventType int

// EventLevelUp represents a character gaining a level.
// This event is triggered when a character accumulates enough experience points
// to advance to the next level. The event carries information about:
// - The character that leveled up
// - The new level achieved
// - Any stat increases or new abilities gained
//
// Related events:
// EventType constants are defined in constants.go
// - EventDamage: May contribute to experience gain
// - EventQuestUpdate: Quests may require reaching certain levels

// GameEvent represents an occurrence or action within the game system that needs to be tracked or handled.
// It contains information about what happened, who/what was involved, and when it occurred.
//
// Fields:
//   - Type: The category/classification of the event (EventType)
//   - SourceID: Unique identifier for the entity that triggered/caused the event
//   - TargetID: Unique identifier for the entity that the event affects/targets
//   - Data: Additional contextual information about the event as key-value pairs
//   - Timestamp: Unix timestamp (in seconds) when the event occurred
//
// The GameEvent struct is used throughout the event system to standardize how
// game occurrences are represented and processed. Events can represent things like
// combat actions, item usage, movement, etc.
//
// Related types:
//   - EventType: Enumeration of possible event categories
type GameEvent struct {
        Type      EventType              `yaml:"event_type"`      // Type of the event
        SourceID  string                 `yaml:"source_id"`       // ID of the event originator
        TargetID  string                 `yaml:"target_id"`       // ID of the event target
        Data      map[string]interface{} `yaml:"event_data"`      // Additional event data
        Timestamp int64                  `yaml:"event_timestamp"` // When the event occurred
}

// EventHandler is a function type that handles game events in the game system.
// It takes a GameEvent parameter and processes it according to the specific event handling logic.
//
// Parameters:
//   - event GameEvent: The game event to be handled
//
// Note: EventHandler functions are typically used as callbacks registered to handle
// specific types of game events in an event-driven architecture.
//
// Related types:
//   - GameEvent (defined elsewhere in the codebase)
type EventHandler func(event GameEvent)

// EventSystem manages event handling and dispatching in the game.
// It provides a thread-safe way to register handlers for different event types
// and dispatch events to all registered handlers.
//
// Fields:
//   - mu: sync.RWMutex for ensuring thread-safe access to handlers
//   - handlers: Map storing event handlers organized by EventType
//
// Thread Safety:
// All methods on EventSystem are thread-safe and can be called concurrently
// from multiple goroutines.
//
// Related Types:
//   - EventType: Type definition for different kinds of game events
//   - EventHandler: Interface for handling dispatched events
type EventSystem struct {
        mu       sync.RWMutex                 `yaml:"mutex,omitempty"`          // Mutex for thread safety
        handlers map[EventType][]EventHandler `yaml:"event_handlers,omitempty"` // Map of event handlers
}

// EventSystemConfig defines the configuration settings for the event handling system.
// It manages event type registration, handler tracking, and processing behavior.
//
// Fields:
//   - RegisteredTypes: Slice of EventType that are registered in the system.
//   - HandlerCount: Map tracking number of handlers registered for each EventType.
//     A count of 0 indicates no handlers are registered for that type.
//   - AsyncHandling: Boolean flag determining if events are processed asynchronously.
//     When true, events are handled in separate goroutines.
//     When false, events are handled synchronously in the calling goroutine.
//
// The config should be initialized before registering any event handlers.
// AsyncHandling should be used with caution as it may affect event ordering.
//
// Related:
//   - EventType: Type definition for supported event types
//   - EventHandler: Interface for event handler implementations
type EventSystemConfig struct {
        RegisteredTypes []EventType       `yaml:"registered_event_types"` // List of registered event types
        HandlerCount    map[EventType]int `yaml:"handler_counts"`         // Number of handlers per type
        AsyncHandling   bool              `yaml:"async_handling"`         // Whether events are handled asynchronously
}

// defaultEventSystem is the global default event system instance used for managing game events.
// It is initialized using NewEventSystem() and serves as a centralized event bus for the game.
// This singleton instance allows components throughout the game to subscribe to and publish events
// without having to pass around an event system reference.
//
// Related types:
// - EventSystem: The underlying event management system type
// - Event: Base interface for all game events
//
// Usage:
// To publish events: defaultEventSystem.Publish(event)
// To subscribe: defaultEventSystem.Subscribe(eventType, handler)
var defaultEventSystem = NewEventSystem()

// NewEventSystem creates and initializes a new event system.
// It initializes an empty map of event handlers that can be registered
// to handle different event types.
//
// Returns:
//   - *EventSystem: A pointer to the newly created event system with an initialized
//     empty handlers map.
//
// Related types:
// - EventType: The type used to identify different kinds of events
// - EventHandler: Function type for handling specific events
func NewEventSystem() *EventSystem <span class="cov8" title="1">{
        return &amp;EventSystem{
                handlers: make(map[EventType][]EventHandler),
        }
}</span>

// Subscribe registers a new event handler for a specific event type.
// The handler will be called when events of the specified type are published.
//
// Parameters:
//   - eventType: The type of event to subscribe to
//   - handler: The event handler function to be called when events occur
//
// Thread safety: This method is thread-safe as it uses mutex locking.
//
// Related:
//   - EventType
//   - EventHandler
//   - EventSystem.Publish
func (es *EventSystem) Subscribe(eventType EventType, handler EventHandler) <span class="cov8" title="1">{
        es.mu.Lock()
        defer es.mu.Unlock()

        es.handlers[eventType] = append(es.handlers[eventType], handler)
}</span>

// Emit asynchronously distributes a game event to all registered handlers for that event type.
// It safely accesses the handlers map using a read lock to prevent concurrent map access issues.
//
// Parameters:
//   - event GameEvent: The game event to be processed. Must contain a valid Type field that
//     matches registered handler types.
//
// Thread-safety:
//   - Uses RWMutex to safely access handlers map
//   - Handlers are executed concurrently in separate goroutines
//
// Related types:
//   - GameEvent interface
//   - EventHandler func type
//   - EventType enum
func (es *EventSystem) Emit(event GameEvent) <span class="cov8" title="1">{
        es.mu.RLock()
        handlers := es.handlers[event.Type]
        es.mu.RUnlock()

        for _, handler := range handlers </span><span class="cov8" title="1">{
                go handler(event) // Async event handling
        }</span>
}

// emitLevelUpEvent sends a level up event to the default event system when a player levels up.
// It creates a GameEvent with the level up information and emits it.
//
// Parameters:
//   - playerID: string - Unique identifier for the player who leveled up
//   - oldLevel: int - The player's level before leveling up
//   - newLevel: int - The player's new level after leveling up
//
// Related:
//   - GameEvent struct
//   - defaultEventSystem
//   - EventLevelUp const
//   - getCurrentGameTick()
func emitLevelUpEvent(playerID string, oldLevel, newLevel int) <span class="cov8" title="1">{
        event := GameEvent{
                Type:     EventLevelUp,
                SourceID: playerID,
                Data: map[string]interface{}{
                        "oldLevel": oldLevel,
                        "newLevel": newLevel,
                },
                Timestamp: getCurrentGameTick(),
        }

        defaultEventSystem.Emit(event)
}</span>

// getCurrentGameTick returns the current game tick count as an int64.
// This represents the number of game update cycles that have occurred.
//
// The actual implementation depends on the game loop timing system.
// Currently returns a placeholder value of 0.
//
// Returns:
//   - int64: The current game tick count
//
// Related:
//   - Game loop implementation (TBD)
//   - Time management system (TBD)
func getCurrentGameTick() int64 <span class="cov8" title="1">{
        // Implementation depends on your game loop timing system
        // This is a placeholder
        return 0
}</span>

// init initializes the default event system by registering event handlers.
// It sets up a handler for the EventLevelUp event that logs when a player levels up.
//
// The handler processes the following event data:
// - "oldLevel" (int): The player's previous level
// - "newLevel" (int): The player's new level
// - SourceID (string): The player's ID/name
//
// This function is called automatically when the package is imported.
//
// Related:
// - GameEvent type
// - defaultEventSystem EventSystem
// - EventLevelUp constant
func init() <span class="cov8" title="1">{
        // Register default event handlers
        defaultEventSystem.Subscribe(EventLevelUp, func(event GameEvent) </span><span class="cov8" title="1">{
                // Log level up
                oldLevel := event.Data["oldLevel"].(int)
                newLevel := event.Data["newLevel"].(int)
                logger.Printf("Player %s leveled up from %d to %d",
                        event.SourceID, oldLevel, newLevel)
        }</span>)
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package game

import (
        "encoding/json"
        "fmt"
)

// Item represents a game item with its properties
// Contains all attributes that define an item's behavior and characteristics
// Item represents a game item with various attributes and properties.
// It is used to define objects that players can interact with in the game world.
//
// Fields:
//   - ID (string): Unique identifier used to reference the item in the game
//   - Name (string): Human-readable display name of the item
//   - Type (string): Category classification (e.g. "weapon", "armor", "potion")
//   - Damage (string): Optional damage specification for weapons (e.g. "1d6")
//   - AC (int): Optional armor class value for defensive equipment
//   - Weight (int): Weight of the item in game units
//   - Value (int): Worth of the item in game currency
//   - Properties ([]string): Optional list of special effects or attributes
//   - Position (Position): Optional current location in the game world
//
// The Item struct is serializable to/from YAML format using the specified tags.
// Related types:
//   - Position: Represents location coordinates in the game world
type Item struct {
        ID         string   `yaml:"item_id"`                    // Unique identifier for the item
        Name       string   `yaml:"item_name"`                  // Display name of the item
        Type       string   `yaml:"item_type"`                  // Category of item (weapon, armor, etc.)
        Damage     string   `yaml:"item_damage,omitempty"`      // Damage specification for weapons
        AC         int      `yaml:"item_armor_class,omitempty"` // Armor class for defensive items
        Weight     int      `yaml:"item_weight"`                // Weight in game units
        Value      int      `yaml:"item_value"`                 // Monetary value in game currency
        Properties []string `yaml:"item_properties,omitempty"`  // Special properties or effects
        Position   Position `yaml:"item_position,omitempty"`    // Current location in game world
}

// FromJSON implements GameObject.
// FromJSON deserializes JSON data into an Item struct.
//
// Parameters:
//   - data []byte: Raw JSON bytes to deserialize
//
// Returns:
//   - error: Returns an error if JSON unmarshaling fails
//
// Related:
//   - Item.ToJSON() for the inverse serialization operation
func (i *Item) FromJSON(data []byte) error <span class="cov8" title="1">{
        return json.Unmarshal(data, i)
}</span>

// GetDescription implements GameObject.
// GetDescription returns a formatted string representation of the item
// combining its Name and Type properties.
//
// Returns a string in the format "Name (Type)"
//
// Related types:
// - Item struct
func (i *Item) GetDescription() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s (%s)", i.Name, i.Type)
}</span>

// GetHealth implements GameObject.
// GetHealth returns the health value of an Item.
// Since items don't inherently have health in this implementation, it always returns 0.
// This method satisfies an interface but has no practical effect for basic Item objects.
// Returns:
//   - int: Always returns 0 for base items
//
// Related types:
//   - Item struct
func (i *Item) GetHealth() int <span class="cov8" title="1">{
        return 0 // Items don't have health
}</span>

// GetID implements GameObject.
// GetID returns the unique identifier string for this Item.
// This method provides access to the private ID field.
// Returns a string representing the item's unique identifier.
// Related: Item struct
func (i *Item) GetID() string <span class="cov8" title="1">{
        return i.ID
}</span>

// GetName implements GameObject.
// GetName returns the name of the item
//
// Returns:
//   - string: The name property of the Item struct
func (i *Item) GetName() string <span class="cov8" title="1">{
        return i.Name
}</span>

// GetPosition implements GameObject.
// GetPosition returns the current position of this item in the game world.
// If the item's position has not been explicitly set, returns an empty Position struct.
// Returns:
//   - Position: The x,y coordinates of the item
//
// Related types:
//   - Position struct
func (i *Item) GetPosition() Position <span class="cov8" title="1">{
        return Position{} // Default position if not set
}</span>

// GetTags implements GameObject.
// GetTags returns the Properties field of an Item, which contains string tags/attributes
// associated with this item. The returned slice can be empty if no properties are set.
//
// Returns:
//   - []string: A slice of strings representing the item's properties/tags
//
// Related:
//   - Item struct
//   - Properties field
func (i *Item) GetTags() []string <span class="cov8" title="1">{
        return i.Properties
}</span>

// IsActive implements GameObject.
// IsActive returns true to indicate if the item is currently active in the game
// This method is used to indicate that items are always usable / active by default
//
// Returns:
//   - bool: Always returns true as items are considered active by default
func (i *Item) IsActive() bool <span class="cov8" title="1">{
        return true // Items are always active
}</span>

// IsObstacle implements GameObject.
// IsObstacle checks if this item blocks movement in the game world.
// This is used by the movement system to determine if a character can pass through the item.
// Returns false as items by default do not obstruct movement.
// Related: Entity.IsObstacle(), Character.CanMoveTo()
func (i *Item) IsObstacle() bool <span class="cov8" title="1">{
        return false // Items are not obstacles
}</span>

// SetHealth implements GameObject.
// SetHealth is a placeholder method that takes a health value but performs no operation,
// as items in this game do not have health attributes.
//
// Parameters:
//   - health: integer value representing health points (not used)
//
// This is a no-op method maintained for compatibility with interfaces or future use.
func (i *Item) SetHealth(health int) {<span class="cov8" title="1">
        // Items don't have health, no-op
}</span>

// SetPosition implements GameObject.
// SetPosition is a stub method that satisfies the Entity interface but does not track position for Items.
// Currently items don't maintain position state - this may change in future implementations.
//
// Parameters:
//   - pos: Position - The position to set (unused)
//
// Returns:
//   - error - Always returns nil since position is not tracked
//
// Related types:
//   - Position struct
//   - Entity interface
func (i *Item) SetPosition(pos Position) error <span class="cov8" title="1">{
        return nil // Items don't track position
}</span>

// ToJSON implements GameObject.
// ToJSON serializes the Item struct into a JSON byte array.
//
// Returns:
//   - []byte: The JSON representation of the Item
//   - error: Error if marshaling fails
//
// This method uses the standard encoding/json package for marshaling.
// Related types: Item struct
func (i *Item) ToJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(i)
}</span>

// ItemType constants are defined in constants.go
// ItemTypeWeapon represents a weapon item type constant used for categorizing items
// in the game inventory and equipment system. This type is used when creating or
// identifying weapon items.
</pre>
		
		<pre class="file" id="file16" style="display: none">package game

import (
        "log"
        "os"
)

// logger is the global game logger instance that writes log messages to standard output.
// It prefixes all messages with "[GAME]" and includes standard logging flags (date and time).
// The logger is configured to write to os.Stdout and uses the standard Go log package.
// Related: pkg/game package logging functions
var logger = log.New(os.Stdout, "[GAME] ", log.LstdFlags)

// SetLogger allows changing the default logger
// SetLogger sets the package-level logger instance used for logging throughout the game.
// It allows injection of a custom logger for different logging implementations.
//
// Parameters:
//   - l: pointer to a log.Logger instance to be used for logging. Must not be nil.
//
// Related:
//   - logger (package-level variable)
func SetLogger(l *log.Logger) <span class="cov8" title="1">{
        logger = l
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package game

import "encoding/json"

// MapTile represents a single tile in the game map with visual and gameplay properties
type MapTile struct {
        SpriteX     int  `json:"spriteX"`
        SpriteY     int  `json:"spriteY"`
        Walkable    bool `json:"walkable"`
        Transparent bool `json:"transparent"`
}

// GameMap represents a game map containing a grid of tiles
type GameMap struct {
        Width  int         `json:"width"`
        Height int         `json:"height"`
        Tiles  [][]MapTile `json:"tiles"`
}

// GetTile returns the tile at the specified coordinates, or nil if out of bounds
func (m *GameMap) GetTile(x, y int) *MapTile <span class="cov8" title="1">{
        if x &lt; 0 || y &lt; 0 || x &gt;= m.Width || y &gt;= m.Height </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;m.Tiles[y][x]</span>
}

// MarshalJSON provides custom JSON marshaling for GameMap.
func (m *GameMap) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        type Alias GameMap
        return json.Marshal(&amp;struct {
                *Alias
                GetTile string `json:"getTile"`
        }{
                Alias:   (*Alias)(m),
                GetTile: "function(x,y) { return this.tiles[y][x]; }",
        })
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package game

// Modifier represents a stat modification that can be applied to game entities.
// It defines how a specific attribute should be modified, including the target stat,
// the value to apply, and the mathematical operation to perform.
//
// Fields:
//   - Stat: String identifier of the stat to modify (e.g. "strength", "health")
//   - Value: Numeric value to apply in the modification
//   - Operation: Type of mathematical operation (add, multiply, set)
//
// Related types:
//   - ModOpType: Enumeration of supported modification operations
//   - Effect: Contains a list of Modifier objects
//
// Example usage:
//
//        mod := Modifier{
//            Stat:      "strength",
//            Value:     5,
//            Operation: ModAdd,
//        }
//
// Moved from: effects.go
type Modifier struct {
        Stat      string    `yaml:"mod_stat"`
        Value     float64   `yaml:"mod_value"`
        Operation ModOpType `yaml:"mod_operation"`
}

// NewModifier creates a new Modifier with the specified parameters.
// Moved from: effects.go
func NewModifier(stat string, value float64, operation ModOpType) *Modifier <span class="cov8" title="1">{
        return &amp;Modifier{
                Stat:      stat,
                Value:     value,
                Operation: operation,
        }
}</span>

// Apply applies the modifier to a given base value and returns the result.
// The operation type determines how the modification is performed.
// Moved from: effects.go
func (m *Modifier) Apply(baseValue float64) float64 <span class="cov8" title="1">{
        switch m.Operation </span>{
        case ModAdd:<span class="cov8" title="1">
                return baseValue + m.Value</span>
        case ModMultiply:<span class="cov8" title="1">
                return baseValue * m.Value</span>
        case ModSet:<span class="cov8" title="1">
                return m.Value</span>
        default:<span class="cov8" title="1">
                return baseValue</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package game

import (
        "fmt"
)

// Player extends Character with player-specific functionality
// Contains all attributes and mechanics specific to player characters
// Player represents a playable character in the game with additional attributes beyond
// the base Character type. It tracks progression elements like level, experience,
// quests and learned spells.
//
// The Player struct embeds the Character type to inherit basic attributes while adding
// RPG-specific fields for character advancement and gameplay mechanics.
//
// Fields:
//   - Character: Base character attributes (embedded)
//   - Class: The character's chosen class that determines available abilities
//   - Level: Current experience level of the player (1 or greater)
//   - Experience: Total experience points accumulated
//   - QuestLog: Slice of active and completed quests
//   - KnownSpells: Slice of spells the player has learned and can cast
//
// Related types:
//   - Character: Base character attributes
//   - CharacterClass: Available character classes
//   - Quest: Quest structure
//   - Spell: Spell structure
type Player struct {
        Character   `yaml:",inline"` // Base character attributes (includes Class)
        Level       int              `yaml:"player_level"`      // Current experience level
        Experience  int64            `yaml:"player_experience"` // Total experience points (int64 to prevent overflow)
        QuestLog    []Quest          `yaml:"player_quests"`     // Active and completed quests
        KnownSpells []Spell          `yaml:"player_spells"`     // Learned/available spells
}

// GetHP returns the player's current hit points.
// This method is thread-safe.
//
// Returns:
//   - int: The player's current HP
func (p *Player) GetHP() int <span class="cov0" title="0">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.HP
}</span>

// SetHP sets the player's current hit points.
// This method is thread-safe and ensures HP doesn't exceed MaxHP or go below 0.
//
// Parameters:
//   - hp: The new HP value to set
func (p *Player) SetHP(hp int) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if hp &lt; 0 </span><span class="cov0" title="0">{
                p.HP = 0
        }</span> else<span class="cov0" title="0"> if hp &gt; p.MaxHP </span><span class="cov0" title="0">{
                p.HP = p.MaxHP
        }</span> else<span class="cov0" title="0"> {
                p.HP = hp
        }</span>
}

// GetMaxHP returns the player's maximum hit points.
// This method is thread-safe.
//
// Returns:
//   - int: The player's maximum HP
func (p *Player) GetMaxHP() int <span class="cov0" title="0">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return p.MaxHP
}</span>

// Update updates the player's data based on the provided map of attributes.
// It safely updates both Player-specific and underlying Character fields while maintaining data consistency.
//
// Parameters:
//   - playerData: Map containing field names and their new values
//
// Character fields that can be updated:
//   - "name": string (Character name)
//   - "description": string (Character description)
//   - "class": CharacterClass (Character class)
//   - "position_x": int (X coordinate)
//   - "position_y": int (Y coordinate)
//   - "position_level": int (Dungeon/map level)
//   - "position_facing": Direction (Facing direction)
//   - "strength": int (Strength attribute)
//   - "constitution": int (Constitution attribute)
//   - "dexterity": int (Dexterity attribute)
//   - "intelligence": int (Intelligence attribute)
//   - "wisdom": int (Wisdom attribute)
//   - "charisma": int (Charisma attribute)
//   - "hp": int (Current hit points)
//   - "max_hp": int (Maximum hit points)
//   - "armor_class": int (Armor class rating)
//   - "thac0": int (To Hit Armor Class 0)
//   - "gold": int (Currency amount)
//
// Player-specific fields that can be updated:
//   - "level": int (Player level)
//   - "experience": int (Experience points)
func (p *Player) Update(playerData map[string]interface{}) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        p.updateCharacterFields(playerData)
        p.updatePositionComponents(playerData)
        p.updateAttributes(playerData)
        p.updateCombatStats(playerData)
        p.updateEconomicData(playerData)
        p.updatePlayerSpecificFields(playerData)
}</span>

// updateCharacterFields updates basic character identification and classification data.
func (p *Player) updateCharacterFields(playerData map[string]interface{}) <span class="cov8" title="1">{
        if name, ok := playerData["name"].(string); ok </span><span class="cov8" title="1">{
                p.Character.Name = name
        }</span>
        <span class="cov8" title="1">if description, ok := playerData["description"].(string); ok </span><span class="cov8" title="1">{
                p.Character.Description = description
        }</span>
        <span class="cov8" title="1">if class, ok := playerData["class"].(CharacterClass); ok </span><span class="cov8" title="1">{
                p.Character.Class = class
        }</span>
}

// updatePositionComponents updates individual position components including coordinates and facing direction.
func (p *Player) updatePositionComponents(playerData map[string]interface{}) <span class="cov8" title="1">{
        if x, ok := playerData["position_x"].(int); ok </span><span class="cov8" title="1">{
                p.Character.Position.X = x
        }</span>
        <span class="cov8" title="1">if y, ok := playerData["position_y"].(int); ok </span><span class="cov8" title="1">{
                p.Character.Position.Y = y
        }</span>
        <span class="cov8" title="1">if level, ok := playerData["position_level"].(int); ok </span><span class="cov8" title="1">{
                p.Character.Position.Level = level
        }</span>
        <span class="cov8" title="1">if facing, ok := playerData["position_facing"].(Direction); ok </span><span class="cov8" title="1">{
                p.Character.Position.Facing = facing
        }</span>
}

// updateAttributes updates the six core character attributes (strength, dexterity, constitution, intelligence, wisdom, charisma).
func (p *Player) updateAttributes(playerData map[string]interface{}) <span class="cov8" title="1">{
        if str, ok := playerData["strength"].(int); ok </span><span class="cov8" title="1">{
                p.Strength = str
        }</span>
        <span class="cov8" title="1">if con, ok := playerData["constitution"].(int); ok </span><span class="cov8" title="1">{
                p.Constitution = con
        }</span>
        <span class="cov8" title="1">if dex, ok := playerData["dexterity"].(int); ok </span><span class="cov8" title="1">{
                p.Dexterity = dex
        }</span>
        <span class="cov8" title="1">if intel, ok := playerData["intelligence"].(int); ok </span><span class="cov8" title="1">{
                p.Intelligence = intel
        }</span>
        <span class="cov8" title="1">if wisdom, ok := playerData["wisdom"].(int); ok </span><span class="cov8" title="1">{
                p.Character.Wisdom = wisdom
        }</span>
        <span class="cov8" title="1">if charisma, ok := playerData["charisma"].(int); ok </span><span class="cov8" title="1">{
                p.Character.Charisma = charisma
        }</span>
}

// updateCombatStats updates combat-related statistics including health points, armor class, and THAC0.
func (p *Player) updateCombatStats(playerData map[string]interface{}) <span class="cov8" title="1">{
        if hp, ok := playerData["hp"].(int); ok </span><span class="cov8" title="1">{
                p.HP = hp
        }</span>
        <span class="cov8" title="1">if maxHP, ok := playerData["max_hp"].(int); ok </span><span class="cov8" title="1">{
                p.MaxHP = maxHP
        }</span>
        <span class="cov8" title="1">if ac, ok := playerData["armor_class"].(int); ok </span><span class="cov8" title="1">{
                p.Character.ArmorClass = ac
        }</span>
        <span class="cov8" title="1">if thac0, ok := playerData["thac0"].(int); ok </span><span class="cov8" title="1">{
                p.Character.THAC0 = thac0
        }</span>
}

// updateEconomicData updates the character's gold and other economic resources.
func (p *Player) updateEconomicData(playerData map[string]interface{}) <span class="cov8" title="1">{
        if gold, ok := playerData["gold"].(int); ok </span><span class="cov8" title="1">{
                p.Character.Gold = gold
        }</span>
}

// updatePlayerSpecificFields updates player-specific data including level and experience with type compatibility handling.
func (p *Player) updatePlayerSpecificFields(playerData map[string]interface{}) <span class="cov8" title="1">{
        if level, ok := playerData["level"].(int); ok </span><span class="cov8" title="1">{
                p.Level = level
        }</span>
        <span class="cov8" title="1">if exp, ok := playerData["experience"].(int64); ok </span><span class="cov0" title="0">{
                p.Experience = exp
        }</span> else<span class="cov8" title="1"> if exp, ok := playerData["experience"].(int); ok </span><span class="cov8" title="1">{
                // Handle backwards compatibility with int values
                p.Experience = int64(exp)
        }</span>
}

// Clone creates and returns a deep copy of the Player.
// This is useful for creating separate instances of a player for different sessions
// while preserving the original player data.
//
// Returns:
//   - *Player: A pointer to a new Player instance with copied data
func (p *Player) Clone() *Player <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">clone := &amp;Player{
                Level:      p.Level,
                Experience: p.Experience,
        }

        // Clone base Character data
        clone.Character = *p.Character.Clone()

        // Deep copy QuestLog
        clone.QuestLog = make([]Quest, len(p.QuestLog))
        copy(clone.QuestLog, p.QuestLog)

        // Deep copy KnownSpells
        clone.KnownSpells = make([]Spell, len(p.KnownSpells))
        copy(clone.KnownSpells, p.KnownSpells)

        return clone</span>
}

// PublicData returns a struct containing non-sensitive player information that can be
// shared with other players or game systems. This includes basic character info
// and visible stats while excluding progression and private data.
//
// Returns:
//   - map[string]interface{}: A map containing the player's basic shareable info
func (p *Player) PublicData() map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "name":         p.Name,
                "class":        p.Character.Class,
                "hp":           p.HP,
                "max_hp":       p.MaxHP,
                "strength":     p.Strength,
                "constitution": p.Constitution,
        }
}</span>

// PlayerProgressData represents the current progress and achievements of a player in the game.
// It keeps track of various metrics like level, experience points, and accomplishments.
//
// Fields:
//   - CurrentLevel: The player's current level in the game (must be &gt;= 1)
//   - ExperiencePoints: Total accumulated experience points
//   - NextLevelThreshold: Experience points required to advance to next level
//   - CompletedQuests: Number of quests the player has finished
//   - SpellsLearned: Number of spells the player has mastered
//
// Related types:
//   - Use with Player struct to track overall player state
//   - Experience points calculation handled by LevelingSystem
type PlayerProgressData struct {
        CurrentLevel       int `yaml:"progress_level"`          // Current level
        ExperiencePoints   int `yaml:"progress_exp"`            // Total XP
        NextLevelThreshold int `yaml:"progress_next_level_exp"` // XP needed for next level
        CompletedQuests    int `yaml:"progress_quests_done"`    // Number of completed quests
        SpellsLearned      int `yaml:"progress_spells_known"`   // Number of known spells
}

// AddExperience safely adds experience points and handles level ups
// AddExperience adds the specified amount of experience points to the player and handles leveling up.
// It is thread-safe through mutex locking.
//
// Parameters:
//   - exp: Amount of experience points to add (must be non-negative)
//
// Returns:
//   - error: Returns nil on success, error if exp is negative or if levelUp fails
//
// Errors:
//   - Returns error if exp is negative
//   - Returns error from levelUp if leveling up fails
//
// Related:
//   - calculateLevel(): Used to determine if player should level up
//   - levelUp(): Called when experience gain triggers a level increase
func (p *Player) AddExperience(exp int64) error <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if exp &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot add negative experience: %d", exp)
        }</span>

        // Check for integer overflow before adding experience
        <span class="cov8" title="1">if p.Experience &gt; 0 &amp;&amp; exp &gt; 0 &amp;&amp; p.Experience &gt; (1&lt;&lt;63-1)-exp </span><span class="cov8" title="1">{
                return fmt.Errorf("experience addition would cause overflow: current=%d, adding=%d", p.Experience, exp)
        }</span>

        <span class="cov8" title="1">p.Experience += exp

        // Check for level up
        if newLevel := calculateLevel(p.Experience); newLevel &gt; p.Level </span><span class="cov8" title="1">{
                return p.levelUp(newLevel)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// levelUp increases the player's level to the specified new level and applies corresponding stat increases.
// It updates the player's maximum and current HP based on their class and constitution,
// and emits a level up event to notify the game system.
//
// Parameters:
//   - newLevel: The target level to advance the player to (must be greater than current level)
//
// Returns:
//   - error: Returns nil if successful, or an error if the level up could not be completed
//
// Related:
//   - calculateHealthGain() - Calculates HP increase on level up
//   - emitLevelUpEvent() - Broadcasts level up event to game systems
//
// Note: This method does not validate if the new level is valid (greater than current).
// Caller must ensure proper level progression.
func (p *Player) levelUp(newLevel int) error <span class="cov8" title="1">{
        oldLevel := p.Level
        p.Level = newLevel

        // Calculate and apply level up benefits
        healthGain := calculateHealthGain(p.Character.Class, p.Constitution)
        p.MaxHP += healthGain
        p.HP += healthGain

        // Update action points based on new level and dexterity
        newMaxActionPoints := calculateMaxActionPoints(newLevel, p.Character.Dexterity)
        p.Character.MaxActionPoints = newMaxActionPoints
        p.Character.ActionPoints = newMaxActionPoints // Restore to full on level up

        // Emit level up event (implementation depends on event system)
        emitLevelUpEvent(p.ID, oldLevel, newLevel)

        return nil
}</span>

// GetStats returns a copy of the player's current stats converted to float64 values.
// It creates a new Stats struct containing the player's health, max health,
// strength, dexterity and intelligence values.
//
// Returns:
//   - *Stats: A pointer to a new Stats struct containing the converted stat values
//
// Related types:
//   - Stats struct
func (p *Player) GetStats() *Stats <span class="cov8" title="1">{
        return &amp;Stats{
                Health:       float64(p.HP),
                Mana:         float64(p.Intelligence),
                Strength:     float64(p.Strength),
                Dexterity:    float64(p.Dexterity),
                Intelligence: float64(p.Intelligence),
                MaxHealth:    float64(p.MaxHP),
                MaxMana:      float64(p.Intelligence),
                Defense:      0,
                Speed:        0,
        }
}</span>

// StartQuest adds a new quest to the player's quest log and marks it as active.
// This method is thread-safe and validates that the quest doesn't already exist.
//
// Parameters:
//   - quest: The Quest object to add to the player's quest log
//
// Returns:
//   - error: Returns error if quest is invalid or already exists in quest log
//
// The method performs the following validations:
// - Quest ID must not be empty
// - Quest must not already exist in player's quest log
// - Quest status is automatically set to QuestActive
func (p *Player) StartQuest(quest Quest) error <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if quest.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("quest ID cannot be empty")
        }</span>

        // Check if quest already exists
        <span class="cov0" title="0">for _, existingQuest := range p.QuestLog </span><span class="cov0" title="0">{
                if existingQuest.ID == quest.ID </span><span class="cov0" title="0">{
                        return fmt.Errorf("quest %s already exists in quest log", quest.ID)
                }</span>
        }

        // Set quest as active and add to quest log
        <span class="cov0" title="0">quest.Status = QuestActive
        p.QuestLog = append(p.QuestLog, quest)

        return nil</span>
}

// CompleteQuest marks a quest as completed and processes its rewards.
// This method finds the quest by ID, validates it can be completed, and processes rewards.
//
// Parameters:
//   - questID: The unique identifier of the quest to complete
//
// Returns:
//   - []QuestReward: Slice of rewards granted for completing the quest
//   - error: Returns error if quest not found, already completed, or cannot be completed
//
// The method performs the following operations:
// - Validates quest exists and is active
// - Checks all objectives are completed
// - Marks quest as completed
// - Returns quest rewards for processing
func (p *Player) CompleteQuest(questID string) ([]QuestReward, error) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if questID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("quest ID cannot be empty")
        }</span>

        // Find quest in quest log
        <span class="cov0" title="0">for i, quest := range p.QuestLog </span><span class="cov0" title="0">{
                if quest.ID == questID </span><span class="cov0" title="0">{
                        if quest.Status == QuestCompleted </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("quest %s is already completed", questID)
                        }</span>
                        <span class="cov0" title="0">if quest.Status != QuestActive </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("quest %s is not active", questID)
                        }</span>

                        // Check if all objectives are completed
                        <span class="cov0" title="0">for _, objective := range quest.Objectives </span><span class="cov0" title="0">{
                                if !objective.Completed </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("quest %s cannot be completed: objective '%s' is not finished", questID, objective.Description)
                                }</span>
                        }

                        // Mark quest as completed
                        <span class="cov0" title="0">p.QuestLog[i].Status = QuestCompleted

                        return quest.Rewards, nil</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("quest %s not found in quest log", questID)</span>
}

// UpdateQuestObjective updates the progress of a specific objective within a quest.
// This method is thread-safe and handles objective completion automatically.
//
// Parameters:
//   - questID: The unique identifier of the quest containing the objective
//   - objectiveIndex: The index of the objective to update (0-based)
//   - progress: The new progress value for the objective
//
// Returns:
//   - error: Returns error if quest not found, objective index invalid, or quest not active
//
// The method performs the following operations:
// - Validates quest exists and is active
// - Validates objective index is within bounds
// - Updates objective progress and completion status
// - Progress cannot exceed the required amount
func (p *Player) UpdateQuestObjective(questID string, objectiveIndex int, progress int) error <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if questID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("quest ID cannot be empty")
        }</span>
        <span class="cov0" title="0">if progress &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("progress cannot be negative")
        }</span>

        // Find quest in quest log
        <span class="cov0" title="0">for i, quest := range p.QuestLog </span><span class="cov0" title="0">{
                if quest.ID == questID </span><span class="cov0" title="0">{
                        if quest.Status != QuestActive </span><span class="cov0" title="0">{
                                return fmt.Errorf("quest %s is not active", questID)
                        }</span>

                        // Validate objective index
                        <span class="cov0" title="0">if objectiveIndex &lt; 0 || objectiveIndex &gt;= len(quest.Objectives) </span><span class="cov0" title="0">{
                                return fmt.Errorf("objective index %d is out of bounds for quest %s", objectiveIndex, questID)
                        }</span>

                        // Update objective progress
                        <span class="cov0" title="0">objective := &amp;p.QuestLog[i].Objectives[objectiveIndex]
                        if progress &gt;= objective.Required </span><span class="cov0" title="0">{
                                objective.Progress = objective.Required
                                objective.Completed = true
                        }</span> else<span class="cov0" title="0"> {
                                objective.Progress = progress
                                objective.Completed = false
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("quest %s not found in quest log", questID)</span>
}

// FailQuest marks a quest as failed, preventing completion but keeping it in the log.
// This method is thread-safe and handles quest state transitions.
//
// Parameters:
//   - questID: The unique identifier of the quest to fail
//
// Returns:
//   - error: Returns error if quest not found or already completed/failed
//
// Failed quests remain in the quest log for reference but cannot be completed.
func (p *Player) FailQuest(questID string) error <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if questID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("quest ID cannot be empty")
        }</span>

        // Find quest in quest log
        <span class="cov0" title="0">for i, quest := range p.QuestLog </span><span class="cov0" title="0">{
                if quest.ID == questID </span><span class="cov0" title="0">{
                        if quest.Status == QuestCompleted </span><span class="cov0" title="0">{
                                return fmt.Errorf("quest %s is already completed and cannot be failed", questID)
                        }</span>
                        <span class="cov0" title="0">if quest.Status == QuestFailed </span><span class="cov0" title="0">{
                                return fmt.Errorf("quest %s is already failed", questID)
                        }</span>

                        // Mark quest as failed
                        <span class="cov0" title="0">p.QuestLog[i].Status = QuestFailed
                        return nil</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("quest %s not found in quest log", questID)</span>
}

// GetQuest retrieves a specific quest from the player's quest log by ID.
// This method is thread-safe and returns a copy of the quest to prevent external modification.
//
// Parameters:
//   - questID: The unique identifier of the quest to retrieve
//
// Returns:
//   - *Quest: Pointer to a copy of the quest, or nil if not found
//   - error: Returns error if quest ID is empty or quest not found
func (p *Player) GetQuest(questID string) (*Quest, error) <span class="cov0" title="0">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        if questID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("quest ID cannot be empty")
        }</span>

        <span class="cov0" title="0">for _, quest := range p.QuestLog </span><span class="cov0" title="0">{
                if quest.ID == questID </span><span class="cov0" title="0">{
                        // Return a copy to prevent external modification
                        questCopy := quest
                        return &amp;questCopy, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("quest %s not found in quest log", questID)</span>
}

// GetActiveQuests returns all quests that are currently active.
// This method is thread-safe and returns copies of quests to prevent external modification.
//
// Returns:
//   - []Quest: Slice containing copies of all active quests
//
// Active quests are those with status QuestActive that can still be progressed and completed.
func (p *Player) GetActiveQuests() []Quest <span class="cov0" title="0">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        var activeQuests []Quest
        for _, quest := range p.QuestLog </span><span class="cov0" title="0">{
                if quest.Status == QuestActive </span><span class="cov0" title="0">{
                        activeQuests = append(activeQuests, quest)
                }</span>
        }

        <span class="cov0" title="0">return activeQuests</span>
}

// GetCompletedQuests returns all quests that have been completed.
// This method is thread-safe and returns copies of quests to prevent external modification.
//
// Returns:
//   - []Quest: Slice containing copies of all completed quests
//
// Completed quests show the player's progression history and achievements.
func (p *Player) GetCompletedQuests() []Quest <span class="cov0" title="0">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        var completedQuests []Quest
        for _, quest := range p.QuestLog </span><span class="cov0" title="0">{
                if quest.Status == QuestCompleted </span><span class="cov0" title="0">{
                        completedQuests = append(completedQuests, quest)
                }</span>
        }

        <span class="cov0" title="0">return completedQuests</span>
}

// GetQuestLog returns a copy of the player's complete quest log.
// This method is thread-safe and returns copies to prevent external modification.
//
// Returns:
//   - []Quest: Slice containing copies of all quests in the quest log
//
// The quest log includes quests of all statuses: active, completed, and failed.
func (p *Player) GetQuestLog() []Quest <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        // Return a copy of all quests (active and completed)
        result := make([]Quest, len(p.QuestLog))
        copy(result, p.QuestLog)
        return result
}</span>

// KnowsSpell checks if the player has learned a specific spell
// Returns true if the spell is in the player's KnownSpells list
func (p *Player) KnowsSpell(spellID string) bool <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        for _, spell := range p.KnownSpells </span><span class="cov8" title="1">{
                if spell.ID == spellID </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// LearnSpell adds a new spell to the player's known spells if they don't already know it
// Returns an error if the player cannot learn the spell due to class or level restrictions
func (p *Player) LearnSpell(spell Spell) error <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // Check if player already knows the spell
        for _, knownSpell := range p.KnownSpells </span><span class="cov8" title="1">{
                if knownSpell.ID == spell.ID </span><span class="cov8" title="1">{
                        return fmt.Errorf("player already knows spell: %s", spell.ID)
                }</span>
        }

        // Check if player's class can cast spells
        <span class="cov8" title="1">if !p.canCastSpells() </span><span class="cov8" title="1">{
                return fmt.Errorf("class %s cannot cast spells", p.Class.String())
        }</span>

        // Check if player's level is sufficient for the spell
        <span class="cov8" title="1">if p.Level &lt; spell.Level </span><span class="cov8" title="1">{
                return fmt.Errorf("player level %d insufficient for spell level %d", p.Level, spell.Level)
        }</span>

        // Add the spell to known spells
        <span class="cov8" title="1">p.KnownSpells = append(p.KnownSpells, spell)
        return nil</span>
}

// canCastSpells determines if the player's class can cast spells
// Based on D&amp;D-style classes where only certain classes are spellcasters
func (p *Player) canCastSpells() bool <span class="cov8" title="1">{
        switch p.Class </span>{
        case ClassMage:<span class="cov8" title="1">
                return true</span>
        case ClassCleric:<span class="cov0" title="0">
                return true</span>
        case ClassPaladin:<span class="cov8" title="1">
                return p.Level &gt;= 9</span> // Paladins get spells at level 9
        case ClassRanger:<span class="cov0" title="0">
                return p.Level &gt;= 8</span> // Rangers get spells at level 8
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package game

import (
        "fmt"
        "math"
        "sync"
)

// SpatialIndex provides efficient spatial queries for game objects
// Implements an R-tree-like spatial data structure optimized for 2D game worlds
type SpatialIndex struct {
        mu       sync.RWMutex
        root     *SpatialNode
        cellSize int
        bounds   Rectangle
}

// SpatialNode represents a node in the spatial index tree
type SpatialNode struct {
        bounds   Rectangle
        objects  []GameObject
        children []*SpatialNode
        isLeaf   bool
}

// Rectangle represents a bounding box for spatial queries
type Rectangle struct {
        MinX, MinY, MaxX, MaxY int
}

// Circle represents a circular query area
type Circle struct {
        CenterX, CenterY int
        Radius           float64
}

// NewSpatialIndex creates a new spatial index with specified bounds and cell size
func NewSpatialIndex(width, height, cellSize int) *SpatialIndex <span class="cov8" title="1">{
        return &amp;SpatialIndex{
                cellSize: cellSize,
                bounds: Rectangle{
                        MinX: 0, MinY: 0,
                        MaxX: width, MaxY: height,
                },
                root: &amp;SpatialNode{
                        bounds:  Rectangle{MinX: 0, MinY: 0, MaxX: width, MaxY: height},
                        isLeaf:  true,
                        objects: make([]GameObject, 0),
                },
        }
}</span>

// Insert adds a game object to the spatial index
func (si *SpatialIndex) Insert(obj GameObject) error <span class="cov8" title="1">{
        si.mu.Lock()
        defer si.mu.Unlock()

        pos := obj.GetPosition()
        if !si.contains(si.bounds, pos) </span><span class="cov8" title="1">{
                return fmt.Errorf("object position %v is outside spatial index bounds", pos)
        }</span>

        <span class="cov8" title="1">return si.insertNode(si.root, obj)</span>
}

// Remove removes a game object from the spatial index
func (si *SpatialIndex) Remove(objectID string) error <span class="cov8" title="1">{
        si.mu.Lock()
        defer si.mu.Unlock()

        return si.removeNode(si.root, objectID)
}</span>

// GetObjectsInRange returns all objects within a rectangular area
func (si *SpatialIndex) GetObjectsInRange(rect Rectangle) []GameObject <span class="cov8" title="1">{
        si.mu.RLock()
        defer si.mu.RUnlock()

        var result []GameObject
        si.queryNode(si.root, rect, &amp;result)
        return result
}</span>

// GetObjectsInRadius returns all objects within a circular area
func (si *SpatialIndex) GetObjectsInRadius(center Position, radius float64) []GameObject <span class="cov8" title="1">{
        si.mu.RLock()
        defer si.mu.RUnlock()

        // Use tighter bounding box to reduce candidates
        radiusInt := int(radius)
        rect := Rectangle{
                MinX: center.X - radiusInt,
                MinY: center.Y - radiusInt,
                MaxX: center.X + radiusInt,
                MaxY: center.Y + radiusInt,
        }

        var candidates []GameObject
        si.queryNode(si.root, rect, &amp;candidates)

        // Optimized filtering with pre-allocated result slice and radius squared
        radiusSquared := radius * radius
        result := make([]GameObject, 0, len(candidates)) // Pre-allocate to avoid reallocation

        for _, obj := range candidates </span><span class="cov8" title="1">{
                objPos := obj.GetPosition()
                // Use distance squared to avoid expensive sqrt operation
                dx := float64(center.X - objPos.X)
                dy := float64(center.Y - objPos.Y)
                distanceSquared := dx*dx + dy*dy

                if distanceSquared &lt;= radiusSquared </span><span class="cov8" title="1">{
                        result = append(result, obj)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// GetNearestObjects returns the k nearest objects to a given position
func (si *SpatialIndex) GetNearestObjects(center Position, k int) []GameObject <span class="cov8" title="1">{
        si.mu.RLock()
        defer si.mu.RUnlock()

        // Start with a small radius and expand as needed
        radius := float64(si.cellSize)
        maxRadius := float64(maxInt(si.bounds.MaxX-si.bounds.MinX, si.bounds.MaxY-si.bounds.MinY))

        for radius &lt;= maxRadius </span><span class="cov8" title="1">{
                objects := si.GetObjectsInRadius(center, radius)
                if len(objects) &gt;= k </span><span class="cov8" title="1">{
                        // Sort by distance and return k nearest
                        si.sortByDistance(objects, center)
                        if len(objects) &gt; k </span><span class="cov8" title="1">{
                                return objects[:k]
                        }</span>
                        <span class="cov8" title="1">return objects</span>
                }
                <span class="cov0" title="0">radius *= 2</span>
        }

        // If we still don't have enough, return all objects sorted by distance
        <span class="cov0" title="0">var allObjects []GameObject
        si.queryNode(si.root, si.bounds, &amp;allObjects)
        si.sortByDistance(allObjects, center)
        if len(allObjects) &gt; k </span><span class="cov0" title="0">{
                return allObjects[:k]
        }</span>
        <span class="cov0" title="0">return allObjects</span>
}

// GetObjectsAt returns all objects at an exact position (optimized for single-cell queries)
func (si *SpatialIndex) GetObjectsAt(pos Position) []GameObject <span class="cov8" title="1">{
        rect := Rectangle{
                MinX: pos.X, MinY: pos.Y,
                MaxX: pos.X, MaxY: pos.Y,
        }
        return si.GetObjectsInRange(rect)
}</span>

// Update moves an object to a new position in the spatial index
func (si *SpatialIndex) Update(objectID string, newPos Position) error <span class="cov8" title="1">{
        si.mu.Lock()
        defer si.mu.Unlock()

        // Find and remove the object
        var obj GameObject
        if err := si.removeNodeWithObject(si.root, objectID, &amp;obj); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("object %s not found for update: %w", objectID, err)
        }</span>

        // Re-insert at new position
        <span class="cov8" title="1">return si.insertNode(si.root, obj)</span>
}

// Clear removes all objects from the spatial index
func (si *SpatialIndex) Clear() <span class="cov8" title="1">{
        si.mu.Lock()
        defer si.mu.Unlock()

        si.root = &amp;SpatialNode{
                bounds:  si.bounds,
                isLeaf:  true,
                objects: make([]GameObject, 0),
        }
}</span>

// GetStats returns statistics about the spatial index
func (si *SpatialIndex) GetStats() SpatialIndexStats <span class="cov8" title="1">{
        si.mu.RLock()
        defer si.mu.RUnlock()

        stats := SpatialIndexStats{}
        si.collectStats(si.root, &amp;stats, 0)
        return stats
}</span>

// SpatialIndexStats provides performance and structure information
type SpatialIndexStats struct {
        TotalObjects      int
        TotalNodes        int
        MaxDepth          int
        LeafNodes         int
        AvgObjectsPerLeaf float64
}

// Private helper methods

func (si *SpatialIndex) insertNode(node *SpatialNode, obj GameObject) error <span class="cov8" title="1">{
        pos := obj.GetPosition()

        if !si.contains(node.bounds, pos) </span><span class="cov0" title="0">{
                return fmt.Errorf("object position %v outside node bounds %v", pos, node.bounds)
        }</span>

        <span class="cov8" title="1">if node.isLeaf </span><span class="cov8" title="1">{
                node.objects = append(node.objects, obj)

                // Split if node becomes too full
                if len(node.objects) &gt; 8 &amp;&amp; si.canSplit(node.bounds) </span><span class="cov8" title="1">{
                        si.splitNode(node)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Find best child node
        <span class="cov8" title="1">for _, child := range node.children </span><span class="cov8" title="1">{
                if si.contains(child.bounds, pos) </span><span class="cov8" title="1">{
                        return si.insertNode(child, obj)
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("no suitable child node found for position %v", pos)</span>
}

func (si *SpatialIndex) removeNode(node *SpatialNode, objectID string) error <span class="cov8" title="1">{
        if node.isLeaf </span><span class="cov8" title="1">{
                for i, obj := range node.objects </span><span class="cov8" title="1">{
                        if obj.GetID() == objectID </span><span class="cov8" title="1">{
                                // Remove object by swapping with last element
                                node.objects[i] = node.objects[len(node.objects)-1]
                                node.objects = node.objects[:len(node.objects)-1]
                                return nil
                        }</span>
                }
                <span class="cov8" title="1">return fmt.Errorf("object %s not found", objectID)</span>
        }

        // Recursively search children
        <span class="cov0" title="0">for _, child := range node.children </span><span class="cov0" title="0">{
                if err := si.removeNode(child, objectID); err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("object %s not found in any child", objectID)</span>
}

func (si *SpatialIndex) removeNodeWithObject(node *SpatialNode, objectID string, obj *GameObject) error <span class="cov8" title="1">{
        if node.isLeaf </span><span class="cov8" title="1">{
                for i, o := range node.objects </span><span class="cov8" title="1">{
                        if o.GetID() == objectID </span><span class="cov8" title="1">{
                                *obj = o
                                node.objects[i] = node.objects[len(node.objects)-1]
                                node.objects = node.objects[:len(node.objects)-1]
                                return nil
                        }</span>
                }
                <span class="cov8" title="1">return fmt.Errorf("object %s not found", objectID)</span>
        }

        <span class="cov0" title="0">for _, child := range node.children </span><span class="cov0" title="0">{
                if err := si.removeNodeWithObject(child, objectID, obj); err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("object %s not found in any child", objectID)</span>
}

func (si *SpatialIndex) queryNode(node *SpatialNode, rect Rectangle, result *[]GameObject) <span class="cov8" title="1">{
        if !si.intersects(node.bounds, rect) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if node.isLeaf </span><span class="cov8" title="1">{
                for _, obj := range node.objects </span><span class="cov8" title="1">{
                        pos := obj.GetPosition()
                        if si.contains(rect, pos) </span><span class="cov8" title="1">{
                                *result = append(*result, obj)
                        }</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">for _, child := range node.children </span><span class="cov8" title="1">{
                si.queryNode(child, rect, result)
        }</span>
}

func (si *SpatialIndex) splitNode(node *SpatialNode) <span class="cov8" title="1">{
        if !node.isLeaf || len(node.objects) &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">bounds := node.bounds
        midX := (bounds.MinX + bounds.MaxX) / 2
        midY := (bounds.MinY + bounds.MaxY) / 2

        // Create four child nodes
        node.children = []*SpatialNode{
                {bounds: Rectangle{bounds.MinX, bounds.MinY, midX, midY}, isLeaf: true, objects: make([]GameObject, 0)},
                {bounds: Rectangle{midX, bounds.MinY, bounds.MaxX, midY}, isLeaf: true, objects: make([]GameObject, 0)},
                {bounds: Rectangle{bounds.MinX, midY, midX, bounds.MaxY}, isLeaf: true, objects: make([]GameObject, 0)},
                {bounds: Rectangle{midX, midY, bounds.MaxX, bounds.MaxY}, isLeaf: true, objects: make([]GameObject, 0)},
        }

        // Redistribute objects to children
        for _, obj := range node.objects </span><span class="cov8" title="1">{
                pos := obj.GetPosition()
                for _, child := range node.children </span><span class="cov8" title="1">{
                        if si.contains(child.bounds, pos) </span><span class="cov8" title="1">{
                                child.objects = append(child.objects, obj)
                                break</span>
                        }
                }
        }

        // Clear parent objects and mark as non-leaf
        <span class="cov8" title="1">node.objects = nil
        node.isLeaf = false</span>
}

func (si *SpatialIndex) canSplit(bounds Rectangle) bool <span class="cov8" title="1">{
        width := bounds.MaxX - bounds.MinX
        height := bounds.MaxY - bounds.MinY
        return width &gt; si.cellSize &amp;&amp; height &gt; si.cellSize
}</span>

func (si *SpatialIndex) contains(rect Rectangle, pos Position) bool <span class="cov8" title="1">{
        return pos.X &gt;= rect.MinX &amp;&amp; pos.X &lt;= rect.MaxX &amp;&amp;
                pos.Y &gt;= rect.MinY &amp;&amp; pos.Y &lt;= rect.MaxY
}</span>

func (si *SpatialIndex) intersects(rect1, rect2 Rectangle) bool <span class="cov8" title="1">{
        return rect1.MinX &lt;= rect2.MaxX &amp;&amp; rect1.MaxX &gt;= rect2.MinX &amp;&amp;
                rect1.MinY &lt;= rect2.MaxY &amp;&amp; rect1.MaxY &gt;= rect2.MinY
}</span>

func (si *SpatialIndex) distance(pos1, pos2 Position) float64 <span class="cov8" title="1">{
        dx := float64(pos1.X - pos2.X)
        dy := float64(pos1.Y - pos2.Y)
        return math.Sqrt(dx*dx + dy*dy)
}</span>

func (si *SpatialIndex) sortByDistance(objects []GameObject, center Position) <span class="cov8" title="1">{
        for i := 0; i &lt; len(objects)-1; i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(objects); j++ </span><span class="cov8" title="1">{
                        dist1 := si.distance(center, objects[i].GetPosition())
                        dist2 := si.distance(center, objects[j].GetPosition())
                        if dist1 &gt; dist2 </span><span class="cov0" title="0">{
                                objects[i], objects[j] = objects[j], objects[i]
                        }</span>
                }
        }
}

func (si *SpatialIndex) collectStats(node *SpatialNode, stats *SpatialIndexStats, depth int) <span class="cov8" title="1">{
        stats.TotalNodes++
        if depth &gt; stats.MaxDepth </span><span class="cov8" title="1">{
                stats.MaxDepth = depth
        }</span>

        <span class="cov8" title="1">if node.isLeaf </span><span class="cov8" title="1">{
                stats.LeafNodes++
                stats.TotalObjects += len(node.objects)
        }</span> else<span class="cov8" title="1"> {
                for _, child := range node.children </span><span class="cov8" title="1">{
                        si.collectStats(child, stats, depth+1)
                }</span>
        }
}

// maxInt function is now defined in utils.go
</pre>
		
		<pre class="file" id="file21" style="display: none">package game

// Spell represents a magical ability that can be cast in the game.
// It contains all the necessary information about a spell's properties and effects.
//
// Fields:
//   - ID: Unique string identifier for the spell
//   - Name: Display name shown to players
//   - Level: Required caster level (must be &gt;= 0)
//   - School: Magic school classification (e.g. Abjuration, Evocation)
//   - Range: Distance in game units the spell can reach (must be &gt;= 0)
//   - Duration: Number of game turns the spell effects last (must be &gt;= 0)
//   - Components: Required components needed to cast the spell
//   - Description: Detailed text describing the spell's effects and usage
//   - DamageType: Type of damage dealt (fire, cold, etc.)
//   - DamageDice: Dice expression for damage (e.g., "3d6+2")
//   - HealingDice: Dice expression for healing (e.g., "2d4+1")
//   - AreaEffect: Whether the spell affects an area
//   - SaveType: Type of saving throw required
//   - EffectKeywords: Tags describing spell effects
//
// Related types:
//   - SpellSchool: Enum defining valid magic schools
//   - SpellComponent: Struct defining spell component requirements
type Spell struct {
        ID             string           `yaml:"spell_id"`          // Unique identifier for the spell
        Name           string           `yaml:"spell_name"`        // Display name of the spell
        Level          int              `yaml:"spell_level"`       // Required caster level for the spell
        School         SpellSchool      `yaml:"spell_school"`      // Magic school classification
        Range          int              `yaml:"spell_range"`       // Range in game units
        Duration       int              `yaml:"spell_duration"`    // Duration in game turns
        Components     []SpellComponent `yaml:"spell_components"`  // Required components for casting
        Description    string           `yaml:"spell_description"` // Full spell description and effects
        DamageType     string           `yaml:"damage_type"`       // Type of damage (fire, cold, etc.)
        DamageDice     string           `yaml:"damage_dice"`       // Damage dice expression
        HealingDice    string           `yaml:"healing_dice"`      // Healing dice expression
        AreaEffect     bool             `yaml:"area_effect"`       // Whether spell affects an area
        SaveType       string           `yaml:"save_type"`         // Required saving throw type
        EffectKeywords []string         `yaml:"effect_keywords"`   // Tags describing spell effects
}

// SpellSchool represents the different schools of magic available in the game
// SpellSchool represents the school/category of magic that a spell belongs to.
// It is implemented as an integer type for efficient storage and comparison.
// The specific values are defined as constants representing different magical disciplines
// like Abjuration, Conjuration, Evocation etc.
//
// Related types:
// - Spell struct - Contains SpellSchool as one of its properties
// - SpellEffect interface - Implemented by specific spell effects
type SpellSchool int

// SchoolAbjuration represents the school of Abjuration magic in the game world.
// Abjuration spells are protective in nature, creating barriers, negating harmful
// effects, or banishing creatures to other planes of existence.
//
// This is one of the eight classical schools of magic defined in the game system.
//
// Related constants:
// - SchoolConjuration
// - SchoolDivination
// - SchoolEnchantment
// - SchoolEvocation
// - SchoolIllusion
// SpellSchool constants are defined in constants.go
// - SchoolNecromancy
// - SchoolTransmutation

// SpellComponent represents a component of a spell in the game.
// It is implemented as an integer type that can be used to classify
// different aspects or parts of a spell, such as verbal, somatic,
// or material components.
//
// Related types:
//   - Spell (not shown in provided code)
type SpellComponent int

// SpellComponent constants are defined in constants.go
// Related constants:
// - ComponentSomatic
// - ComponentMaterial

// String returns the string representation of a SpellSchool
func (s SpellSchool) String() string <span class="cov8" title="1">{
        switch s </span>{
        case SchoolAbjuration:<span class="cov8" title="1">
                return "Abjuration"</span>
        case SchoolConjuration:<span class="cov8" title="1">
                return "Conjuration"</span>
        case SchoolDivination:<span class="cov8" title="1">
                return "Divination"</span>
        case SchoolEnchantment:<span class="cov8" title="1">
                return "Enchantment"</span>
        case SchoolEvocation:<span class="cov8" title="1">
                return "Evocation"</span>
        case SchoolIllusion:<span class="cov8" title="1">
                return "Illusion"</span>
        case SchoolNecromancy:<span class="cov8" title="1">
                return "Necromancy"</span>
        case SchoolTransmutation:<span class="cov8" title="1">
                return "Transmutation"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// ParseSpellSchool converts a string to a SpellSchool enum
func ParseSpellSchool(s string) SpellSchool <span class="cov8" title="1">{
        switch s </span>{
        case "Abjuration", "abjuration":<span class="cov8" title="1">
                return SchoolAbjuration</span>
        case "Conjuration", "conjuration":<span class="cov0" title="0">
                return SchoolConjuration</span>
        case "Divination", "divination":<span class="cov0" title="0">
                return SchoolDivination</span>
        case "Enchantment", "enchantment":<span class="cov0" title="0">
                return SchoolEnchantment</span>
        case "Evocation", "evocation":<span class="cov8" title="1">
                return SchoolEvocation</span>
        case "Illusion", "illusion":<span class="cov0" title="0">
                return SchoolIllusion</span>
        case "Necromancy", "necromancy":<span class="cov0" title="0">
                return SchoolNecromancy</span>
        case "Transmutation", "transmutation":<span class="cov0" title="0">
                return SchoolTransmutation</span>
        default:<span class="cov8" title="1">
                return SchoolEvocation</span> // Default to Evocation
        }
}

// String returns the string representation of a SpellComponent
func (c SpellComponent) String() string <span class="cov8" title="1">{
        switch c </span>{
        case ComponentVerbal:<span class="cov8" title="1">
                return "Verbal"</span>
        case ComponentSomatic:<span class="cov8" title="1">
                return "Somatic"</span>
        case ComponentMaterial:<span class="cov8" title="1">
                return "Material"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// ParseSpellComponent converts a string to a SpellComponent enum
func ParseSpellComponent(s string) SpellComponent <span class="cov8" title="1">{
        switch s </span>{
        case "Verbal", "verbal", "V":<span class="cov8" title="1">
                return ComponentVerbal</span>
        case "Somatic", "somatic", "S":<span class="cov8" title="1">
                return ComponentSomatic</span>
        case "Material", "material", "M":<span class="cov8" title="1">
                return ComponentMaterial</span>
        default:<span class="cov8" title="1">
                return ComponentVerbal</span> // Default to Verbal
        }
}

// SpellCollection represents a collection of spells loaded from YAML
type SpellCollection struct {
        Spells []Spell `yaml:"spells"`
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package game

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"

        "gopkg.in/yaml.v3"
)

// SpellManager handles loading, saving, and managing spells from YAML files
type SpellManager struct {
        spellsDir string
        spells    map[string]*Spell // Map of spell ID to spell
}

// NewSpellManager creates a new SpellManager instance
func NewSpellManager(spellsDir string) *SpellManager <span class="cov8" title="1">{
        return &amp;SpellManager{
                spellsDir: spellsDir,
                spells:    make(map[string]*Spell),
        }
}</span>

// LoadSpells loads all spell files from the spells directory
func (sm *SpellManager) LoadSpells() error <span class="cov8" title="1">{
        if _, err := os.Stat(sm.spellsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("spells directory does not exist: %s", sm.spellsDir)
        }</span>

        <span class="cov8" title="1">files, err := os.ReadDir(sm.spellsDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read spells directory: %w", err)
        }</span>

        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                if !strings.HasSuffix(file.Name(), ".yaml") &amp;&amp; !strings.HasSuffix(file.Name(), ".yml") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">filePath := filepath.Join(sm.spellsDir, file.Name())
                if err := sm.loadSpellFile(filePath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load spell file %s: %w", file.Name(), err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// loadSpellFile loads spells from a single YAML file
func (sm *SpellManager) loadSpellFile(filePath string) error <span class="cov8" title="1">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov8" title="1">var collection SpellCollection
        if err := yaml.Unmarshal(data, &amp;collection); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        <span class="cov8" title="1">for i := range collection.Spells </span><span class="cov8" title="1">{
                spell := &amp;collection.Spells[i]

                // Validate spell
                if err := sm.validateSpell(spell); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid spell %s: %w", spell.ID, err)
                }</span>

                <span class="cov8" title="1">sm.spells[spell.ID] = spell</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateSpell ensures a spell has valid data
func (sm *SpellManager) validateSpell(spell *Spell) error <span class="cov8" title="1">{
        if spell.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("spell ID cannot be empty")
        }</span>
        <span class="cov8" title="1">if spell.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("spell name cannot be empty")
        }</span>
        <span class="cov8" title="1">if spell.Level &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("spell level cannot be negative")
        }</span>
        <span class="cov8" title="1">if spell.Range &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("spell range cannot be negative")
        }</span>
        <span class="cov8" title="1">if spell.Duration &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("spell duration cannot be negative")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SaveSpell saves a single spell to a YAML file
func (sm *SpellManager) SaveSpell(spell *Spell, filename string) error <span class="cov8" title="1">{
        if err := sm.validateSpell(spell); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid spell: %w", err)
        }</span>

        <span class="cov8" title="1">collection := SpellCollection{
                Spells: []Spell{*spell},
        }

        data, err := yaml.Marshal(collection)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal spell to YAML: %w", err)
        }</span>

        <span class="cov8" title="1">filePath := filepath.Join(sm.spellsDir, filename)
        if err := os.WriteFile(filePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write spell file: %w", err)
        }</span>

        // Add to memory
        <span class="cov8" title="1">sm.spells[spell.ID] = spell

        return nil</span>
}

// SaveSpellsByLevel saves spells grouped by level to separate files
func (sm *SpellManager) SaveSpellsByLevel() error <span class="cov0" title="0">{
        // Group spells by level
        spellsByLevel := make(map[int][]Spell)

        for _, spell := range sm.spells </span><span class="cov0" title="0">{
                spellsByLevel[spell.Level] = append(spellsByLevel[spell.Level], *spell)
        }</span>

        // Save each level to a separate file
        <span class="cov0" title="0">for level, spells := range spellsByLevel </span><span class="cov0" title="0">{
                // Sort spells by name for consistent output
                sort.Slice(spells, func(i, j int) bool </span><span class="cov0" title="0">{
                        return spells[i].Name &lt; spells[j].Name
                }</span>)

                <span class="cov0" title="0">collection := SpellCollection{Spells: spells}
                data, err := yaml.Marshal(collection)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal level %d spells: %w", level, err)
                }</span>

                <span class="cov0" title="0">var filename string
                if level == 0 </span><span class="cov0" title="0">{
                        filename = "cantrips.yaml"
                }</span> else<span class="cov0" title="0"> {
                        filename = fmt.Sprintf("level%d.yaml", level)
                }</span>

                <span class="cov0" title="0">filePath := filepath.Join(sm.spellsDir, filename)
                if err := os.WriteFile(filePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write level %d spells: %w", level, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetSpell retrieves a spell by ID
func (sm *SpellManager) GetSpell(spellID string) (*Spell, error) <span class="cov8" title="1">{
        spell, exists := sm.spells[spellID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("spell not found: %s", spellID)
        }</span>

        // Return a copy to prevent external modification
        <span class="cov8" title="1">spellCopy := *spell
        return &amp;spellCopy, nil</span>
}

// GetSpellsByLevel returns all spells of a specific level
func (sm *SpellManager) GetSpellsByLevel(level int) []*Spell <span class="cov8" title="1">{
        var result []*Spell

        for _, spell := range sm.spells </span><span class="cov8" title="1">{
                if spell.Level == level </span><span class="cov8" title="1">{
                        spellCopy := *spell
                        result = append(result, &amp;spellCopy)
                }</span>
        }

        // Sort by name
        <span class="cov8" title="1">sort.Slice(result, func(i, j int) bool </span><span class="cov8" title="1">{
                return result[i].Name &lt; result[j].Name
        }</span>)

        <span class="cov8" title="1">return result</span>
}

// GetSpellsBySchool returns all spells of a specific school
func (sm *SpellManager) GetSpellsBySchool(school SpellSchool) []*Spell <span class="cov8" title="1">{
        var result []*Spell

        for _, spell := range sm.spells </span><span class="cov8" title="1">{
                if spell.School == school </span><span class="cov8" title="1">{
                        spellCopy := *spell
                        result = append(result, &amp;spellCopy)
                }</span>
        }

        // Sort by level, then name
        <span class="cov8" title="1">sort.Slice(result, func(i, j int) bool </span><span class="cov8" title="1">{
                if result[i].Level != result[j].Level </span><span class="cov8" title="1">{
                        return result[i].Level &lt; result[j].Level
                }</span>
                <span class="cov0" title="0">return result[i].Name &lt; result[j].Name</span>
        })

        <span class="cov8" title="1">return result</span>
}

// GetAllSpells returns all loaded spells
func (sm *SpellManager) GetAllSpells() []*Spell <span class="cov0" title="0">{
        var result []*Spell

        for _, spell := range sm.spells </span><span class="cov0" title="0">{
                spellCopy := *spell
                result = append(result, &amp;spellCopy)
        }</span>

        // Sort by level, then name
        <span class="cov0" title="0">sort.Slice(result, func(i, j int) bool </span><span class="cov0" title="0">{
                if result[i].Level != result[j].Level </span><span class="cov0" title="0">{
                        return result[i].Level &lt; result[j].Level
                }</span>
                <span class="cov0" title="0">return result[i].Name &lt; result[j].Name</span>
        })

        <span class="cov0" title="0">return result</span>
}

// AddSpell adds a new spell to the manager
func (sm *SpellManager) AddSpell(spell *Spell) error <span class="cov8" title="1">{
        if err := sm.validateSpell(spell); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid spell: %w", err)
        }</span>

        <span class="cov8" title="1">if _, exists := sm.spells[spell.ID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("spell already exists: %s", spell.ID)
        }</span>

        <span class="cov8" title="1">sm.spells[spell.ID] = spell
        return nil</span>
}

// UpdateSpell updates an existing spell
func (sm *SpellManager) UpdateSpell(spell *Spell) error <span class="cov0" title="0">{
        if err := sm.validateSpell(spell); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid spell: %w", err)
        }</span>

        <span class="cov0" title="0">if _, exists := sm.spells[spell.ID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("spell not found: %s", spell.ID)
        }</span>

        <span class="cov0" title="0">sm.spells[spell.ID] = spell
        return nil</span>
}

// RemoveSpell removes a spell from the manager
func (sm *SpellManager) RemoveSpell(spellID string) error <span class="cov0" title="0">{
        if _, exists := sm.spells[spellID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("spell not found: %s", spellID)
        }</span>

        <span class="cov0" title="0">delete(sm.spells, spellID)
        return nil</span>
}

// GetSpellCount returns the total number of loaded spells
func (sm *SpellManager) GetSpellCount() int <span class="cov0" title="0">{
        return len(sm.spells)
}</span>

// GetSpellCountByLevel returns the number of spells at each level
func (sm *SpellManager) GetSpellCountByLevel() map[int]int <span class="cov0" title="0">{
        counts := make(map[int]int)

        for _, spell := range sm.spells </span><span class="cov0" title="0">{
                counts[spell.Level]++
        }</span>

        <span class="cov0" title="0">return counts</span>
}

// SearchSpells searches for spells by name or keywords
func (sm *SpellManager) SearchSpells(query string) []*Spell <span class="cov8" title="1">{
        var result []*Spell
        query = strings.ToLower(query)

        for _, spell := range sm.spells </span><span class="cov8" title="1">{
                // Search in name
                if strings.Contains(strings.ToLower(spell.Name), query) </span><span class="cov8" title="1">{
                        spellCopy := *spell
                        result = append(result, &amp;spellCopy)
                        continue</span>
                }

                // Search in description
                <span class="cov8" title="1">if strings.Contains(strings.ToLower(spell.Description), query) </span><span class="cov8" title="1">{
                        spellCopy := *spell
                        result = append(result, &amp;spellCopy)
                        continue</span>
                }

                // Search in keywords
                <span class="cov8" title="1">for _, keyword := range spell.EffectKeywords </span><span class="cov8" title="1">{
                        if strings.Contains(strings.ToLower(keyword), query) </span><span class="cov8" title="1">{
                                spellCopy := *spell
                                result = append(result, &amp;spellCopy)
                                break</span>
                        }
                }
        }

        // Sort by level, then name
        <span class="cov8" title="1">sort.Slice(result, func(i, j int) bool </span><span class="cov8" title="1">{
                if result[i].Level != result[j].Level </span><span class="cov0" title="0">{
                        return result[i].Level &lt; result[j].Level
                }</span>
                <span class="cov8" title="1">return result[i].Name &lt; result[j].Name</span>
        })

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package game

// TileType represents the type of a tile in the game world.
// It is implemented as an integer enum to efficiently store and compare different tile types.
type TileType int

// TileType constants are defined in constants.go
// Each constant is assigned a unique integer value through iota.

// Tile represents a single cell in the game map. It encapsulates all properties
// that define a tile's behavior, appearance, and interaction capabilities within the game world.
//
// Related types:
// - TileType: Defines the base classification of the tile
// - RGB: Defines the color properties
//
// Fields:
// - Type: Base classification of the tile (floor, wall, etc.)
// - Walkable: Determines if entities can traverse this tile
// - Transparent: Controls if light can pass through the tile
// - Properties: Custom key-value store for additional tile attributes
// - Sprite: Identifier for the tile's visual representation
// - Color: Base RGB color tint for rendering
// - BlocksSight: Specifically controls line of sight behavior
// - Dangerous: Indicates if the tile can cause damage
// - DamageType: Classification of damage (e.g., "fire", "poison")
// - Damage: Integer amount of damage dealt per turn if dangerous
//
// Note: Properties map allows for dynamic extension of tile attributes
// without modifying the core structure.
type Tile struct {
        Type        TileType               `yaml:"tile_type"`        // Base type of the tile
        Walkable    bool                   `yaml:"tile_walkable"`    // Whether entities can move through
        Transparent bool                   `yaml:"tile_transparent"` // Whether light passes through
        Properties  map[string]interface{} `yaml:"tile_properties"`  // Custom property map

        // Visual properties
        Sprite string `yaml:"tile_sprite"` // Sprite/texture identifier
        Color  RGB    `yaml:"tile_color"`  // Base color tint

        // Special properties
        BlocksSight bool   `yaml:"tile_blocks_sight"` // Whether blocks line of sight
        Dangerous   bool   `yaml:"tile_dangerous"`    // Whether causes damage
        DamageType  string `yaml:"tile_damage_type"`  // Type of damage dealt
        Damage      int    `yaml:"tile_damage"`       // Amount of damage per turn
}

// RGB represents a color in RGB format
// Each component ranges from 0-255
// RGB represents a color in the RGB color space with 8-bit components.
// Each component (R,G,B) ranges from 0-255.
//
// The struct is designed to be YAML serializable with custom field tags.
//
// This is used throughout the game engine for defining colors of tiles,
// sprites and other visual elements.
//
// Related types:
//   - Tile - Uses RGB for foreground/background colors
type RGB struct {
        R uint8 `yaml:"color_red"`   // Red component
        G uint8 `yaml:"color_green"` // Green component
        B uint8 `yaml:"color_blue"`  // Blue component
}

// NewFloorTile creates and returns a new floor tile with default properties.
// The floor tile is walkable and transparent with a light gray color (RGB: 200,200,200).
// Returns a Tile struct configured as a basic floor tile with:
// - Type: TileFloor
// - Walkable: true
// - Transparent: true
// - Empty properties map
// - Light gray color
//
// Related types:
// - Tile struct
// - TileFloor constant
func NewFloorTile() Tile <span class="cov8" title="1">{
        return Tile{
                Type:        TileFloor,
                Walkable:    true,
                Transparent: true,
                Properties:  make(map[string]interface{}),
                Sprite:      "",
                Color:       RGB{200, 200, 200},
                BlocksSight: false,
                Dangerous:   false,
                DamageType:  "",
                Damage:      0,
        }
}</span>

// NewWallTile creates and returns a new wall tile with default properties.
// It initializes an impassable, opaque wall with gray coloring that blocks line of sight.
//
// Returns:
//   - Tile: A new wall tile instance with the following default properties:
//   - Type: TileWall
//   - Walkable: false (cannot be walked through)
//   - Transparent: false (blocks vision)
//   - Properties: empty map for custom properties
//   - Sprite: empty string (no sprite assigned)
//   - Color: gray RGB(128,128,128)
//   - BlocksSight: true (blocks line of sight)
//   - Dangerous: false (does not cause damage)
//   - DamageType: empty string (no damage type)
//   - Damage: 0 (no damage value)
//
// Related types:
//   - Tile
//   - RGB
//   - TileWall (constant)
func NewWallTile() Tile <span class="cov8" title="1">{
        return Tile{
                Type:        TileWall,
                Walkable:    false,
                Transparent: false,
                Properties:  make(map[string]interface{}),
                Sprite:      "",
                Color:       RGB{128, 128, 128},
                BlocksSight: true,
                Dangerous:   false,
                DamageType:  "",
                Damage:      0,
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package game

import (
        "github.com/google/uuid"
)

// NewUID generates a unique identifier string using UUID v4.
//
// Thread Safety:
//   - This function is thread-safe and does not modify shared state.
//
// Returns a 36-character UUID string (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).
func NewUID() string <span class="cov8" title="1">{
        return uuid.NewString()
}</span>

// isValidPosition checks if a given Position is valid within game bounds.
//
// Thread Safety:
//   - This function is thread-safe and does not modify shared state.
//
// Parameters:
//   - pos: Position struct containing X, Y coordinates and Level number
//   - width: map width (max X+1)
//   - height: map height (max Y+1)
//   - maxLevel: number of levels (max Level+1)
//
// Returns:
//   - bool: true if position is valid (within bounds), false otherwise
func isValidPosition(pos Position, width, height, maxLevel int) bool <span class="cov8" title="1">{
        return pos.X &gt;= 0 &amp;&amp; pos.Y &gt;= 0 &amp;&amp; pos.Level &gt;= 0 &amp;&amp;
                pos.X &lt; width &amp;&amp; pos.Y &lt; height &amp;&amp; pos.Level &lt; maxLevel
}</span>

// calculateLevel determines the character level based on experience points using a D&amp;D-style progression system.
//
// Thread Safety:
//   - This function is thread-safe and does not modify shared state.
//
// Parameters:
//   - exp: The total experience points (must be non-negative integer)
//
// Returns:
//   - An integer representing the character level based on experience thresholds
//
// Level thresholds:
//
//        Level 1: 0-1999 XP
//        Level 2: 2000-3999 XP
//        Level 3: 4000-7999 XP
//        Level 4: 8000-15999 XP
//        Level 5: 16000-31999 XP
//        Level 6: 32000-63999 XP
//        Level 7: 64000+ XP
//
// Notes:
//   - Returns level 0 for negative experience values
//   - Returns max level (7) for experience values above highest threshold
func calculateLevel(exp int64) int <span class="cov8" title="1">{
        // Handle negative experience values
        if exp &lt; 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Implement D&amp;D-style level progression
        // Level 1: 0-1999 XP, Level 2: 2000-3999 XP, etc.
        <span class="cov8" title="1">levels := []int64{0, 2000, 4000, 8000, 16000, 32000, 64000}

        // Find the highest threshold that the experience meets or exceeds
        currentLevel := 1
        for i := 1; i &lt; len(levels); i++ </span><span class="cov8" title="1">{
                if exp &gt;= levels[i] </span><span class="cov8" title="1">{
                        currentLevel = i + 1
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">return currentLevel</span>
}

// calculateHealthGain calculates the health points gained when a character levels up
// based on their character class and constitution score.
//
// Thread Safety:
//   - This function is thread-safe and does not modify shared state.
func calculateHealthGain(class CharacterClass, constitution int) int <span class="cov8" title="1">{
        baseGain := map[CharacterClass]int{
                ClassFighter: 10,
                ClassMage:    4,
                ClassCleric:  8,
                ClassThief:   6,
                ClassRanger:  8,
                ClassPaladin: 10,
        }

        conBonus := (constitution - 10) / 2
        return baseGain[class] + conBonus
}</span>

// minFloat returns the smaller of two float64 values.
//
// Thread Safety:
//   - This function is thread-safe and does not modify shared state.
func minFloat(a, b float64) float64 <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// maxFloat returns the larger of two float64 values.
//
// Thread Safety:
//   - This function is thread-safe and does not modify shared state.
func maxFloat(a, b float64) float64 <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// maxInt returns the larger of two int values.
//
// Thread Safety:
//   - This function is thread-safe and does not modify shared state.
func maxInt(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

// minInt returns the smaller of two int values.
//
// Thread Safety:
//   - This function is thread-safe and does not modify shared state.
func minInt(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// clampFloat restricts a value between a minimum and maximum bound.
// This utility function ensures that val is within the range [minVal, maxVal].
//
// Thread Safety:
//   - This function is thread-safe and does not modify shared state.
func clampFloat(val, minVal, maxVal float64) float64 <span class="cov0" title="0">{
        return maxFloat(minVal, minFloat(val, maxVal))
}</span>

// calculateMaxActionPoints determines the maximum action points for a character based on their level and dexterity.
//
// Thread Safety:
//   - This function is thread-safe and does not modify shared state.
//
// Parameters:
//   - level: The character's current level (must be at least 1)
//   - dexterity: The character's dexterity score
//
// Returns:
//   - int: The maximum action points for the given level and dexterity
//
// Notes:
//   - If level &lt; 1, the function clamps it to 1. This may mask logic errors in calling code.
//     Consider validating level before calling this function.
func calculateMaxActionPoints(level, dexterity int) int <span class="cov8" title="1">{
        if level &lt; 1 </span><span class="cov8" title="1">{
                level = 1
        }</span>

        // Start with base action points
        <span class="cov8" title="1">basePoints := ActionPointsPerTurn

        // Add 1 action point for each odd level beyond 1
        // Odd levels: 3, 5, 7, 9, etc.
        // At level 3: (3-1)/2 = 1 bonus point
        // At level 5: (5-1)/2 = 2 bonus points
        // At level 7: (7-1)/2 = 3 bonus points
        bonusPoints := 0
        if level &gt;= 3 </span><span class="cov8" title="1">{
                bonusPoints = (level - 1) / 2
        }</span>

        // Add dexterity bonus
        <span class="cov8" title="1">dexterityBonus := 0
        if dexterity &gt; 14 </span><span class="cov8" title="1">{
                dexterityBonus = 1
        }</span>

        <span class="cov8" title="1">return basePoints + bonusPoints + dexterityBonus</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package game

import (
        "fmt"
        "math"
        "sync"
)

// World manages the game state and all game objects
// Contains the complete state of the game world including all entities and maps
type World struct {
        mu           sync.RWMutex          `yaml:"-"`                  // Protects concurrent access
        Levels       []Level               `yaml:"world_levels"`       // All game levels/maps
        CurrentTime  GameTime              `yaml:"world_current_time"` // Current game time
        Objects      map[string]GameObject `yaml:"world_objects"`      // All game objects by ID
        Players      map[string]*Player    `yaml:"world_players"`      // Active players by ID
        NPCs         map[string]*NPC       `yaml:"world_npcs"`         // Non-player characters by ID
        SpatialGrid  map[Position][]string `yaml:"world_spatial_grid"` // Legacy spatial index (for compatibility)
        SpatialIndex *SpatialIndex         `yaml:"-"`                  // Advanced spatial indexing system
        Width        int                   `yaml:"world_width"`        // Width of the world
        Height       int                   `yaml:"world_height"`       // Height of the world
}

// Update applies a set of updates to the World state
func (w *World) Update(worldUpdates map[string]interface{}) error <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        for key, value := range worldUpdates </span><span class="cov8" title="1">{
                switch key </span>{
                case "objects":<span class="cov8" title="1">
                        if err := w.updateObjects(value); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case "players":<span class="cov8" title="1">
                        w.updatePlayers(value)</span>
                case "npcs":<span class="cov8" title="1">
                        w.updateNPCs(value)</span>
                case "current_time":<span class="cov8" title="1">
                        w.updateGameTime(value)</span>
                default:<span class="cov8" title="1">
                        return fmt.Errorf("unknown update key: %s", key)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// updateObjects updates all game objects and maintains spatial indexing
func (w *World) updateObjects(value interface{}) error <span class="cov8" title="1">{
        objects, ok := value.(map[string]GameObject)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for id, obj := range objects </span><span class="cov8" title="1">{
                w.Objects[id] = obj
                pos := obj.GetPosition()
                w.SpatialGrid[pos] = append(w.SpatialGrid[pos], obj.GetID())

                // Update advanced spatial index if available
                if w.SpatialIndex != nil </span><span class="cov8" title="1">{
                        if err := w.SpatialIndex.Insert(obj); err != nil </span>{<span class="cov0" title="0">
                                // Log error but don't fail the entire update
                                // This ensures backward compatibility if spatial index has issues
                                // In a production system, this could use logrus for proper logging
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// updatePlayers updates all player entities in the world
func (w *World) updatePlayers(value interface{}) <span class="cov8" title="1">{
        players, ok := value.(map[string]*Player)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">for id, player := range players </span><span class="cov8" title="1">{
                w.Players[id] = player
        }</span>
}

// updateNPCs updates all non-player characters in the world
func (w *World) updateNPCs(value interface{}) <span class="cov8" title="1">{
        npcs, ok := value.(map[string]*NPC)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">for id, npc := range npcs </span><span class="cov8" title="1">{
                w.NPCs[id] = npc
        }</span>
}

// updateGameTime updates the current game time
func (w *World) updateGameTime(value interface{}) <span class="cov8" title="1">{
        time, ok := value.(GameTime)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">w.CurrentTime = time</span>
}

// Clone creates a deep copy of the World
func (w *World) Clone() *World <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        clone := &amp;World{
                Levels:      make([]Level, len(w.Levels)),
                CurrentTime: w.CurrentTime,
                Objects:     make(map[string]GameObject),
                Players:     make(map[string]*Player),
                NPCs:        make(map[string]*NPC),
                SpatialGrid: make(map[Position][]string),
                Width:       w.Width,
                Height:      w.Height,
        }

        // Deep copy levels
        copy(clone.Levels, w.Levels)

        // Copy objects
        for k, v := range w.Objects </span><span class="cov8" title="1">{
                clone.Objects[k] = v
        }</span>

        // Copy players
        <span class="cov8" title="1">for k, v := range w.Players </span><span class="cov8" title="1">{
                clone.Players[k] = v
        }</span>

        // Copy NPCs
        <span class="cov8" title="1">for k, v := range w.NPCs </span><span class="cov8" title="1">{
                clone.NPCs[k] = v
        }</span>

        // Copy spatial grid
        <span class="cov8" title="1">for k, v := range w.SpatialGrid </span><span class="cov8" title="1">{
                gridCopy := make([]string, len(v))
                copy(gridCopy, v)
                clone.SpatialGrid[k] = gridCopy
        }</span>

        // Clone spatial index by rebuilding it with all objects
        <span class="cov8" title="1">if w.SpatialIndex != nil </span><span class="cov8" title="1">{
                clone.SpatialIndex = NewSpatialIndex(w.Width, w.Height, w.SpatialIndex.cellSize)
                for _, obj := range clone.Objects </span><span class="cov8" title="1">{
                        if err := clone.SpatialIndex.Insert(obj); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue cloning other objects for robustness
                                // In production, this would use proper logging (logrus)
                                continue</span>
                        }
                }
        }

        <span class="cov8" title="1">return clone</span>
}

// WorldState represents the serializable state of the world
// Used for saving/loading game state
type WorldState struct {
        WorldVersion string     `yaml:"world_version"`       // World data version
        LastSaved    GameTime   `yaml:"world_last_saved"`    // Last save timestamp
        ActiveLevels []string   `yaml:"world_active_levels"` // Currently active level IDs
        Statistics   WorldStats `yaml:"world_stats"`         // World statistics
}

// WorldStats tracks various world statistics
type WorldStats struct {
        TotalPlayers  int `yaml:"stat_total_players"`  // Total number of players
        ActiveNPCs    int `yaml:"stat_active_npcs"`    // Current active NPCs
        LoadedObjects int `yaml:"stat_loaded_objects"` // Total loaded objects
        ActiveQuests  int `yaml:"stat_active_quests"`  // Current active quests
        WorldAge      int `yaml:"stat_world_age"`      // Time since world creation
}

// WorldConfig represents world configuration settings
type WorldConfig struct {
        MaxPlayers      int      `yaml:"config_max_players"`      // Maximum allowed players
        MaxLevel        int      `yaml:"config_max_level"`        // Maximum character level
        StartingLevel   string   `yaml:"config_starting_level"`   // Initial player level ID
        EnabledFeatures []string `yaml:"config_enabled_features"` // Enabled world features
}

// NewWorld creates a new game world instance
func NewWorld() *World <span class="cov8" title="1">{
        return &amp;World{
                Objects:      make(map[string]GameObject),
                Players:      make(map[string]*Player),
                NPCs:         make(map[string]*NPC),
                SpatialGrid:  make(map[Position][]string),
                SpatialIndex: nil, // Initialize as nil by default to maintain compatibility
                Width:        0,   // Default width 0 for compatibility
                Height:       0,   // Default height 0 for compatibility
        }
}</span>

// NewWorldWithSize creates a new game world instance with specified dimensions
func NewWorldWithSize(width, height, cellSize int) *World <span class="cov8" title="1">{
        return &amp;World{
                Objects:      make(map[string]GameObject),
                Players:      make(map[string]*Player),
                NPCs:         make(map[string]*NPC),
                SpatialGrid:  make(map[Position][]string),
                SpatialIndex: NewSpatialIndex(width, height, cellSize),
                Width:        width,
                Height:       height,
        }
}</span>

// AddObject safely adds a GameObject to the world
func (w *World) AddObject(obj GameObject) error <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        if _, exists := w.Objects[obj.GetID()]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("object with ID %s already exists", obj.GetID())
        }</span>

        <span class="cov8" title="1">w.Objects[obj.GetID()] = obj

        // Update legacy spatial grid for compatibility
        pos := obj.GetPosition()
        w.SpatialGrid[pos] = append(w.SpatialGrid[pos], obj.GetID())

        // Update advanced spatial index
        if w.SpatialIndex != nil </span><span class="cov8" title="1">{
                if err := w.SpatialIndex.Insert(obj); err != nil </span><span class="cov0" title="0">{
                        // If spatial index fails, we still keep the object in Objects map
                        // This ensures compatibility even if spatial indexing has issues
                        return fmt.Errorf("failed to add object to spatial index: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetObjectsAt returns all objects at a given position
func (w *World) GetObjectsAt(pos Position) []GameObject <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        var objects []GameObject
        for _, id := range w.SpatialGrid[pos] </span><span class="cov8" title="1">{
                if obj, exists := w.Objects[id]; exists </span><span class="cov8" title="1">{
                        objects = append(objects, obj)
                }</span>
        }

        <span class="cov8" title="1">return objects</span>
}

// ValidateMove checks if the move is valid for the given player and position
func (w *World) ValidateMove(player *Player, newPos Position) error <span class="cov8" title="1">{
        // Check if the new position is within the bounds of the world
        if !w.isPositionWithinBounds(newPos) </span><span class="cov8" title="1">{
                return fmt.Errorf("position out of bounds")
        }</span>

        // Check if the new position is occupied by an obstacle
        <span class="cov8" title="1">objectsAtNewPos := w.GetObjectsAt(newPos)
        for _, obj := range objectsAtNewPos </span><span class="cov8" title="1">{
                if obj.IsObstacle() </span><span class="cov8" title="1">{
                        return fmt.Errorf("position occupied by an obstacle")
                }</span>
        }

        // Additional validation logic can be added here (e.g., checking player abilities)

        <span class="cov8" title="1">return nil</span>
}

// isPositionWithinBounds checks if the given position is within the bounds of the world
func (w *World) isPositionWithinBounds(pos Position) bool <span class="cov8" title="1">{
        // Implement the logic to check if the position is within the bounds of the world
        return pos.X &gt;= 0 &amp;&amp; pos.X &lt; w.Width &amp;&amp; pos.Y &gt;= 0 &amp;&amp; pos.Y &lt; w.Height
}</span>

// Serialize returns a map representation of the World state
func (w *World) Serialize() map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "objects": w.Objects,
        }
}</span>

// GetObjectsInRange returns all objects within a rectangular area using advanced spatial indexing
func (w *World) GetObjectsInRange(rect Rectangle) []GameObject <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        if w.SpatialIndex != nil </span><span class="cov8" title="1">{
                return w.SpatialIndex.GetObjectsInRange(rect)
        }</span>

        // Fallback to legacy method if spatial index not available
        <span class="cov8" title="1">var objects []GameObject
        for _, obj := range w.Objects </span><span class="cov8" title="1">{
                pos := obj.GetPosition()
                if pos.X &gt;= rect.MinX &amp;&amp; pos.X &lt;= rect.MaxX &amp;&amp;
                        pos.Y &gt;= rect.MinY &amp;&amp; pos.Y &lt;= rect.MaxY </span><span class="cov8" title="1">{
                        objects = append(objects, obj)
                }</span>
        }
        <span class="cov8" title="1">return objects</span>
}

// GetObjectsInRadius returns all objects within a circular area using advanced spatial indexing
func (w *World) GetObjectsInRadius(center Position, radius float64) []GameObject <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        if w.SpatialIndex != nil </span><span class="cov8" title="1">{
                return w.SpatialIndex.GetObjectsInRadius(center, radius)
        }</span>

        // Fallback to legacy method if spatial index not available
        <span class="cov8" title="1">var objects []GameObject
        for _, obj := range w.Objects </span><span class="cov8" title="1">{
                pos := obj.GetPosition()
                dx := float64(center.X - pos.X)
                dy := float64(center.Y - pos.Y)
                distance := math.Sqrt(dx*dx + dy*dy)
                if distance &lt;= radius </span><span class="cov8" title="1">{
                        objects = append(objects, obj)
                }</span>
        }
        <span class="cov8" title="1">return objects</span>
}

// GetNearestObjects returns the k nearest objects to a given position using advanced spatial indexing
func (w *World) GetNearestObjects(center Position, k int) []GameObject <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        if w.SpatialIndex != nil </span><span class="cov8" title="1">{
                return w.SpatialIndex.GetNearestObjects(center, k)
        }</span>

        // Fallback to legacy method if spatial index not available
        <span class="cov8" title="1">type objectDistance struct {
                obj      GameObject
                distance float64
        }

        var candidates []objectDistance
        for _, obj := range w.Objects </span><span class="cov8" title="1">{
                pos := obj.GetPosition()
                dx := float64(center.X - pos.X)
                dy := float64(center.Y - pos.Y)
                distance := math.Sqrt(dx*dx + dy*dy)
                candidates = append(candidates, objectDistance{obj, distance})
        }</span>

        // Simple bubble sort for small k values
        <span class="cov8" title="1">for i := 0; i &lt; len(candidates)-1; i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(candidates); j++ </span><span class="cov8" title="1">{
                        if candidates[i].distance &gt; candidates[j].distance </span><span class="cov0" title="0">{
                                candidates[i], candidates[j] = candidates[j], candidates[i]
                        }</span>
                }
        }

        <span class="cov8" title="1">var result []GameObject
        limit := k
        if len(candidates) &lt; k </span><span class="cov0" title="0">{
                limit = len(candidates)
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; limit; i++ </span><span class="cov8" title="1">{
                result = append(result, candidates[i].obj)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// UpdateObjectPosition updates an object's position in both legacy and advanced spatial indexes
func (w *World) UpdateObjectPosition(objectID string, newPos Position) error <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        obj, oldPos, err := w.validateAndGetObject(objectID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := w.updateObjectPositionWithBounds(obj, newPos); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">w.updateLegacySpatialGrid(objectID, oldPos, newPos)

        if err := w.updateAdvancedSpatialIndex(objectID, newPos); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateAndGetObject checks if the object exists and returns it along with its current position.
func (w *World) validateAndGetObject(objectID string) (GameObject, Position, error) <span class="cov8" title="1">{
        obj, exists := w.Objects[objectID]
        if !exists </span><span class="cov0" title="0">{
                return nil, Position{}, fmt.Errorf("object with ID %s not found", objectID)
        }</span>
        <span class="cov8" title="1">return obj, obj.GetPosition(), nil</span>
}

// updateObjectPositionWithBounds sets the object position using bounds validation when available.
func (w *World) updateObjectPositionWithBounds(obj GameObject, newPos Position) error <span class="cov8" title="1">{
        type boundsSetter interface {
                SetPositionWithBounds(Position, int, int, int) error
        }

        if c, ok := obj.(boundsSetter); ok </span><span class="cov8" title="1">{
                if err := c.SetPositionWithBounds(newPos, w.Width, w.Height, 1); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set object position: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                if err := obj.SetPosition(newPos); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set object position: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// updateLegacySpatialGrid removes the object from its old position and adds it to the new position in the spatial grid.
func (w *World) updateLegacySpatialGrid(objectID string, oldPos, newPos Position) <span class="cov8" title="1">{
        w.removeObjectFromSpatialGrid(objectID, oldPos)
        w.addObjectToSpatialGrid(objectID, newPos)
}</span>

// removeObjectFromSpatialGrid removes an object from the specified position in the spatial grid.
func (w *World) removeObjectFromSpatialGrid(objectID string, pos Position) <span class="cov8" title="1">{
        if oldObjects, exists := w.SpatialGrid[pos]; exists </span><span class="cov8" title="1">{
                for i, id := range oldObjects </span><span class="cov8" title="1">{
                        if id == objectID </span><span class="cov8" title="1">{
                                w.SpatialGrid[pos] = append(oldObjects[:i], oldObjects[i+1:]...)
                                break</span>
                        }
                }
                <span class="cov8" title="1">if len(w.SpatialGrid[pos]) == 0 </span><span class="cov8" title="1">{
                        delete(w.SpatialGrid, pos)
                }</span>
        }
}

// addObjectToSpatialGrid adds an object to the specified position in the spatial grid.
func (w *World) addObjectToSpatialGrid(objectID string, pos Position) <span class="cov8" title="1">{
        w.SpatialGrid[pos] = append(w.SpatialGrid[pos], objectID)
}</span>

// updateAdvancedSpatialIndex updates the object position in the advanced spatial index if available.
func (w *World) updateAdvancedSpatialIndex(objectID string, newPos Position) error <span class="cov8" title="1">{
        if w.SpatialIndex != nil </span><span class="cov8" title="1">{
                if err := w.SpatialIndex.Update(objectID, newPos); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update object in spatial index: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// RemoveObject safely removes a GameObject from the world and all spatial indexes
func (w *World) RemoveObject(objectID string) error <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        obj, exists := w.Objects[objectID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("object with ID %s not found", objectID)
        }</span>

        <span class="cov8" title="1">pos := obj.GetPosition()

        // Remove from objects map
        delete(w.Objects, objectID)

        // Remove from legacy spatial grid
        if objects, exists := w.SpatialGrid[pos]; exists </span><span class="cov8" title="1">{
                for i, id := range objects </span><span class="cov8" title="1">{
                        if id == objectID </span><span class="cov8" title="1">{
                                w.SpatialGrid[pos] = append(objects[:i], objects[i+1:]...)
                                break</span>
                        }
                }
                <span class="cov8" title="1">if len(w.SpatialGrid[pos]) == 0 </span><span class="cov8" title="1">{
                        delete(w.SpatialGrid, pos)
                }</span>
        }

        // Remove from advanced spatial index
        <span class="cov8" title="1">if w.SpatialIndex != nil </span><span class="cov8" title="1">{
                if err := w.SpatialIndex.Remove(objectID); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove object from spatial index: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetSpatialIndexStats returns performance statistics for the spatial indexing system
func (w *World) GetSpatialIndexStats() *SpatialIndexStats <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        if w.SpatialIndex != nil </span><span class="cov8" title="1">{
                stats := w.SpatialIndex.GetStats()
                return &amp;stats
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package game

import "time"

// Level represents a game level/map with its dimensions, layout and properties.
// A level contains a 2D grid of Tiles and can be loaded from YAML configuration.
//
// Fields:
//   - ID: Unique string identifier for the level
//   - Name: Human readable display name for the level
//   - Width: Level width in number of tiles (must be &gt; 0)
//   - Height: Level height in number of tiles (must be &gt; 0)
//   - Tiles: 2D slice containing the level's tile grid, dimensions must match Width x Height
//   - Properties: Map of custom level attributes for game-specific data
//
// Related types:
//   - Tile: Individual map tile type used in the Tiles grid
//
// Usage:
//
//        level := &amp;Level{
//          ID: "level1",
//          Name: "Tutorial Level",
//          Width: 10,
//          Height: 10,
//          Tiles: make([][]Tile, height),
//          Properties: make(map[string]interface{}),
//        }
type Level struct {
        ID         string                 `yaml:"level_id"`         // Unique level identifier
        Name       string                 `yaml:"level_name"`       // Display name of the level
        Width      int                    `yaml:"level_width"`      // Width in tiles
        Height     int                    `yaml:"level_height"`     // Height in tiles
        Tiles      [][]Tile               `yaml:"level_tiles"`      // 2D grid of map tiles
        Properties map[string]interface{} `yaml:"level_properties"` // Custom level attributes
}

// GameTime represents the in-game time system and manages game time progression
// Handles conversion between real time and game time using a configurable scale factor.
//
// Fields:
//   - RealTime: System time when game time was last updated
//   - GameTicks: Counter tracking elapsed game time units
//   - TimeScale: Multiplier for converting real time to game time (1.0 = realtime)
//
// Usage:
//
//        gameTime := &amp;GameTime{
//          RealTime: time.Now(),
//          GameTicks: 0,
//          TimeScale: 2.0, // Game time passes 2x faster than real time
//        }
//
// Related types:
//   - Level: Game levels track time for events and updates
//   - NPC: NPCs use game time for behavior and schedules
type GameTime struct {
        RealTime  time.Time `yaml:"time_real"`  // Actual system time
        GameTicks int64     `yaml:"time_ticks"` // Internal game time counter
        TimeScale float64   `yaml:"time_scale"` // Game/real time ratio
}

// GetCombatTurn returns the current combat round and turn index.
func (gt *GameTime) GetCombatTurn() (round, index int) <span class="cov8" title="1">{
        ticksPerTurn := int64(10) // 10 second turns
        totalTurns := gt.GameTicks / ticksPerTurn
        round = int(totalTurns / 6) // 6 turns per round
        index = int(totalTurns % 6)
        return
}</span>

// IsSameTurn checks if this GameTime represents the same combat turn as another.
func (gt *GameTime) IsSameTurn(other GameTime) bool <span class="cov8" title="1">{
        r1, i1 := gt.GetCombatTurn()
        r2, i2 := other.GetCombatTurn()
        return r1 == r2 &amp;&amp; i1 == i2
}</span>

// NPC represents a non-player character in the game world
// Extends the base Character type with AI behaviors and interaction capabilities
//
// Fields:
//   - Character: Embedded base character attributes (health, stats, inventory etc)
//   - Behavior: AI behavior pattern ID determining how NPC acts (e.g. "guard", "merchant")
//   - Faction: Group allegiance affecting NPC relationships and interactions
//   - Dialog: Available conversation options when player interacts with NPC
//   - LootTable: Items that may be dropped when NPC dies
//
// Related types:
//   - Character: Base type providing core character functionality
//   - DialogEntry: Defines conversation nodes and options
//   - LootEntry: Defines droppable items and probabilities
//
// Usage:
//
//        npc := &amp;NPC{
//          Character: Character{Name: "Guard"},
//          Behavior: "patrol",
//          Faction: "town_guard",
//          Dialog: []DialogEntry{...},
//          LootTable: []LootEntry{...},
//        }
type NPC struct {
        Character `yaml:",inline"` // Base character attributes
        Behavior  string           `yaml:"npc_behavior"`   // AI behavior pattern
        Faction   string           `yaml:"npc_faction"`    // Allegiance group
        Dialog    []DialogEntry    `yaml:"npc_dialog"`     // Conversation options
        LootTable []LootEntry      `yaml:"npc_loot_table"` // Droppable items
}

// DialogEntry represents a single dialog interaction node in the game's conversation system.
// It contains the text spoken by an NPC, possible player responses, and conditions that must
// be met for this dialog to be available.
//
// Fields:
//   - ID: A unique string identifier for this dialog entry
//   - Text: The actual dialog text spoken by the NPC
//   - Responses: A slice of DialogResponse objects representing possible player choices
//   - Conditions: A slice of DialogCondition objects that must be satisfied for this dialog to appear
//
// Related types:
//   - DialogResponse: Represents a player's response option
//   - DialogCondition: Defines requirements that must be met
//
// Usage:
// Dialog entries are typically loaded from YAML configuration files and used by the
// dialog system to present NPC conversations to the player.
type DialogEntry struct {
        ID         string            `yaml:"dialog_id"`         // Unique dialog identifier
        Text       string            `yaml:"dialog_text"`       // NPC's spoken text
        Responses  []DialogResponse  `yaml:"dialog_responses"`  // Player response options
        Conditions []DialogCondition `yaml:"dialog_conditions"` // Requirements to show dialog
}

// DialogResponse represents a player conversation choice
// DialogResponse represents a player's response option in a dialog system.
// It contains the text shown to the player, the ID of the next dialog to trigger,
// and any associated game action to execute when this response is chosen.
//
// Fields:
//   - Text: The response text shown to the player as a dialog choice
//   - NextDialog: ID reference to the next dialog that should be triggered when this response is selected
//   - Action: Optional action identifier that will be executed when this response is chosen
//
// This struct is typically used as part of a larger Dialog structure to create branching conversations.
// The NextDialog field enables creating dialog trees by linking responses to subsequent dialog nodes.
type DialogResponse struct {
        Text       string `yaml:"response_text"`        // Player's response text
        NextDialog string `yaml:"response_next_dialog"` // Following dialog ID
        Action     string `yaml:"response_action"`      // Triggered action
}

// DialogCondition represents requirements for dialog options
// DialogCondition represents a condition that must be met for a dialog option or event to occur.
// It consists of a condition type and an associated value that needs to be satisfied.
//
// Fields:
//   - Type: The type of condition to check (e.g. "quest_complete", "has_item", etc.)
//   - Value: The required value or state for the condition to be met. Can be of any type
//     depending on the condition type.
//
// The specific validation and handling of conditions depends on the condition type.
// Custom condition types can be defined by implementing appropriate handlers.
type DialogCondition struct {
        Type  string      `yaml:"condition_type"`  // Type of condition
        Value interface{} `yaml:"condition_value"` // Required value/state
}

// LootEntry represents a single item drop configuration in the game's loot system.
// It defines the probability and quantity range for a specific item that can be obtained.
//
// Fields:
//   - ItemID: Unique identifier string for the item that can be dropped
//   - Chance: Float value between 0.0 and 1.0 representing drop probability percentage
//   - MinQuantity: Minimum number of items that can drop (must be &gt;= 0)
//   - MaxQuantity: Maximum number of items that can drop (must be &gt;= MinQuantity)
//
// Related types:
//   - Item - The actual item definition this entry references
//   - LootTable - Collection of LootEntry that defines all possible drops
type LootEntry struct {
        ItemID      string  `yaml:"loot_item_id"`      // Item identifier
        Chance      float64 `yaml:"loot_chance"`       // Drop probability
        MinQuantity int     `yaml:"loot_min_quantity"` // Minimum amount
        MaxQuantity int     `yaml:"loot_max_quantity"` // Maximum amount
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"

        "goldbox-rpg/pkg/game"
        "goldbox-rpg/pkg/pcg"

        "github.com/sirupsen/logrus"
)

// Demo script to showcase the Performance Metrics and Monitoring system
func main() <span class="cov0" title="0">{
        fmt.Println("=== PCG Performance Metrics Demo ===")

        // Create a test world
        world := &amp;game.World{
                Objects: make(map[string]game.GameObject),
                Levels:  []game.Level{},
                Players: make(map[string]*game.Player),
        }

        // Create logger with info level for demo
        logger := logrus.New()
        logger.SetLevel(logrus.InfoLevel)

        // Create PCG manager
        pcgManager := pcg.NewPCGManager(world, logger)
        pcgManager.InitializeWithSeed(12345)

        fmt.Println("PCG Manager initialized with seed 12345")

        // Get initial metrics (should be empty)
        fmt.Println("\n=== Initial Metrics ===")
        printMetrics(pcgManager.GetMetrics())

        // Perform several generations to populate metrics
        ctx := context.Background()

        fmt.Println("\n=== Performing Content Generation ===")

        // Generate terrain multiple times
        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                levelID := fmt.Sprintf("level_%d", i+1)
                fmt.Printf("Generating terrain for %s...\n", levelID)

                _, err := pcgManager.GenerateTerrainForLevel(ctx, levelID, 20, 20, pcg.BiomeCave, 5)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error generating terrain: %v\n", err)
                }</span>
        }

        // Generate items multiple times
        <span class="cov0" title="0">for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                locationID := fmt.Sprintf("location_%d", i+1)
                fmt.Printf("Generating items for %s...\n", locationID)

                _, err := pcgManager.GenerateItemsForLocation(ctx, locationID, 3, pcg.RarityCommon, pcg.RarityRare, 5)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error generating items: %v\n", err)
                }</span>
        }

        // Simulate cache hits and misses
        <span class="cov0" title="0">metrics := pcgManager.GetMetrics()
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                if i%3 == 0 </span><span class="cov0" title="0">{
                        metrics.RecordCacheMiss()
                }</span> else<span class="cov0" title="0"> {
                        metrics.RecordCacheHit()
                }</span>
        }

        // Show final metrics
        <span class="cov0" title="0">fmt.Println("\n=== Final Metrics ===")
        printMetrics(metrics)

        // Show generation statistics from manager
        fmt.Println("\n=== Manager Statistics ===")
        stats := pcgManager.GetGenerationStatistics()
        prettyPrint(stats)

        // Demonstrate metrics reset
        fmt.Println("\n=== Resetting Metrics ===")
        pcgManager.ResetMetrics()
        fmt.Println("Metrics after reset:")
        printMetrics(pcgManager.GetMetrics())

        fmt.Println("\n=== Demo Complete ===")</span>
}

func printMetrics(metrics *pcg.GenerationMetrics) <span class="cov0" title="0">{
        fmt.Printf("Total Generations: %d\n", metrics.TotalGenerations)
        fmt.Printf("Cache Hit Ratio: %.2f%%\n", metrics.GetCacheHitRatio())

        // Print per-content-type metrics
        contentTypes := []pcg.ContentType{
                pcg.ContentTypeTerrain,
                pcg.ContentTypeItems,
                pcg.ContentTypeLevels,
                pcg.ContentTypeQuests,
        }

        for _, contentType := range contentTypes </span><span class="cov0" title="0">{
                count := metrics.GetGenerationCount(contentType)
                if count &gt; 0 </span><span class="cov0" title="0">{
                        avgTime := metrics.GetAverageTiming(contentType)
                        errorCount := metrics.GetErrorCount(contentType)
                        fmt.Printf("  %s: %d generations, avg time: %v, errors: %d\n",
                                contentType, count, avgTime, errorCount)
                }</span>
        }
}

func prettyPrint(data interface{}) <span class="cov0" title="0">{
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error marshaling data: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">fmt.Println(string(jsonData))</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package items

import (
        "fmt"
        "math/rand"

        "goldbox-rpg/pkg/game"

        "goldbox-rpg/pkg/pcg"
)

// EnchantmentSystem manages procedural enchantments
type EnchantmentSystem struct {
        enchantments map[string]*pcg.EnchantmentTemplate
        schools      map[string][]string // Magic school -&gt; enchantment list
        rng          *rand.Rand
}

// NewEnchantmentSystem creates a new enchantment system
func NewEnchantmentSystem() *EnchantmentSystem <span class="cov8" title="1">{
        es := &amp;EnchantmentSystem{
                enchantments: make(map[string]*pcg.EnchantmentTemplate),
                schools:      make(map[string][]string),
        }

        // Load default enchantments
        es.loadDefaultEnchantments()

        return es
}</span>

// SetSeed sets the random seed for enchantment generation
func (es *EnchantmentSystem) SetSeed(seed int64) <span class="cov8" title="1">{
        es.rng = rand.New(rand.NewSource(seed))
}</span>

// ApplyEnchantments adds procedural enchantments to an item
func (es *EnchantmentSystem) ApplyEnchantments(item *game.Item, rarity pcg.RarityTier, playerLevel int, rng *rand.Rand) error <span class="cov8" title="1">{
        if rng == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("random generator is nil")
        }</span>

        <span class="cov8" title="1">es.rng = rng

        // Get rarity modifier to determine enchantment parameters
        registry := NewItemTemplateRegistry()
        registry.LoadDefaultTemplates()
        modifier := registry.GetRarityModifier(rarity)

        // Check if we should add enchantments
        if es.rng.Float64() &gt; modifier.EnchantmentChance </span><span class="cov8" title="1">{
                return nil // No enchantments for this item
        }</span>

        // Determine number of enchantments
        <span class="cov8" title="1">numEnchantments := 1
        if modifier.MaxEnchantments &gt; 1 </span><span class="cov8" title="1">{
                numEnchantments = 1 + es.rng.Intn(modifier.MaxEnchantments)
        }</span>

        // Get available enchantments for this item type
        <span class="cov8" title="1">availableEnchants := es.GetAvailableEnchantments(item.Type, 1, playerLevel)
        if len(availableEnchants) == 0 </span><span class="cov0" title="0">{
                return nil // No available enchantments
        }</span>

        // Apply enchantments
        <span class="cov8" title="1">appliedEnchants := make(map[string]bool) // Track to avoid duplicates
        for i := 0; i &lt; numEnchantments &amp;&amp; len(appliedEnchants) &lt; len(availableEnchants); i++ </span><span class="cov8" title="1">{
                // Select random enchantment
                enchant := availableEnchants[es.rng.Intn(len(availableEnchants))]

                // Skip if already applied
                if appliedEnchants[enchant.Name] </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Apply enchantment effects
                <span class="cov8" title="1">if err := es.applyEnchantmentToItem(item, enchant, playerLevel); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip failed enchantments
                }

                <span class="cov8" title="1">appliedEnchants[enchant.Name] = true

                // Update item name if this is the first enchantment
                if len(appliedEnchants) == 1 </span><span class="cov8" title="1">{
                        item.Name = enchant.Name + " " + item.Name
                }</span>
        }

        // Update item value based on enchantments
        <span class="cov8" title="1">enchantmentMultiplier := 1.0 + (0.5 * float64(len(appliedEnchants)))
        item.Value = int(float64(item.Value) * enchantmentMultiplier)

        return nil</span>
}

// GetAvailableEnchantments returns enchantments valid for item type
func (es *EnchantmentSystem) GetAvailableEnchantments(itemType string, minLevel, maxLevel int) []*pcg.EnchantmentTemplate <span class="cov8" title="1">{
        var available []*pcg.EnchantmentTemplate

        for _, enchant := range es.enchantments </span><span class="cov8" title="1">{
                // Check level requirements
                if enchant.MinLevel &gt; maxLevel || enchant.MaxLevel &lt; minLevel </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check item type compatibility
                <span class="cov8" title="1">if es.isEnchantmentCompatible(enchant, itemType) </span><span class="cov8" title="1">{
                        available = append(available, enchant)
                }</span>
        }

        <span class="cov8" title="1">return available</span>
}

// applyEnchantmentToItem applies a specific enchantment to an item
func (es *EnchantmentSystem) applyEnchantmentToItem(item *game.Item, enchant *pcg.EnchantmentTemplate, playerLevel int) error <span class="cov8" title="1">{
        // Apply effects based on enchantment type
        switch enchant.Type </span>{
        case "weapon_bonus":<span class="cov8" title="1">
                return es.applyWeaponBonus(item, enchant, playerLevel)</span>
        case "armor_bonus":<span class="cov0" title="0">
                return es.applyArmorBonus(item, enchant, playerLevel)</span>
        case "damage_type":<span class="cov8" title="1">
                return es.applyDamageType(item, enchant, playerLevel)</span>
        case "resistance":<span class="cov8" title="1">
                return es.applyResistance(item, enchant, playerLevel)</span>
        default:<span class="cov0" title="0">
                // Generic property addition
                return es.applyGenericEnchantment(item, enchant, playerLevel)</span>
        }
}

// applyWeaponBonus applies weapon enhancement enchantments
func (es *EnchantmentSystem) applyWeaponBonus(item *game.Item, enchant *pcg.EnchantmentTemplate, playerLevel int) error <span class="cov8" title="1">{
        if item.Type != "weapon" </span><span class="cov0" title="0">{
                return fmt.Errorf("weapon bonus applied to non-weapon")
        }</span>

        // Add weapon enhancement property
        <span class="cov8" title="1">bonus := 1 + (playerLevel / 5) // +1 per 5 levels
        if bonus &gt; 5 </span><span class="cov0" title="0">{
                bonus = 5 // Cap at +5
        }</span>

        <span class="cov8" title="1">enchantProp := fmt.Sprintf("+%d enhancement", bonus)
        item.Properties = append(item.Properties, enchantProp)

        return nil</span>
}

// applyArmorBonus applies armor enhancement enchantments
func (es *EnchantmentSystem) applyArmorBonus(item *game.Item, enchant *pcg.EnchantmentTemplate, playerLevel int) error <span class="cov8" title="1">{
        if item.Type != "armor" </span><span class="cov0" title="0">{
                return fmt.Errorf("armor bonus applied to non-armor")
        }</span>

        // Increase AC
        <span class="cov8" title="1">bonus := 1 + (playerLevel / 4) // +1 per 4 levels
        if bonus &gt; 3 </span><span class="cov0" title="0">{
                bonus = 3 // Cap at +3
        }</span>

        <span class="cov8" title="1">item.AC += bonus
        enchantProp := fmt.Sprintf("+%d armor", bonus)
        item.Properties = append(item.Properties, enchantProp)

        return nil</span>
}

// applyDamageType applies elemental damage enchantments
func (es *EnchantmentSystem) applyDamageType(item *game.Item, enchant *pcg.EnchantmentTemplate, playerLevel int) error <span class="cov8" title="1">{
        if item.Type != "weapon" </span><span class="cov0" title="0">{
                return fmt.Errorf("damage type applied to non-weapon")
        }</span>

        <span class="cov8" title="1">elements := []string{"fire", "cold", "lightning", "acid"}
        element := elements[es.rng.Intn(len(elements))]

        damageDice := 1 + (playerLevel / 3) // Additional dice every 3 levels
        if damageDice &gt; 6 </span><span class="cov0" title="0">{
                damageDice = 6
        }</span>

        <span class="cov8" title="1">enchantProp := fmt.Sprintf("+%dd6 %s", damageDice, element)
        item.Properties = append(item.Properties, enchantProp)

        return nil</span>
}

// applyResistance applies resistance enchantments
func (es *EnchantmentSystem) applyResistance(item *game.Item, enchant *pcg.EnchantmentTemplate, playerLevel int) error <span class="cov8" title="1">{
        if item.Type != "armor" </span><span class="cov0" title="0">{
                return fmt.Errorf("resistance applied to non-armor")
        }</span>

        <span class="cov8" title="1">resistances := []string{"fire", "cold", "lightning", "acid", "necrotic"}
        resistance := resistances[es.rng.Intn(len(resistances))]

        enchantProp := fmt.Sprintf("resistance %s", resistance)
        item.Properties = append(item.Properties, enchantProp)

        return nil</span>
}

// applyGenericEnchantment applies generic property enchantments
func (es *EnchantmentSystem) applyGenericEnchantment(item *game.Item, enchant *pcg.EnchantmentTemplate, playerLevel int) error <span class="cov0" title="0">{
        // Add enchantment name as property
        item.Properties = append(item.Properties, enchant.Name)
        return nil
}</span>

// isEnchantmentCompatible checks if enchantment works with item type
func (es *EnchantmentSystem) isEnchantmentCompatible(enchant *pcg.EnchantmentTemplate, itemType string) bool <span class="cov8" title="1">{
        switch enchant.Type </span>{
        case "weapon_bonus", "damage_type":<span class="cov8" title="1">
                return itemType == "weapon"</span>
        case "armor_bonus", "resistance":<span class="cov8" title="1">
                return itemType == "armor"</span>
        case "utility", "generic":<span class="cov8" title="1">
                return true</span> // Compatible with all items
        default:<span class="cov0" title="0">
                return true</span> // Default to compatible
        }
}

// loadDefaultEnchantments loads built-in enchantment templates
func (es *EnchantmentSystem) loadDefaultEnchantments() <span class="cov8" title="1">{
        // Weapon enchantments
        es.enchantments["enhancement"] = &amp;pcg.EnchantmentTemplate{
                Name:     "Enhancement",
                Type:     "weapon_bonus",
                MinLevel: 1,
                MaxLevel: 20,
                Effects:  []game.Effect{}, // Effects would be defined if we had the Effect system
                Restrictions: map[string]interface{}{
                        "item_types": []string{"weapon"},
                },
        }

        es.enchantments["flaming"] = &amp;pcg.EnchantmentTemplate{
                Name:     "Flaming",
                Type:     "damage_type",
                MinLevel: 3,
                MaxLevel: 20,
                Effects:  []game.Effect{},
                Restrictions: map[string]interface{}{
                        "item_types": []string{"weapon"},
                        "elements":   []string{"fire"},
                },
        }

        es.enchantments["frost"] = &amp;pcg.EnchantmentTemplate{
                Name:     "Frost",
                Type:     "damage_type",
                MinLevel: 3,
                MaxLevel: 20,
                Effects:  []game.Effect{},
                Restrictions: map[string]interface{}{
                        "item_types": []string{"weapon"},
                        "elements":   []string{"cold"},
                },
        }

        es.enchantments["shock"] = &amp;pcg.EnchantmentTemplate{
                Name:     "Shock",
                Type:     "damage_type",
                MinLevel: 3,
                MaxLevel: 20,
                Effects:  []game.Effect{},
                Restrictions: map[string]interface{}{
                        "item_types": []string{"weapon"},
                        "elements":   []string{"lightning"},
                },
        }

        // Armor enchantments
        es.enchantments["protection"] = &amp;pcg.EnchantmentTemplate{
                Name:     "Protection",
                Type:     "armor_bonus",
                MinLevel: 1,
                MaxLevel: 20,
                Effects:  []game.Effect{},
                Restrictions: map[string]interface{}{
                        "item_types": []string{"armor"},
                },
        }

        es.enchantments["fire_resistance"] = &amp;pcg.EnchantmentTemplate{
                Name:     "Fire Resistance",
                Type:     "resistance",
                MinLevel: 5,
                MaxLevel: 20,
                Effects:  []game.Effect{},
                Restrictions: map[string]interface{}{
                        "item_types": []string{"armor"},
                        "elements":   []string{"fire"},
                },
        }

        // Set up magic schools
        es.schools["evocation"] = []string{"flaming", "frost", "shock"}
        es.schools["abjuration"] = []string{"protection", "fire_resistance"}
        es.schools["transmutation"] = []string{"enhancement"}
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package items

import (
        "context"
        "fmt"
        "math/rand"

        "goldbox-rpg/pkg/game"
        "goldbox-rpg/pkg/pcg"
)

// TemplateBasedGenerator generates items using template system
type TemplateBasedGenerator struct {
        version   string
        templates map[string]*pcg.ItemTemplate
        registry  *ItemTemplateRegistry
        enchants  *EnchantmentSystem
        rng       *rand.Rand
}

// NewTemplateBasedGenerator creates a new template-based item generator
func NewTemplateBasedGenerator() *TemplateBasedGenerator <span class="cov8" title="1">{
        tbg := &amp;TemplateBasedGenerator{
                version:   "1.0.0",
                templates: make(map[string]*pcg.ItemTemplate),
                registry:  NewItemTemplateRegistry(),
                enchants:  NewEnchantmentSystem(),
        }

        // Load default templates
        if err := tbg.registry.LoadDefaultTemplates(); err != nil </span>{<span class="cov0" title="0">
                // Log error but continue - this is handled in actual usage
        }</span>

        <span class="cov8" title="1">return tbg</span>
}

// SetSeed sets the random seed for deterministic generation
func (tbg *TemplateBasedGenerator) SetSeed(seed int64) <span class="cov8" title="1">{
        tbg.rng = rand.New(rand.NewSource(seed))
        tbg.enchants.SetSeed(seed + 1) // Offset for enchantment system
}</span>

// LoadTemplates loads item templates from YAML configuration
func (tbg *TemplateBasedGenerator) LoadTemplates(configPath string) error <span class="cov0" title="0">{
        return tbg.registry.LoadFromFile(configPath)
}</span>

// Generate implements the Generator interface
func (tbg *TemplateBasedGenerator) Generate(ctx context.Context, params pcg.GenerationParams) (interface{}, error) <span class="cov8" title="1">{
        // Initialize RNG if not set
        if tbg.rng == nil </span><span class="cov8" title="1">{
                tbg.SetSeed(params.Seed)
        }</span>

        // Create default item parameters
        <span class="cov8" title="1">itemParams := pcg.ItemParams{
                GenerationParams: params,
                MinRarity:        pcg.RarityCommon,
                MaxRarity:        pcg.RarityRare,
                ItemTypes:        []string{"sword", "bow", "armor", "potion"},
                EnchantmentRate:  0.3,
                UniqueChance:     0.1,
                LevelScaling:     true,
        }

        // Generate random item with constraints
        rarity := tbg.selectRandomRarity(itemParams.MinRarity, itemParams.MaxRarity)
        itemType := itemParams.ItemTypes[tbg.rng.Intn(len(itemParams.ItemTypes))]

        template, err := tbg.registry.GetTemplate(itemType, rarity)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get template: %w", err)
        }</span>

        <span class="cov8" title="1">item, err := tbg.GenerateItem(ctx, *template, itemParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate item: %w", err)
        }</span>

        <span class="cov8" title="1">return item, nil</span>
}

// GenerateItem creates a single item from template
func (tbg *TemplateBasedGenerator) GenerateItem(ctx context.Context, template pcg.ItemTemplate, params pcg.ItemParams) (*game.Item, error) <span class="cov8" title="1">{
        if tbg.rng == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("random generator not initialized")
        }</span>

        // Select rarity from params range
        <span class="cov8" title="1">rarity := tbg.selectRandomRarity(params.MinRarity, params.MaxRarity)

        // Create base item
        item := &amp;game.Item{
                ID:   generateItemID(),
                Type: template.BaseType,
        }

        // Generate procedural name
        item.Name = GenerateItemName(&amp;template, rarity, tbg.rng)

        // Roll stats within template ranges
        if err := tbg.applyStatRanges(item, template.StatRanges, params.PlayerLevel); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply stat ranges: %w", err)
        }</span>

        // Set base properties
        <span class="cov8" title="1">item.Properties = make([]string, len(template.Properties))
        copy(item.Properties, template.Properties)

        // Apply level scaling and rarity modifications
        if err := tbg.applyRarityModifications(item, rarity, &amp;template); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply rarity modifications: %w", err)
        }</span>

        // Add enchantments based on rarity and rate
        <span class="cov8" title="1">if tbg.rng.Float64() &lt; params.EnchantmentRate </span><span class="cov8" title="1">{
                if err := tbg.enchants.ApplyEnchantments(item, rarity, params.PlayerLevel, tbg.rng); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply enchantments: %w", err)
                }</span>
        }

        // Set appropriate value and weight
        <span class="cov8" title="1">tbg.calculateValueAndWeight(item, &amp;template, rarity)

        return item, nil</span>
}

// GenerateItemSet creates a collection of related items
func (tbg *TemplateBasedGenerator) GenerateItemSet(ctx context.Context, setType pcg.ItemSetType, params pcg.ItemParams) ([]*game.Item, error) <span class="cov8" title="1">{
        if tbg.rng == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("random generator not initialized")
        }</span>

        <span class="cov8" title="1">quantity := tbg.getDefaultSetSize(setType)

        items := make([]*game.Item, 0, quantity)
        itemTypes := tbg.getItemTypesForSet(setType)

        for i := 0; i &lt; quantity; i++ </span><span class="cov8" title="1">{
                // Select item type for this set
                itemType := itemTypes[tbg.rng.Intn(len(itemTypes))]

                // Select rarity from range
                rarity := tbg.selectRandomRarity(params.MinRarity, params.MaxRarity)

                // Get template and generate item
                template, err := tbg.registry.GetTemplate(itemType, rarity)
                if err != nil </span><span class="cov8" title="1">{
                        continue</span> // Skip items we can't generate
                }

                <span class="cov8" title="1">item, err := tbg.GenerateItem(ctx, *template, params)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip failed items
                }

                <span class="cov8" title="1">items = append(items, item)</span>
        }

        <span class="cov8" title="1">if len(items) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate any items for set type: %s", setType)
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}

// applyStatRanges applies template stat ranges to item
func (tbg *TemplateBasedGenerator) applyStatRanges(item *game.Item, ranges map[string]pcg.StatRange, playerLevel int) error <span class="cov8" title="1">{
        for statName, statRange := range ranges </span><span class="cov8" title="1">{
                // Calculate base value within range
                baseValue := statRange.Min + tbg.rng.Intn(statRange.Max-statRange.Min+1)

                // Apply level scaling
                scaledValue := int(float64(baseValue) * (1.0 + statRange.Scaling*float64(playerLevel)))

                // Apply stat to item based on stat name
                switch statName </span>{
                case "damage":<span class="cov8" title="1">
                        item.Damage = fmt.Sprintf("1d%d", scaledValue)</span>
                case "ac":<span class="cov0" title="0">
                        item.AC = scaledValue</span>
                case "weight":<span class="cov8" title="1">
                        item.Weight = scaledValue</span>
                case "value":<span class="cov8" title="1">
                        item.Value = scaledValue</span>
                default:<span class="cov8" title="1">
                        // Add as property for unknown stats
                        item.Properties = append(item.Properties, fmt.Sprintf("%s:%d", statName, scaledValue))</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// applyRarityModifications applies rarity-based modifications to item
func (tbg *TemplateBasedGenerator) applyRarityModifications(item *game.Item, rarity pcg.RarityTier, template *pcg.ItemTemplate) error <span class="cov8" title="1">{
        modifier := tbg.registry.GetRarityModifier(rarity)

        // Apply stat multipliers
        if item.AC &gt; 0 </span><span class="cov0" title="0">{
                item.AC = int(float64(item.AC) * modifier.StatMultiplier)
        }</span>

        // Parse and modify damage
        <span class="cov8" title="1">if item.Damage != "" </span><span class="cov8" title="1">{
                if newDamage := tbg.scaleDamage(item.Damage, modifier.StatMultiplier); newDamage != "" </span><span class="cov8" title="1">{
                        item.Damage = newDamage
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// calculateValueAndWeight sets final value and weight based on rarity
func (tbg *TemplateBasedGenerator) calculateValueAndWeight(item *game.Item, template *pcg.ItemTemplate, rarity pcg.RarityTier) <span class="cov8" title="1">{
        modifier := tbg.registry.GetRarityModifier(rarity)

        // Base value calculation if not set by stat ranges
        if item.Value &lt;= 0 </span><span class="cov0" title="0">{
                item.Value = 10 // Default base value
        }</span>

        // Apply rarity value multiplier
        <span class="cov8" title="1">item.Value = int(float64(item.Value) * modifier.ValueMultiplier)

        // Base weight calculation if not set by stat ranges
        if item.Weight &lt;= 0 </span><span class="cov8" title="1">{
                switch item.Type </span>{
                case "weapon":<span class="cov8" title="1">
                        item.Weight = 3</span>
                case "armor":<span class="cov0" title="0">
                        item.Weight = 10</span>
                case "consumable":<span class="cov0" title="0">
                        item.Weight = 1</span>
                default:<span class="cov0" title="0">
                        item.Weight = 2</span>
                }
        }
}

// scaleDamage scales damage strings by multiplier
func (tbg *TemplateBasedGenerator) scaleDamage(damage string, multiplier float64) string <span class="cov8" title="1">{
        // Simple scaling - could be more sophisticated
        if multiplier &gt; 1.0 </span><span class="cov8" title="1">{
                return damage + "+1" // Add bonus damage for higher rarities
        }</span>
        <span class="cov8" title="1">return damage</span>
}

// getDefaultSetSize returns default number of items for set type
func (tbg *TemplateBasedGenerator) getDefaultSetSize(setType pcg.ItemSetType) int <span class="cov8" title="1">{
        switch setType </span>{
        case pcg.ItemSetArmor:<span class="cov0" title="0">
                return 3</span> // helmet, armor, boots
        case pcg.ItemSetWeapons:<span class="cov8" title="1">
                return 2</span> // primary and secondary weapon
        case pcg.ItemSetJewelry:<span class="cov0" title="0">
                return 2</span> // ring and amulet
        case pcg.ItemSetConsumab:<span class="cov0" title="0">
                return 5</span> // various potions
        default:<span class="cov0" title="0">
                return 3</span>
        }
}

// getItemTypesForSet returns appropriate item types for set
func (tbg *TemplateBasedGenerator) getItemTypesForSet(setType pcg.ItemSetType) []string <span class="cov8" title="1">{
        switch setType </span>{
        case pcg.ItemSetArmor:<span class="cov0" title="0">
                return []string{"armor", "shield", "helmet"}</span>
        case pcg.ItemSetWeapons:<span class="cov8" title="1">
                return []string{"sword", "bow", "dagger", "staff"}</span>
        case pcg.ItemSetJewelry:<span class="cov0" title="0">
                return []string{"ring", "amulet", "bracelet"}</span>
        case pcg.ItemSetConsumab:<span class="cov0" title="0">
                return []string{"potion", "scroll", "elixir"}</span>
        case pcg.ItemSetTools:<span class="cov0" title="0">
                return []string{"tool", "kit", "instrument"}</span>
        default:<span class="cov0" title="0">
                return []string{"misc"}</span>
        }
}

// GetType returns the content type this generator produces
func (tbg *TemplateBasedGenerator) GetType() pcg.ContentType <span class="cov8" title="1">{
        return pcg.ContentTypeItems
}</span>

// GetVersion returns the generator version for compatibility checking
func (tbg *TemplateBasedGenerator) GetVersion() string <span class="cov8" title="1">{
        return tbg.version
}</span>

// Validate checks if the provided parameters are valid for this generator
func (tbg *TemplateBasedGenerator) Validate(params pcg.GenerationParams) error <span class="cov8" title="1">{
        if params.Seed == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("seed cannot be zero")
        }</span>

        <span class="cov8" title="1">if params.PlayerLevel &lt; 1 || params.PlayerLevel &gt; 20 </span><span class="cov8" title="1">{
                return fmt.Errorf("player level must be between 1 and 20")
        }</span>

        <span class="cov8" title="1">if params.Difficulty &lt; 1 || params.Difficulty &gt; 20 </span><span class="cov8" title="1">{
                return fmt.Errorf("difficulty must be between 1 and 20")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// generateItemID creates a unique identifier for items
func generateItemID() string <span class="cov8" title="1">{
        return fmt.Sprintf("item_%d", rand.Int63())
}</span>

// selectRandomRarity selects a random rarity within the given range
func (tbg *TemplateBasedGenerator) selectRandomRarity(minRarity, maxRarity pcg.RarityTier) pcg.RarityTier <span class="cov8" title="1">{
        rarities := []pcg.RarityTier{
                pcg.RarityCommon,
                pcg.RarityUncommon,
                pcg.RarityRare,
                pcg.RarityEpic,
                pcg.RarityLegendary,
                pcg.RarityArtifact,
        }

        // Find indices of min and max rarities
        minIndex := 0
        maxIndex := len(rarities) - 1

        for i, rarity := range rarities </span><span class="cov8" title="1">{
                if rarity == minRarity </span><span class="cov8" title="1">{
                        minIndex = i
                }</span>
                <span class="cov8" title="1">if rarity == maxRarity </span><span class="cov8" title="1">{
                        maxIndex = i
                }</span>
        }

        // Ensure valid range
        <span class="cov8" title="1">if maxIndex &lt; minIndex </span><span class="cov0" title="0">{
                maxIndex = minIndex
        }</span>

        // Select random rarity within range
        <span class="cov8" title="1">selectedIndex := minIndex + tbg.rng.Intn(maxIndex-minIndex+1)
        return rarities[selectedIndex]</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package items

import (
        "fmt"
        "math/rand"

        "goldbox-rpg/pkg/pcg"
)

// ItemTemplateRegistry manages available item templates
type ItemTemplateRegistry struct {
        templates       map[string]*pcg.ItemTemplate
        rarityModifiers map[pcg.RarityTier]RarityModifier
}

// RarityModifier defines how rarity affects item generation
type RarityModifier struct {
        StatMultiplier    float64  `yaml:"stat_multiplier"`
        EnchantmentChance float64  `yaml:"enchantment_chance"`
        MaxEnchantments   int      `yaml:"max_enchantments"`
        ValueMultiplier   float64  `yaml:"value_multiplier"`
        NamePrefixes      []string `yaml:"name_prefixes"`
        NameSuffixes      []string `yaml:"name_suffixes"`
}

// NewItemTemplateRegistry creates a new item template registry
func NewItemTemplateRegistry() *ItemTemplateRegistry <span class="cov8" title="1">{
        return &amp;ItemTemplateRegistry{
                templates:       make(map[string]*pcg.ItemTemplate),
                rarityModifiers: make(map[pcg.RarityTier]RarityModifier),
        }
}</span>

// LoadDefaultTemplates loads built-in item templates
func (itr *ItemTemplateRegistry) LoadDefaultTemplates() error <span class="cov8" title="1">{
        // Define default weapon templates
        swordTemplate := &amp;pcg.ItemTemplate{
                BaseType:  "weapon",
                NameParts: []string{"Blade", "Sword", "Saber", "Falchion"},
                StatRanges: map[string]pcg.StatRange{
                        "damage": {Min: 6, Max: 8, Scaling: 0.1},
                        "value":  {Min: 10, Max: 50, Scaling: 0.5},
                        "weight": {Min: 2, Max: 4, Scaling: 0.0},
                },
                Properties: []string{"slashing", "martial"},
                Materials:  []string{"iron", "steel", "mithril", "adamantine"},
                Rarities:   []pcg.RarityTier{pcg.RarityCommon, pcg.RarityUncommon, pcg.RarityRare, pcg.RarityEpic, pcg.RarityLegendary},
        }
        itr.templates["sword"] = swordTemplate

        bowTemplate := &amp;pcg.ItemTemplate{
                BaseType:  "weapon",
                NameParts: []string{"Bow", "Longbow", "Shortbow", "Recurve"},
                StatRanges: map[string]pcg.StatRange{
                        "damage": {Min: 6, Max: 6, Scaling: 0.1},
                        "range":  {Min: 80, Max: 150, Scaling: 1.0},
                        "value":  {Min: 15, Max: 75, Scaling: 0.5},
                        "weight": {Min: 1, Max: 3, Scaling: 0.0},
                },
                Properties: []string{"ranged", "martial", "ammunition"},
                Materials:  []string{"wood", "yew", "ironwood", "dragonbone"},
                Rarities:   []pcg.RarityTier{pcg.RarityCommon, pcg.RarityUncommon, pcg.RarityRare, pcg.RarityEpic},
        }
        itr.templates["bow"] = bowTemplate

        // Define default armor templates
        leatherTemplate := &amp;pcg.ItemTemplate{
                BaseType:  "armor",
                NameParts: []string{"Leather", "Hide", "Studded"},
                StatRanges: map[string]pcg.StatRange{
                        "ac":     {Min: 11, Max: 12, Scaling: 0.05},
                        "value":  {Min: 10, Max: 40, Scaling: 0.3},
                        "weight": {Min: 8, Max: 12, Scaling: 0.0},
                },
                Properties: []string{"light"},
                Materials:  []string{"leather", "studded_leather", "dragonskin"},
                Rarities:   []pcg.RarityTier{pcg.RarityCommon, pcg.RarityUncommon, pcg.RarityRare},
        }
        itr.templates["armor"] = leatherTemplate

        // Define consumable templates
        potionTemplate := &amp;pcg.ItemTemplate{
                BaseType:  "consumable",
                NameParts: []string{"Potion", "Elixir", "Draught"},
                StatRanges: map[string]pcg.StatRange{
                        "healing": {Min: 8, Max: 16, Scaling: 0.5},
                        "value":   {Min: 25, Max: 100, Scaling: 0.8},
                        "weight":  {Min: 1, Max: 1, Scaling: 0.0},
                },
                Properties: []string{"consumable", "magical"},
                Materials:  []string{"glass", "crystal", "vial"},
                Rarities:   []pcg.RarityTier{pcg.RarityCommon, pcg.RarityUncommon, pcg.RarityRare},
        }
        itr.templates["potion"] = potionTemplate

        // Load default rarity modifiers
        itr.loadDefaultRarityModifiers()

        return nil
}</span>

// LoadFromFile loads templates from YAML file
func (itr *ItemTemplateRegistry) LoadFromFile(configPath string) error <span class="cov0" title="0">{
        // TODO: Implement YAML file loading
        // For now, just ensure default templates are loaded
        return itr.LoadDefaultTemplates()
}</span>

// GetTemplate retrieves template by base type and rarity
func (itr *ItemTemplateRegistry) GetTemplate(baseType string, rarity pcg.RarityTier) (*pcg.ItemTemplate, error) <span class="cov8" title="1">{
        template, exists := itr.templates[baseType]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("template not found for type: %s", baseType)
        }</span>

        // Check if the template supports this rarity
        <span class="cov8" title="1">supported := false
        for _, supportedRarity := range template.Rarities </span><span class="cov8" title="1">{
                if supportedRarity == rarity </span><span class="cov8" title="1">{
                        supported = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !supported </span><span class="cov0" title="0">{
                // Return template anyway but with common rarity as fallback
                templateCopy := *template
                return &amp;templateCopy, nil
        }</span>

        // Return a copy of the template
        <span class="cov8" title="1">templateCopy := *template
        return &amp;templateCopy, nil</span>
}

// GetRarityModifier returns rarity modifier for given tier
func (itr *ItemTemplateRegistry) GetRarityModifier(rarity pcg.RarityTier) RarityModifier <span class="cov8" title="1">{
        if modifier, exists := itr.rarityModifiers[rarity]; exists </span><span class="cov8" title="1">{
                return modifier
        }</span>
        // Return common rarity as fallback
        <span class="cov0" title="0">return itr.rarityModifiers[pcg.RarityCommon]</span>
}

// loadDefaultRarityModifiers loads built-in rarity modifiers
func (itr *ItemTemplateRegistry) loadDefaultRarityModifiers() <span class="cov8" title="1">{
        itr.rarityModifiers[pcg.RarityCommon] = RarityModifier{
                StatMultiplier:    1.0,
                EnchantmentChance: 0.0,
                MaxEnchantments:   0,
                ValueMultiplier:   1.0,
                NamePrefixes:      []string{},
                NameSuffixes:      []string{},
        }

        itr.rarityModifiers[pcg.RarityUncommon] = RarityModifier{
                StatMultiplier:    1.1,
                EnchantmentChance: 0.3,
                MaxEnchantments:   1,
                ValueMultiplier:   2.0,
                NamePrefixes:      []string{"Fine", "Quality"},
                NameSuffixes:      []string{},
        }

        itr.rarityModifiers[pcg.RarityRare] = RarityModifier{
                StatMultiplier:    1.25,
                EnchantmentChance: 0.6,
                MaxEnchantments:   2,
                ValueMultiplier:   5.0,
                NamePrefixes:      []string{"Superior", "Masterwork"},
                NameSuffixes:      []string{"of Power"},
        }

        itr.rarityModifiers[pcg.RarityEpic] = RarityModifier{
                StatMultiplier:    1.5,
                EnchantmentChance: 0.8,
                MaxEnchantments:   3,
                ValueMultiplier:   10.0,
                NamePrefixes:      []string{"Epic", "Heroic"},
                NameSuffixes:      []string{"of the Champion", "of Might"},
        }

        itr.rarityModifiers[pcg.RarityLegendary] = RarityModifier{
                StatMultiplier:    2.0,
                EnchantmentChance: 1.0,
                MaxEnchantments:   4,
                ValueMultiplier:   25.0,
                NamePrefixes:      []string{"Legendary", "Mythic"},
                NameSuffixes:      []string{"of Legend", "of the Gods"},
        }

        itr.rarityModifiers[pcg.RarityArtifact] = RarityModifier{
                StatMultiplier:    3.0,
                EnchantmentChance: 1.0,
                MaxEnchantments:   5,
                ValueMultiplier:   100.0,
                NamePrefixes:      []string{"Artifact", "Primordial"},
                NameSuffixes:      []string{"of Creation", "of the Ancients"},
        }
}</span>

// GenerateItemName creates procedural item names
func GenerateItemName(template *pcg.ItemTemplate, rarity pcg.RarityTier, rng *rand.Rand) string <span class="cov8" title="1">{
        registry := NewItemTemplateRegistry()
        registry.LoadDefaultTemplates()

        modifier := registry.GetRarityModifier(rarity)

        // Start with base name
        baseName := template.NameParts[rng.Intn(len(template.NameParts))]

        // Add material qualifier
        if len(template.Materials) &gt; 0 </span><span class="cov8" title="1">{
                material := template.Materials[rng.Intn(len(template.Materials))]
                baseName = material + " " + baseName
        }</span>

        // Add rarity prefix
        <span class="cov8" title="1">if len(modifier.NamePrefixes) &gt; 0 &amp;&amp; rng.Float64() &lt; 0.7 </span><span class="cov8" title="1">{
                prefix := modifier.NamePrefixes[rng.Intn(len(modifier.NamePrefixes))]
                baseName = prefix + " " + baseName
        }</span>

        // Add rarity suffix
        <span class="cov8" title="1">if len(modifier.NameSuffixes) &gt; 0 &amp;&amp; rng.Float64() &lt; 0.5 </span><span class="cov8" title="1">{
                suffix := modifier.NameSuffixes[rng.Intn(len(modifier.NameSuffixes))]
                baseName = baseName + " " + suffix
        }</span>

        <span class="cov8" title="1">return baseName</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package levels

import (
        "fmt"
        "math"
        "math/rand"

        "goldbox-rpg/pkg/game"
        "goldbox-rpg/pkg/pcg"
)

// CorridorPlanner handles corridor generation between rooms
type CorridorPlanner struct {
        style pcg.CorridorStyle
        rng   *rand.Rand
}

// NewCorridorPlanner creates a new corridor planner with specified style
func NewCorridorPlanner(style pcg.CorridorStyle, rng *rand.Rand) *CorridorPlanner <span class="cov8" title="1">{
        return &amp;CorridorPlanner{
                style: style,
                rng:   rng,
        }
}</span>

// CreateCorridor generates a corridor between two points
func (cp *CorridorPlanner) CreateCorridor(id string, start, end game.Position, theme pcg.LevelTheme) (*pcg.Corridor, error) <span class="cov8" title="1">{
        corridor := &amp;pcg.Corridor{
                ID:       id,
                Start:    start,
                End:      end,
                Width:    cp.determineCorridorWidth(),
                Style:    cp.style,
                Features: []pcg.CorridorFeature{},
        }

        // Generate path based on style
        var err error
        corridor.Path, err = cp.generatePath(start, end, theme)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate corridor path: %w", err)
        }</span>

        // Add corridor features
        <span class="cov8" title="1">corridor.Features = cp.generateCorridorFeatures(corridor.Path, theme)

        return corridor, nil</span>
}

// determineCorridorWidth calculates appropriate corridor width
func (cp *CorridorPlanner) determineCorridorWidth() int <span class="cov8" title="1">{
        switch cp.style </span>{
        case pcg.CorridorMinimal:<span class="cov8" title="1">
                return 1</span>
        case pcg.CorridorStraight:<span class="cov8" title="1">
                return 1 + cp.rng.Intn(2)</span>
        case pcg.CorridorWindy:<span class="cov8" title="1">
                return 1 + cp.rng.Intn(2)</span>
        case pcg.CorridorMaze:<span class="cov8" title="1">
                return 1</span>
        case pcg.CorridorOrganic:<span class="cov8" title="1">
                return 2 + cp.rng.Intn(2)</span>
        default:<span class="cov0" title="0">
                return 1</span>
        }
}

// generatePath creates the corridor path based on style
func (cp *CorridorPlanner) generatePath(start, end game.Position, theme pcg.LevelTheme) ([]game.Position, error) <span class="cov8" title="1">{
        switch cp.style </span>{
        case pcg.CorridorStraight:<span class="cov8" title="1">
                return cp.generateStraightPath(start, end)</span>
        case pcg.CorridorWindy:<span class="cov8" title="1">
                return cp.generateWindyPath(start, end)</span>
        case pcg.CorridorMaze:<span class="cov8" title="1">
                return cp.generateMazePath(start, end)</span>
        case pcg.CorridorOrganic:<span class="cov8" title="1">
                return cp.generateOrganicPath(start, end)</span>
        case pcg.CorridorMinimal:<span class="cov8" title="1">
                return cp.generateMinimalPath(start, end)</span>
        default:<span class="cov0" title="0">
                return cp.generateStraightPath(start, end)</span>
        }
}

// generateStraightPath creates direct L-shaped corridors
func (cp *CorridorPlanner) generateStraightPath(start, end game.Position) ([]game.Position, error) <span class="cov8" title="1">{
        var path []game.Position

        // Determine if we go horizontal first or vertical first
        horizontalFirst := cp.rng.Float64() &lt; 0.5

        current := start
        path = append(path, current)

        if horizontalFirst </span><span class="cov8" title="1">{
                // Move horizontally first
                for current.X != end.X </span><span class="cov8" title="1">{
                        if current.X &lt; end.X </span><span class="cov8" title="1">{
                                current.X++
                        }</span> else<span class="cov8" title="1"> {
                                current.X--
                        }</span>
                        <span class="cov8" title="1">path = append(path, current)</span>
                }

                // Then move vertically
                <span class="cov8" title="1">for current.Y != end.Y </span><span class="cov8" title="1">{
                        if current.Y &lt; end.Y </span><span class="cov8" title="1">{
                                current.Y++
                        }</span> else<span class="cov8" title="1"> {
                                current.Y--
                        }</span>
                        <span class="cov8" title="1">path = append(path, current)</span>
                }
        } else<span class="cov8" title="1"> {
                // Move vertically first
                for current.Y != end.Y </span><span class="cov8" title="1">{
                        if current.Y &lt; end.Y </span><span class="cov8" title="1">{
                                current.Y++
                        }</span> else<span class="cov8" title="1"> {
                                current.Y--
                        }</span>
                        <span class="cov8" title="1">path = append(path, current)</span>
                }

                // Then move horizontally
                <span class="cov8" title="1">for current.X != end.X </span><span class="cov8" title="1">{
                        if current.X &lt; end.X </span><span class="cov8" title="1">{
                                current.X++
                        }</span> else<span class="cov8" title="1"> {
                                current.X--
                        }</span>
                        <span class="cov8" title="1">path = append(path, current)</span>
                }
        }

        <span class="cov8" title="1">return path, nil</span>
}

// generateWindyPath creates corridors with random turns
func (cp *CorridorPlanner) generateWindyPath(start, end game.Position) ([]game.Position, error) <span class="cov8" title="1">{
        var path []game.Position
        current := start
        path = append(path, current)

        // Add some randomness to the path
        for current.X != end.X || current.Y != end.Y </span><span class="cov8" title="1">{
                // Decide direction with bias toward target
                dx := end.X - current.X
                dy := end.Y - current.Y

                // Choose direction with weighted probability
                directions := []game.Position{}
                weights := []float64{}

                // Right
                if dx &gt; 0 </span><span class="cov8" title="1">{
                        directions = append(directions, game.Position{X: 1, Y: 0})
                        weights = append(weights, 0.6)
                }</span>
                // Left
                <span class="cov8" title="1">if dx &lt; 0 </span><span class="cov8" title="1">{
                        directions = append(directions, game.Position{X: -1, Y: 0})
                        weights = append(weights, 0.6)
                }</span>
                // Down
                <span class="cov8" title="1">if dy &gt; 0 </span><span class="cov8" title="1">{
                        directions = append(directions, game.Position{X: 0, Y: 1})
                        weights = append(weights, 0.6)
                }</span>
                // Up
                <span class="cov8" title="1">if dy &lt; 0 </span><span class="cov8" title="1">{
                        directions = append(directions, game.Position{X: 0, Y: -1})
                        weights = append(weights, 0.6)
                }</span>

                // Add some random directions
                <span class="cov8" title="1">if len(directions) &gt; 0 </span><span class="cov8" title="1">{
                        // Pick weighted random direction
                        dir := cp.weightedRandomDirection(directions, weights)
                        current.X += dir.X
                        current.Y += dir.Y
                        path = append(path, current)
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }

                // Add occasional random turns
                <span class="cov8" title="1">if cp.rng.Float64() &lt; 0.2 </span><span class="cov8" title="1">{
                        // Random side step
                        if cp.rng.Float64() &lt; 0.5 &amp;&amp; dx != 0 </span><span class="cov8" title="1">{
                                current.Y += cp.rng.Intn(3) - 1
                        }</span> else<span class="cov8" title="1"> if dy != 0 </span><span class="cov8" title="1">{
                                current.X += cp.rng.Intn(3) - 1
                        }</span>
                        <span class="cov8" title="1">path = append(path, current)</span>
                }
        }

        <span class="cov8" title="1">return path, nil</span>
}

// generateMazePath creates maze-like corridor paths
func (cp *CorridorPlanner) generateMazePath(start, end game.Position) ([]game.Position, error) <span class="cov8" title="1">{
        // For now, create a more complex path with multiple turns
        var path []game.Position
        current := start
        path = append(path, current)

        // Create intermediate waypoints
        waypoints := cp.generateWaypoints(start, end, 2+cp.rng.Intn(3))

        for _, waypoint := range waypoints </span><span class="cov8" title="1">{
                // Generate straight path to each waypoint
                for current.X != waypoint.X || current.Y != waypoint.Y </span><span class="cov8" title="1">{
                        if current.X != waypoint.X </span><span class="cov8" title="1">{
                                if current.X &lt; waypoint.X </span><span class="cov8" title="1">{
                                        current.X++
                                }</span> else<span class="cov8" title="1"> {
                                        current.X--
                                }</span>
                        } else<span class="cov8" title="1"> if current.Y != waypoint.Y </span><span class="cov8" title="1">{
                                if current.Y &lt; waypoint.Y </span><span class="cov8" title="1">{
                                        current.Y++
                                }</span> else<span class="cov8" title="1"> {
                                        current.Y--
                                }</span>
                        }
                        <span class="cov8" title="1">path = append(path, current)</span>
                }
        }

        <span class="cov8" title="1">return path, nil</span>
}

// generateOrganicPath creates natural, flowing corridors
func (cp *CorridorPlanner) generateOrganicPath(start, end game.Position) ([]game.Position, error) <span class="cov8" title="1">{
        var path []game.Position
        current := start
        path = append(path, current)

        distance := math.Sqrt(float64((end.X-start.X)*(end.X-start.X) + (end.Y-start.Y)*(end.Y-start.Y)))
        steps := int(distance * 1.5) // Make path longer for organic feel

        for i := 0; i &lt; steps &amp;&amp; (current.X != end.X || current.Y != end.Y); i++ </span><span class="cov8" title="1">{
                // Use sine wave for organic movement
                progress := float64(i) / float64(steps)

                // Calculate ideal position along direct line
                idealX := start.X + int(float64(end.X-start.X)*progress)
                idealY := start.Y + int(float64(end.Y-start.Y)*progress)

                // Add organic deviation
                deviation := math.Sin(progress*math.Pi*4) * 2 // Sine wave deviation

                // Move toward ideal position with organic curves
                if current.X &lt; idealX </span><span class="cov8" title="1">{
                        current.X++
                }</span> else<span class="cov8" title="1"> if current.X &gt; idealX </span><span class="cov8" title="1">{
                        current.X--
                }</span>

                <span class="cov8" title="1">if current.Y &lt; idealY </span><span class="cov8" title="1">{
                        current.Y++
                }</span> else<span class="cov8" title="1"> if current.Y &gt; idealY </span><span class="cov8" title="1">{
                        current.Y--
                }</span>

                // Apply organic deviation
                <span class="cov8" title="1">if cp.rng.Float64() &lt; 0.3 </span><span class="cov8" title="1">{
                        current.X += int(deviation)
                }</span>

                <span class="cov8" title="1">path = append(path, current)</span>
        }

        // Ensure we reach the end
        <span class="cov8" title="1">for current.X != end.X || current.Y != end.Y </span><span class="cov8" title="1">{
                if current.X &lt; end.X </span><span class="cov8" title="1">{
                        current.X++
                }</span> else<span class="cov8" title="1"> if current.X &gt; end.X </span><span class="cov8" title="1">{
                        current.X--
                }</span> else<span class="cov8" title="1"> if current.Y &lt; end.Y </span><span class="cov8" title="1">{
                        current.Y++
                }</span> else<span class="cov8" title="1"> if current.Y &gt; end.Y </span><span class="cov8" title="1">{
                        current.Y--
                }</span>
                <span class="cov8" title="1">path = append(path, current)</span>
        }

        <span class="cov8" title="1">return path, nil</span>
}

// generateMinimalPath creates the shortest possible path
func (cp *CorridorPlanner) generateMinimalPath(start, end game.Position) ([]game.Position, error) <span class="cov8" title="1">{
        var path []game.Position
        current := start
        path = append(path, current)

        // Move diagonally when possible, then orthogonally
        for current.X != end.X || current.Y != end.Y </span><span class="cov8" title="1">{
                moved := false

                // Try diagonal movement first
                if current.X != end.X &amp;&amp; current.Y != end.Y </span><span class="cov8" title="1">{
                        if current.X &lt; end.X </span><span class="cov8" title="1">{
                                current.X++
                        }</span> else<span class="cov8" title="1"> {
                                current.X--
                        }</span>
                        <span class="cov8" title="1">if current.Y &lt; end.Y </span><span class="cov8" title="1">{
                                current.Y++
                        }</span> else<span class="cov0" title="0"> {
                                current.Y--
                        }</span>
                        <span class="cov8" title="1">moved = true</span>
                } else<span class="cov8" title="1"> {
                        // Orthogonal movement
                        if current.X != end.X </span><span class="cov0" title="0">{
                                if current.X &lt; end.X </span><span class="cov0" title="0">{
                                        current.X++
                                }</span> else<span class="cov0" title="0"> {
                                        current.X--
                                }</span>
                                <span class="cov0" title="0">moved = true</span>
                        } else<span class="cov8" title="1"> if current.Y != end.Y </span><span class="cov8" title="1">{
                                if current.Y &lt; end.Y </span><span class="cov8" title="1">{
                                        current.Y++
                                }</span> else<span class="cov0" title="0"> {
                                        current.Y--
                                }</span>
                                <span class="cov8" title="1">moved = true</span>
                        }
                }

                <span class="cov8" title="1">if moved </span><span class="cov8" title="1">{
                        path = append(path, current)
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">return path, nil</span>
}

// generateWaypoints creates intermediate points for complex paths
func (cp *CorridorPlanner) generateWaypoints(start, end game.Position, count int) []game.Position <span class="cov8" title="1">{
        var waypoints []game.Position

        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                progress := float64(i+1) / float64(count+1)

                x := start.X + int(float64(end.X-start.X)*progress)
                y := start.Y + int(float64(end.Y-start.Y)*progress)

                // Add some randomness
                x += cp.rng.Intn(6) - 3
                y += cp.rng.Intn(6) - 3

                waypoints = append(waypoints, game.Position{X: x, Y: y})
        }</span>

        // Always end at the target
        <span class="cov8" title="1">waypoints = append(waypoints, end)

        return waypoints</span>
}

// weightedRandomDirection selects a direction based on weights
func (cp *CorridorPlanner) weightedRandomDirection(directions []game.Position, weights []float64) game.Position <span class="cov8" title="1">{
        if len(directions) == 0 </span><span class="cov0" title="0">{
                return game.Position{X: 0, Y: 0}
        }</span>

        <span class="cov8" title="1">totalWeight := 0.0
        for _, weight := range weights </span><span class="cov8" title="1">{
                totalWeight += weight
        }</span>

        <span class="cov8" title="1">if totalWeight == 0 </span><span class="cov0" title="0">{
                return directions[cp.rng.Intn(len(directions))]
        }</span>

        <span class="cov8" title="1">target := cp.rng.Float64() * totalWeight
        current := 0.0

        for i, weight := range weights </span><span class="cov8" title="1">{
                current += weight
                if current &gt;= target </span><span class="cov8" title="1">{
                        return directions[i]
                }</span>
        }

        <span class="cov0" title="0">return directions[len(directions)-1]</span>
}

// generateCorridorFeatures adds special features to corridors
func (cp *CorridorPlanner) generateCorridorFeatures(path []game.Position, theme pcg.LevelTheme) []pcg.CorridorFeature <span class="cov8" title="1">{
        var features []pcg.CorridorFeature

        // Add features spaced throughout the corridor
        featureSpacing := 8 + cp.rng.Intn(5)

        for i := featureSpacing; i &lt; len(path); i += featureSpacing </span><span class="cov8" title="1">{
                if cp.rng.Float64() &lt; 0.4 </span><span class="cov8" title="1">{ // 40% chance for feature
                        featureType := cp.selectCorridorFeatureType(theme)

                        feature := pcg.CorridorFeature{
                                Type:     featureType,
                                Position: path[i],
                                Properties: map[string]interface{}{
                                        "theme": theme,
                                },
                        }

                        features = append(features, feature)
                }</span>
        }

        <span class="cov8" title="1">return features</span>
}

// selectCorridorFeatureType chooses appropriate corridor features based on theme
func (cp *CorridorPlanner) selectCorridorFeatureType(theme pcg.LevelTheme) string <span class="cov8" title="1">{
        features := map[pcg.LevelTheme][]string{
                pcg.ThemeClassic:    {"torch", "banner", "statue"},
                pcg.ThemeHorror:     {"blood_stain", "scratch_marks", "bone_pile"},
                pcg.ThemeNatural:    {"moss", "root", "mushroom"},
                pcg.ThemeMechanical: {"gear", "pipe", "console"},
                pcg.ThemeMagical:    {"rune", "crystal", "floating_orb"},
                pcg.ThemeUndead:     {"coffin", "skeleton", "tomb"},
                pcg.ThemeElemental:  {"flame", "ice_crystal", "water_pool"},
        }

        themeFeatures, exists := features[theme]
        if !exists </span><span class="cov0" title="0">{
                themeFeatures = features[pcg.ThemeClassic]
        }</span>

        <span class="cov8" title="1">return themeFeatures[cp.rng.Intn(len(themeFeatures))]</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package main

import (
        "context"
        "fmt"
        "log"

        "goldbox-rpg/pkg/pcg"
        "goldbox-rpg/pkg/pcg/levels"
)

func main() <span class="cov0" title="0">{
        // Create a new level generator
        generator := levels.NewRoomCorridorGenerator()

        // Set up generation parameters
        levelParams := pcg.LevelParams{
                GenerationParams: pcg.GenerationParams{
                        Seed:        42,
                        Difficulty:  8,
                        PlayerLevel: 10,
                },
                MinRooms:      4,
                MaxRooms:      7,
                RoomTypes:     []pcg.RoomType{pcg.RoomTypeCombat, pcg.RoomTypeTreasure, pcg.RoomTypePuzzle},
                CorridorStyle: pcg.CorridorStraight,
                LevelTheme:    pcg.ThemeClassic,
                HasBoss:       true,
                SecretRooms:   1,
        }

        // Generate a level
        ctx := context.Background()
        level, err := generator.GenerateLevel(ctx, levelParams)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to generate level: %v", err)
        }</span>

        // Display basic level information
        <span class="cov0" title="0">fmt.Printf("Generated Level: %s\n", level.Name)
        fmt.Printf("Dimensions: %dx%d\n", level.Width, level.Height)
        fmt.Printf("Properties: %+v\n", level.Properties)

        // Show a small section of the level map
        fmt.Println("\nLevel Map (first 20x20 section):")
        for y := 0; y &lt; 20 &amp;&amp; y &lt; level.Height; y++ </span><span class="cov0" title="0">{
                for x := 0; x &lt; 20 &amp;&amp; x &lt; level.Width; x++ </span><span class="cov0" title="0">{
                        if level.Tiles[y][x].Walkable </span><span class="cov0" title="0">{
                                fmt.Print(".")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Print("#")
                        }</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">fmt.Println("\nLevel generation completed successfully!")</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package levels

import (
        "context"
        "fmt"
        "math/rand"

        "goldbox-rpg/pkg/game"
        "goldbox-rpg/pkg/pcg"
)

// RoomCorridorGenerator creates levels using room-corridor approach
type RoomCorridorGenerator struct {
        version        string
        roomGenerators map[pcg.RoomType]RoomGenerator
        rng            *rand.Rand
}

// RoomGenerator interface for different room types
type RoomGenerator interface {
        GenerateRoom(bounds pcg.Rectangle, theme pcg.LevelTheme, difficulty int, genCtx *pcg.GenerationContext) (*pcg.RoomLayout, error)
}

// NewRoomCorridorGenerator creates a new room-corridor level generator
func NewRoomCorridorGenerator() *RoomCorridorGenerator <span class="cov8" title="1">{
        rcg := &amp;RoomCorridorGenerator{
                version:        "1.0.0",
                roomGenerators: make(map[pcg.RoomType]RoomGenerator),
                rng:            rand.New(rand.NewSource(1)),
        }

        // Register default room generators
        rcg.registerDefaultRoomGenerators()
        return rcg
}</span>

// registerDefaultRoomGenerators registers the default room generators
func (rcg *RoomCorridorGenerator) registerDefaultRoomGenerators() <span class="cov8" title="1">{
        rcg.roomGenerators[pcg.RoomTypeCombat] = &amp;CombatRoomGenerator{}
        rcg.roomGenerators[pcg.RoomTypeTreasure] = &amp;TreasureRoomGenerator{}
        rcg.roomGenerators[pcg.RoomTypePuzzle] = &amp;PuzzleRoomGenerator{}
        rcg.roomGenerators[pcg.RoomTypeBoss] = &amp;BossRoomGenerator{}
        rcg.roomGenerators[pcg.RoomTypeEntrance] = &amp;EntranceRoomGenerator{}
        rcg.roomGenerators[pcg.RoomTypeExit] = &amp;ExitRoomGenerator{}
        rcg.roomGenerators[pcg.RoomTypeSecret] = &amp;SecretRoomGenerator{}
        rcg.roomGenerators[pcg.RoomTypeShop] = &amp;ShopRoomGenerator{}
        rcg.roomGenerators[pcg.RoomTypeRest] = &amp;RestRoomGenerator{}
        rcg.roomGenerators[pcg.RoomTypeTrap] = &amp;TrapRoomGenerator{}
        rcg.roomGenerators[pcg.RoomTypeStory] = &amp;StoryRoomGenerator{}
}</span>

// SetSeed sets the random seed for deterministic generation
func (rcg *RoomCorridorGenerator) SetSeed(seed int64) <span class="cov8" title="1">{
        rcg.rng = rand.New(rand.NewSource(seed))
}</span>

// GetType returns the content type this generator produces
func (rcg *RoomCorridorGenerator) GetType() pcg.ContentType <span class="cov8" title="1">{
        return pcg.ContentTypeLevels
}</span>

// GetVersion returns the generator version for compatibility checking
func (rcg *RoomCorridorGenerator) GetVersion() string <span class="cov8" title="1">{
        return rcg.version
}</span>

// Validate checks if the provided parameters are valid for this generator
func (rcg *RoomCorridorGenerator) Validate(params pcg.GenerationParams) error <span class="cov8" title="1">{
        levelParams, ok := params.Constraints["level_params"].(pcg.LevelParams)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid level parameters provided")
        }</span>

        <span class="cov8" title="1">if levelParams.MinRooms &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("minimum rooms must be at least 1")
        }</span>

        <span class="cov8" title="1">if levelParams.MaxRooms &lt; levelParams.MinRooms </span><span class="cov8" title="1">{
                return fmt.Errorf("maximum rooms must be greater than or equal to minimum rooms")
        }</span>

        <span class="cov8" title="1">if params.Difficulty &lt; 1 || params.Difficulty &gt; 20 </span><span class="cov8" title="1">{
                return fmt.Errorf("difficulty must be between 1 and 20")
        }</span>

        <span class="cov8" title="1">if params.PlayerLevel &lt; 1 || params.PlayerLevel &gt; 20 </span><span class="cov0" title="0">{
                return fmt.Errorf("player level must be between 1 and 20")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Generate implements the Generator interface
func (rcg *RoomCorridorGenerator) Generate(ctx context.Context, params pcg.GenerationParams) (interface{}, error) <span class="cov8" title="1">{
        levelParams, ok := params.Constraints["level_params"].(pcg.LevelParams)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid level parameters provided")
        }</span>

        // Set the seed for deterministic generation
        <span class="cov8" title="1">rcg.SetSeed(params.Seed)

        return rcg.GenerateLevel(ctx, levelParams)</span>
}

// GenerateLevel creates a complete dungeon level
func (rcg *RoomCorridorGenerator) GenerateLevel(ctx context.Context, params pcg.LevelParams) (*game.Level, error) <span class="cov8" title="1">{
        // Create generation context
        seedMgr := pcg.NewSeedManager(params.Seed)
        genCtx := pcg.NewGenerationContext(seedMgr, pcg.ContentTypeLevels, "level_generation", params.GenerationParams)

        // Calculate level dimensions based on room count
        width, height := rcg.calculateLevelDimensions(params)

        // 1. Plan room layout using space partitioning
        roomLayouts, err := rcg.generateRoomLayout(width, height, params, genCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate room layout: %w", err)
        }</span>

        // 2. Generate individual rooms
        <span class="cov8" title="1">err = rcg.generateRooms(roomLayouts, params, genCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate rooms: %w", err)
        }</span>

        // 3. Create corridor connections
        <span class="cov8" title="1">corridors, err := rcg.ConnectRooms(ctx, roomLayouts, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect rooms: %w", err)
        }</span>

        // 4. Add special features and encounters
        <span class="cov8" title="1">err = rcg.addSpecialFeatures(roomLayouts, params, genCtx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add special features: %w", err)
        }</span>

        // 5. Validate connectivity and balance
        <span class="cov8" title="1">err = rcg.validateLevel(roomLayouts, corridors)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("level validation failed: %w", err)
        }</span>

        // 6. Convert to game.Level format
        <span class="cov8" title="1">level, err := rcg.convertToGameLevel(roomLayouts, corridors, width, height, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert to game level: %w", err)
        }</span>

        <span class="cov8" title="1">return level, nil</span>
}

// calculateLevelDimensions calculates appropriate dimensions based on room count
func (rcg *RoomCorridorGenerator) calculateLevelDimensions(params pcg.LevelParams) (width, height int) <span class="cov8" title="1">{
        roomCount := params.MinRooms + rcg.rng.Intn(params.MaxRooms-params.MinRooms+1)

        // Estimate dimensions based on room count and theme
        baseSize := 40 + roomCount*8 // Base size scales with room count

        // Theme-specific adjustments
        switch params.LevelTheme </span>{
        case pcg.ThemeClassic:<span class="cov8" title="1">
                width, height = baseSize, baseSize</span>
        case pcg.ThemeHorror:<span class="cov8" title="1">
                // Longer, narrower levels for tension
                width, height = baseSize+20, baseSize-10</span>
        case pcg.ThemeNatural:<span class="cov8" title="1">
                // More organic, irregular dimensions
                width, height = baseSize+rcg.rng.Intn(20)-10, baseSize+rcg.rng.Intn(20)-10</span>
        case pcg.ThemeMechanical:<span class="cov8" title="1">
                // Perfect squares for mechanical precision
                width, height = baseSize, baseSize</span>
        default:<span class="cov8" title="1">
                width, height = baseSize, baseSize</span>
        }

        // Ensure minimum dimensions
        <span class="cov8" title="1">if width &lt; 30 </span><span class="cov0" title="0">{
                width = 30
        }</span>
        <span class="cov8" title="1">if height &lt; 30 </span><span class="cov0" title="0">{
                height = 30
        }</span>

        <span class="cov8" title="1">return width, height</span>
}

// generateRoomLayout creates the spatial layout of rooms using BSP
func (rcg *RoomCorridorGenerator) generateRoomLayout(width, height int, params pcg.LevelParams, genCtx *pcg.GenerationContext) ([]*pcg.RoomLayout, error) <span class="cov8" title="1">{
        roomCount := params.MinRooms + rcg.rng.Intn(params.MaxRooms-params.MinRooms+1)

        // Create BSP tree for room placement
        rootArea := pcg.Rectangle{X: 5, Y: 5, Width: width - 10, Height: height - 10}
        bspAreas := rcg.createBSPAreas(rootArea, roomCount)

        var roomLayouts []*pcg.RoomLayout

        // Create rooms from BSP areas
        for i, area := range bspAreas </span><span class="cov8" title="1">{
                roomType := rcg.selectRoomType(i, len(bspAreas), params)

                roomLayout := &amp;pcg.RoomLayout{
                        ID:         fmt.Sprintf("room_%d", i),
                        Type:       roomType,
                        Bounds:     area,
                        Difficulty: params.Difficulty,
                        Properties: make(map[string]interface{}),
                        Connected:  []string{},
                }

                roomLayouts = append(roomLayouts, roomLayout)
        }</span>

        // Ensure we have required special rooms
        <span class="cov8" title="1">rcg.ensureSpecialRooms(roomLayouts, params)

        return roomLayouts, nil</span>
}

// createBSPAreas uses Binary Space Partitioning to create room areas
func (rcg *RoomCorridorGenerator) createBSPAreas(area pcg.Rectangle, targetRooms int) []pcg.Rectangle <span class="cov8" title="1">{
        if targetRooms &lt;= 1 </span><span class="cov8" title="1">{
                return []pcg.Rectangle{area}
        }</span>

        // Split the area
        <span class="cov8" title="1">var areas []pcg.Rectangle
        splitVertical := rcg.rng.Float64() &lt; 0.5

        if splitVertical &amp;&amp; area.Width &gt; 20 </span><span class="cov8" title="1">{
                // Vertical split
                splitPos := area.Width/3 + rcg.rng.Intn(area.Width/3)
                left := pcg.Rectangle{X: area.X, Y: area.Y, Width: splitPos, Height: area.Height}
                right := pcg.Rectangle{X: area.X + splitPos, Y: area.Y, Width: area.Width - splitPos, Height: area.Height}

                leftRooms := targetRooms / 2
                rightRooms := targetRooms - leftRooms

                areas = append(areas, rcg.createBSPAreas(left, leftRooms)...)
                areas = append(areas, rcg.createBSPAreas(right, rightRooms)...)
        }</span> else<span class="cov8" title="1"> if !splitVertical &amp;&amp; area.Height &gt; 20 </span><span class="cov8" title="1">{
                // Horizontal split
                splitPos := area.Height/3 + rcg.rng.Intn(area.Height/3)
                top := pcg.Rectangle{X: area.X, Y: area.Y, Width: area.Width, Height: splitPos}
                bottom := pcg.Rectangle{X: area.X, Y: area.Y + splitPos, Width: area.Width, Height: area.Height - splitPos}

                topRooms := targetRooms / 2
                bottomRooms := targetRooms - topRooms

                areas = append(areas, rcg.createBSPAreas(top, topRooms)...)
                areas = append(areas, rcg.createBSPAreas(bottom, bottomRooms)...)
        }</span> else<span class="cov8" title="1"> {
                // Can't split further, return the area
                return []pcg.Rectangle{area}
        }</span>

        <span class="cov8" title="1">return areas</span>
}

// selectRoomType determines the appropriate room type for a position
func (rcg *RoomCorridorGenerator) selectRoomType(index, total int, params pcg.LevelParams) pcg.RoomType <span class="cov8" title="1">{
        // First room is entrance
        if index == 0 </span><span class="cov8" title="1">{
                return pcg.RoomTypeEntrance
        }</span>

        // Last room is exit
        <span class="cov8" title="1">if index == total-1 </span><span class="cov8" title="1">{
                return pcg.RoomTypeExit
        }</span>

        // Boss room if specified
        <span class="cov8" title="1">if params.HasBoss &amp;&amp; index == total-2 </span><span class="cov8" title="1">{
                return pcg.RoomTypeBoss
        }</span>

        // Select from allowed room types
        <span class="cov8" title="1">if len(params.RoomTypes) &gt; 0 </span><span class="cov8" title="1">{
                return params.RoomTypes[rcg.rng.Intn(len(params.RoomTypes))]
        }</span>

        // Default room type distribution
        <span class="cov8" title="1">roll := rcg.rng.Float64()
        switch </span>{
        case roll &lt; 0.4:<span class="cov8" title="1">
                return pcg.RoomTypeCombat</span>
        case roll &lt; 0.6:<span class="cov8" title="1">
                return pcg.RoomTypeTreasure</span>
        case roll &lt; 0.75:<span class="cov0" title="0">
                return pcg.RoomTypePuzzle</span>
        case roll &lt; 0.85:<span class="cov0" title="0">
                return pcg.RoomTypeRest</span>
        case roll &lt; 0.95:<span class="cov8" title="1">
                return pcg.RoomTypeTrap</span>
        default:<span class="cov0" title="0">
                return pcg.RoomTypeSecret</span>
        }
}

// ensureSpecialRooms makes sure required special rooms are present
func (rcg *RoomCorridorGenerator) ensureSpecialRooms(roomLayouts []*pcg.RoomLayout, params pcg.LevelParams) <span class="cov8" title="1">{
        hasEntrance := false
        hasExit := false

        for _, room := range roomLayouts </span><span class="cov8" title="1">{
                if room.Type == pcg.RoomTypeEntrance </span><span class="cov8" title="1">{
                        hasEntrance = true
                }</span>
                <span class="cov8" title="1">if room.Type == pcg.RoomTypeExit </span><span class="cov8" title="1">{
                        hasExit = true
                }</span>
        }

        // Ensure entrance exists
        <span class="cov8" title="1">if !hasEntrance &amp;&amp; len(roomLayouts) &gt; 0 </span><span class="cov0" title="0">{
                roomLayouts[0].Type = pcg.RoomTypeEntrance
        }</span>

        // Ensure exit exists
        <span class="cov8" title="1">if !hasExit &amp;&amp; len(roomLayouts) &gt; 1 </span><span class="cov0" title="0">{
                roomLayouts[len(roomLayouts)-1].Type = pcg.RoomTypeExit
        }</span>
}

// generateRooms creates the actual room content
func (rcg *RoomCorridorGenerator) generateRooms(roomLayouts []*pcg.RoomLayout, params pcg.LevelParams, genCtx *pcg.GenerationContext) error <span class="cov8" title="1">{
        for _, roomLayout := range roomLayouts </span><span class="cov8" title="1">{
                generator, exists := rcg.roomGenerators[roomLayout.Type]
                if !exists </span><span class="cov0" title="0">{
                        // Use default combat room generator
                        generator = rcg.roomGenerators[pcg.RoomTypeCombat]
                }</span>

                <span class="cov8" title="1">generatedRoom, err := generator.GenerateRoom(roomLayout.Bounds, params.LevelTheme, params.Difficulty, genCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate room %s: %w", roomLayout.ID, err)
                }</span>

                // Copy generated content back to layout
                <span class="cov8" title="1">roomLayout.Tiles = generatedRoom.Tiles
                roomLayout.Doors = generatedRoom.Doors
                roomLayout.Features = generatedRoom.Features
                roomLayout.Properties = generatedRoom.Properties</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ConnectRooms generates corridors and passages between rooms
func (rcg *RoomCorridorGenerator) ConnectRooms(ctx context.Context, rooms []*pcg.RoomLayout, params pcg.LevelParams) ([]pcg.Corridor, error) <span class="cov8" title="1">{
        var corridors []pcg.Corridor
        planner := NewCorridorPlanner(params.CorridorStyle, rcg.rng)

        // Create minimum spanning tree for basic connectivity
        connections := rcg.createMinimumConnections(rooms)

        // Generate corridors for each connection
        for i, connection := range connections </span><span class="cov8" title="1">{
                corridor, err := planner.CreateCorridor(
                        fmt.Sprintf("corridor_%d", i),
                        connection.Start,
                        connection.End,
                        params.LevelTheme,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create corridor %d: %w", i, err)
                }</span>

                <span class="cov8" title="1">corridors = append(corridors, *corridor)

                // Update room connections
                rooms[connection.StartRoomIndex].Connected = append(
                        rooms[connection.StartRoomIndex].Connected,
                        rooms[connection.EndRoomIndex].ID,
                )
                rooms[connection.EndRoomIndex].Connected = append(
                        rooms[connection.EndRoomIndex].Connected,
                        rooms[connection.StartRoomIndex].ID,
                )</span>
        }

        <span class="cov8" title="1">return corridors, nil</span>
}

// RoomConnection represents a connection between two rooms
type RoomConnection struct {
        Start          game.Position
        End            game.Position
        StartRoomIndex int
        EndRoomIndex   int
}

// createMinimumConnections creates a minimum set of connections for level connectivity
func (rcg *RoomCorridorGenerator) createMinimumConnections(rooms []*pcg.RoomLayout) []RoomConnection <span class="cov8" title="1">{
        var connections []RoomConnection

        // Connect adjacent rooms in a simple chain
        for i := 0; i &lt; len(rooms)-1; i++ </span><span class="cov8" title="1">{
                startPos := rcg.findConnectionPoint(rooms[i])
                endPos := rcg.findConnectionPoint(rooms[i+1])

                connections = append(connections, RoomConnection{
                        Start:          startPos,
                        End:            endPos,
                        StartRoomIndex: i,
                        EndRoomIndex:   i + 1,
                })
        }</span>

        // Add some additional connections for interesting layouts
        <span class="cov8" title="1">if len(rooms) &gt; 3 </span><span class="cov8" title="1">{
                // Connect first and last room for loop
                startPos := rcg.findConnectionPoint(rooms[0])
                endPos := rcg.findConnectionPoint(rooms[len(rooms)-1])

                connections = append(connections, RoomConnection{
                        Start:          startPos,
                        End:            endPos,
                        StartRoomIndex: 0,
                        EndRoomIndex:   len(rooms) - 1,
                })
        }</span>

        <span class="cov8" title="1">return connections</span>
}

// findConnectionPoint finds a good door position on a room
func (rcg *RoomCorridorGenerator) findConnectionPoint(room *pcg.RoomLayout) game.Position <span class="cov8" title="1">{
        // For now, return center of a random wall
        switch rcg.rng.Intn(4) </span>{
        case 0:<span class="cov8" title="1"> // Top wall
                return game.Position{
                        X: room.Bounds.X + room.Bounds.Width/2,
                        Y: room.Bounds.Y,
                }</span>
        case 1:<span class="cov8" title="1"> // Right wall
                return game.Position{
                        X: room.Bounds.X + room.Bounds.Width - 1,
                        Y: room.Bounds.Y + room.Bounds.Height/2,
                }</span>
        case 2:<span class="cov8" title="1"> // Bottom wall
                return game.Position{
                        X: room.Bounds.X + room.Bounds.Width/2,
                        Y: room.Bounds.Y + room.Bounds.Height - 1,
                }</span>
        default:<span class="cov8" title="1"> // Left wall
                return game.Position{
                        X: room.Bounds.X,
                        Y: room.Bounds.Y + room.Bounds.Height/2,
                }</span>
        }
}

// addSpecialFeatures adds special features and encounters to the level
func (rcg *RoomCorridorGenerator) addSpecialFeatures(roomLayouts []*pcg.RoomLayout, params pcg.LevelParams, genCtx *pcg.GenerationContext) error <span class="cov8" title="1">{
        // Add secret rooms if specified
        secretRoomsAdded := 0
        for _, room := range roomLayouts </span><span class="cov8" title="1">{
                if room.Type == pcg.RoomTypeSecret </span><span class="cov0" title="0">{
                        secretRoomsAdded++
                }</span>
        }

        // Generate additional secret rooms if needed
        <span class="cov8" title="1">for secretRoomsAdded &lt; params.SecretRooms &amp;&amp; len(roomLayouts) &gt; 0 </span><span class="cov8" title="1">{
                // Find a suitable room to add a secret connection to
                targetRoom := roomLayouts[rcg.rng.Intn(len(roomLayouts))]
                if targetRoom.Type != pcg.RoomTypeSecret </span><span class="cov8" title="1">{
                        // Add secret room feature
                        targetRoom.Features = append(targetRoom.Features, pcg.RoomFeature{
                                Type:     "secret_door",
                                Position: rcg.findConnectionPoint(targetRoom),
                                Properties: map[string]interface{}{
                                        "hidden":     true,
                                        "difficulty": params.Difficulty + 2,
                                },
                        })
                        secretRoomsAdded++
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateLevel ensures the level meets quality standards
func (rcg *RoomCorridorGenerator) validateLevel(rooms []*pcg.RoomLayout, corridors []pcg.Corridor) error <span class="cov8" title="1">{
        // Check that all rooms are reachable
        reachable := make(map[string]bool)
        rcg.markReachableRooms(rooms[0].ID, rooms, reachable)

        for _, room := range rooms </span><span class="cov8" title="1">{
                if !reachable[room.ID] </span><span class="cov0" title="0">{
                        return fmt.Errorf("room %s is not reachable", room.ID)
                }</span>
        }

        // Check that we have at least one entrance and exit
        <span class="cov8" title="1">hasEntrance := false
        hasExit := false
        for _, room := range rooms </span><span class="cov8" title="1">{
                if room.Type == pcg.RoomTypeEntrance </span><span class="cov8" title="1">{
                        hasEntrance = true
                }</span>
                <span class="cov8" title="1">if room.Type == pcg.RoomTypeExit </span><span class="cov8" title="1">{
                        hasExit = true
                }</span>
        }

        <span class="cov8" title="1">if !hasEntrance </span><span class="cov0" title="0">{
                return fmt.Errorf("level has no entrance room")
        }</span>
        <span class="cov8" title="1">if !hasExit </span><span class="cov0" title="0">{
                return fmt.Errorf("level has no exit room")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// markReachableRooms recursively marks all reachable rooms
func (rcg *RoomCorridorGenerator) markReachableRooms(roomID string, rooms []*pcg.RoomLayout, reachable map[string]bool) <span class="cov8" title="1">{
        if reachable[roomID] </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">reachable[roomID] = true

        // Find the room
        var currentRoom *pcg.RoomLayout
        for _, room := range rooms </span><span class="cov8" title="1">{
                if room.ID == roomID </span><span class="cov8" title="1">{
                        currentRoom = room
                        break</span>
                }
        }

        <span class="cov8" title="1">if currentRoom == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Mark connected rooms as reachable
        <span class="cov8" title="1">for _, connectedID := range currentRoom.Connected </span><span class="cov8" title="1">{
                rcg.markReachableRooms(connectedID, rooms, reachable)
        }</span>
}

// convertToGameLevel converts the generated rooms and corridors to a game.Level
func (rcg *RoomCorridorGenerator) convertToGameLevel(rooms []*pcg.RoomLayout, corridors []pcg.Corridor, width, height int, params pcg.LevelParams) (*game.Level, error) <span class="cov8" title="1">{
        // Create level with basic info
        level := &amp;game.Level{
                ID:         fmt.Sprintf("generated_level_%d", params.Seed),
                Name:       fmt.Sprintf("Generated %s Level", params.LevelTheme),
                Width:      width,
                Height:     height,
                Tiles:      make([][]game.Tile, height),
                Properties: make(map[string]interface{}),
        }

        // Initialize tiles with walls
        for y := 0; y &lt; height; y++ </span><span class="cov8" title="1">{
                level.Tiles[y] = make([]game.Tile, width)
                for x := 0; x &lt; width; x++ </span><span class="cov8" title="1">{
                        level.Tiles[y][x] = game.Tile{
                                Type:       game.TileWall,
                                Walkable:   false,
                                Properties: make(map[string]interface{}),
                        }
                }</span>
        }

        // Place room tiles
        <span class="cov8" title="1">for _, room := range rooms </span><span class="cov8" title="1">{
                for y := 0; y &lt; len(room.Tiles) &amp;&amp; room.Bounds.Y+y &lt; height; y++ </span><span class="cov8" title="1">{
                        for x := 0; x &lt; len(room.Tiles[y]) &amp;&amp; room.Bounds.X+x &lt; width; x++ </span><span class="cov8" title="1">{
                                level.Tiles[room.Bounds.Y+y][room.Bounds.X+x] = room.Tiles[y][x]
                        }</span>
                }
        }

        // Place corridor tiles
        <span class="cov8" title="1">for _, corridor := range corridors </span><span class="cov8" title="1">{
                for _, pos := range corridor.Path </span><span class="cov8" title="1">{
                        if pos.X &gt;= 0 &amp;&amp; pos.X &lt; width &amp;&amp; pos.Y &gt;= 0 &amp;&amp; pos.Y &lt; height </span><span class="cov8" title="1">{
                                level.Tiles[pos.Y][pos.X] = game.Tile{
                                        Type:       game.TileFloor,
                                        Walkable:   true,
                                        Properties: make(map[string]interface{}),
                                }
                        }</span>
                }
        }

        // Add level metadata
        <span class="cov8" title="1">level.Properties["theme"] = params.LevelTheme
        level.Properties["difficulty"] = params.Difficulty
        level.Properties["room_count"] = len(rooms)
        level.Properties["corridor_count"] = len(corridors)
        level.Properties["generator"] = "room_corridor"
        level.Properties["version"] = rcg.version

        return level, nil</span>
}

// GenerateRoom creates a single room with specified constraints
func (rcg *RoomCorridorGenerator) GenerateRoom(ctx context.Context, bounds pcg.Rectangle, roomType pcg.RoomType, params pcg.LevelParams) (*pcg.RoomLayout, error) <span class="cov8" title="1">{
        generator, exists := rcg.roomGenerators[roomType]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no generator available for room type: %s", roomType)
        }</span>

        <span class="cov8" title="1">seedMgr := pcg.NewSeedManager(params.Seed)
        genCtx := pcg.NewGenerationContext(seedMgr, pcg.ContentTypeLevels, "room_generation", params.GenerationParams)

        return generator.GenerateRoom(bounds, params.LevelTheme, params.Difficulty, genCtx)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package levels

import (
        "fmt"
        "math/rand"

        "goldbox-rpg/pkg/game"
        "goldbox-rpg/pkg/pcg"
)

// CombatRoomGenerator creates combat encounter rooms
type CombatRoomGenerator struct{}

func (crg *CombatRoomGenerator) GenerateRoom(bounds pcg.Rectangle, theme pcg.LevelTheme, difficulty int, genCtx *pcg.GenerationContext) (*pcg.RoomLayout, error) <span class="cov8" title="1">{
        room := &amp;pcg.RoomLayout{
                Type:       pcg.RoomTypeCombat,
                Bounds:     bounds,
                Tiles:      make([][]game.Tile, bounds.Height),
                Doors:      []game.Position{},
                Features:   []pcg.RoomFeature{},
                Properties: make(map[string]interface{}),
        }

        // Initialize room tiles
        for y := 0; y &lt; bounds.Height; y++ </span><span class="cov8" title="1">{
                room.Tiles[y] = make([]game.Tile, bounds.Width)
                for x := 0; x &lt; bounds.Width; x++ </span><span class="cov8" title="1">{
                        // Create basic floor with walls on edges
                        if x == 0 || x == bounds.Width-1 || y == 0 || y == bounds.Height-1 </span><span class="cov8" title="1">{
                                room.Tiles[y][x] = game.Tile{
                                        Type:       game.TileWall,
                                        Walkable:   false,
                                        Properties: make(map[string]interface{}),
                                }
                        }</span> else<span class="cov8" title="1"> {
                                room.Tiles[y][x] = game.Tile{
                                        Type:       game.TileFloor,
                                        Walkable:   true,
                                        Properties: make(map[string]interface{}),
                                }
                        }</span>
                }
        }

        // Add tactical features based on theme and difficulty
        <span class="cov8" title="1">rng := genCtx.RNG
        featureCount := 1 + difficulty/4 + rng.Intn(3)

        for i := 0; i &lt; featureCount; i++ </span><span class="cov8" title="1">{
                feature := crg.generateTacticalFeature(bounds, theme, difficulty, rng)
                room.Features = append(room.Features, feature)
        }</span>

        // Add doors
        <span class="cov8" title="1">room.Doors = append(room.Doors, crg.generateDoorPositions(bounds, rng)...)

        // Set combat-specific properties
        room.Properties["enemy_count"] = 2 + difficulty/3
        room.Properties["enemy_types"] = crg.selectEnemyTypes(theme, difficulty)
        room.Properties["loot_chance"] = 0.3 + float64(difficulty)*0.02

        return room, nil</span>
}

func (crg *CombatRoomGenerator) generateTacticalFeature(bounds pcg.Rectangle, theme pcg.LevelTheme, difficulty int, rng *rand.Rand) pcg.RoomFeature <span class="cov8" title="1">{
        // Generate random position inside room (not on walls)
        x := 1 + rng.Intn(bounds.Width-2)
        y := 1 + rng.Intn(bounds.Height-2)

        features := []string{"cover", "elevation", "trap", "hazard"}
        featureType := features[rng.Intn(len(features))]

        return pcg.RoomFeature{
                Type:     featureType,
                Position: game.Position{X: bounds.X + x, Y: bounds.Y + y},
                Properties: map[string]interface{}{
                        "theme":      theme,
                        "difficulty": difficulty,
                },
        }
}</span>

func (crg *CombatRoomGenerator) generateDoorPositions(bounds pcg.Rectangle, rng *rand.Rand) []game.Position <span class="cov8" title="1">{
        var doors []game.Position

        // Add 1-3 doors
        doorCount := 1 + rng.Intn(3)
        for i := 0; i &lt; doorCount; i++ </span><span class="cov8" title="1">{
                // Choose random wall
                wall := rng.Intn(4)
                var x, y int

                switch wall </span>{
                case 0:<span class="cov8" title="1"> // Top wall
                        x = 1 + rng.Intn(bounds.Width-2)
                        y = 0</span>
                case 1:<span class="cov8" title="1"> // Right wall
                        x = bounds.Width - 1
                        y = 1 + rng.Intn(bounds.Height-2)</span>
                case 2:<span class="cov8" title="1"> // Bottom wall
                        x = 1 + rng.Intn(bounds.Width-2)
                        y = bounds.Height - 1</span>
                case 3:<span class="cov8" title="1"> // Left wall
                        x = 0
                        y = 1 + rng.Intn(bounds.Height-2)</span>
                }

                <span class="cov8" title="1">doors = append(doors, game.Position{X: bounds.X + x, Y: bounds.Y + y})</span>
        }

        <span class="cov8" title="1">return doors</span>
}

func (crg *CombatRoomGenerator) selectEnemyTypes(theme pcg.LevelTheme, difficulty int) []string <span class="cov8" title="1">{
        var enemies []string

        switch theme </span>{
        case pcg.ThemeClassic:<span class="cov8" title="1">
                enemies = []string{"goblin", "orc", "skeleton"}</span>
        case pcg.ThemeHorror:<span class="cov0" title="0">
                enemies = []string{"zombie", "wraith", "shadow"}</span>
        case pcg.ThemeNatural:<span class="cov8" title="1">
                enemies = []string{"wolf", "bear", "spider"}</span>
        case pcg.ThemeMechanical:<span class="cov0" title="0">
                enemies = []string{"construct", "golem", "automaton"}</span>
        case pcg.ThemeMagical:<span class="cov8" title="1">
                enemies = []string{"elemental", "sprite", "wisp"}</span>
        case pcg.ThemeUndead:<span class="cov0" title="0">
                enemies = []string{"skeleton", "zombie", "lich"}</span>
        case pcg.ThemeElemental:<span class="cov0" title="0">
                enemies = []string{"fire_elemental", "water_elemental", "earth_elemental"}</span>
        default:<span class="cov0" title="0">
                enemies = []string{"goblin", "orc", "bandit"}</span>
        }

        // Scale with difficulty
        <span class="cov8" title="1">if difficulty &gt; 10 </span><span class="cov0" title="0">{
                enemies = append(enemies, "elite_"+enemies[0])
        }</span>

        <span class="cov8" title="1">return enemies</span>
}

// TreasureRoomGenerator creates treasure and loot rooms
type TreasureRoomGenerator struct{}

func (trg *TreasureRoomGenerator) GenerateRoom(bounds pcg.Rectangle, theme pcg.LevelTheme, difficulty int, genCtx *pcg.GenerationContext) (*pcg.RoomLayout, error) <span class="cov8" title="1">{
        room := &amp;pcg.RoomLayout{
                Type:       pcg.RoomTypeTreasure,
                Bounds:     bounds,
                Tiles:      make([][]game.Tile, bounds.Height),
                Doors:      []game.Position{},
                Features:   []pcg.RoomFeature{},
                Properties: make(map[string]interface{}),
        }

        // Initialize room tiles with ornate decoration
        for y := 0; y &lt; bounds.Height; y++ </span><span class="cov8" title="1">{
                room.Tiles[y] = make([]game.Tile, bounds.Width)
                for x := 0; x &lt; bounds.Width; x++ </span><span class="cov8" title="1">{
                        if x == 0 || x == bounds.Width-1 || y == 0 || y == bounds.Height-1 </span><span class="cov8" title="1">{
                                room.Tiles[y][x] = game.Tile{
                                        Type:       game.TileWall,
                                        Walkable:   false,
                                        Properties: map[string]interface{}{"decorated": true},
                                }
                        }</span> else<span class="cov8" title="1"> {
                                room.Tiles[y][x] = game.Tile{
                                        Type:       game.TileFloor,
                                        Walkable:   true,
                                        Properties: map[string]interface{}{"polished": true},
                                }
                        }</span>
                }
        }

        <span class="cov8" title="1">rng := genCtx.RNG

        // Add treasure containers
        treasureCount := 1 + difficulty/5 + rng.Intn(2)
        for i := 0; i &lt; treasureCount; i++ </span><span class="cov8" title="1">{
                x := 1 + rng.Intn(bounds.Width-2)
                y := 1 + rng.Intn(bounds.Height-2)

                treasure := pcg.RoomFeature{
                        Type:     "treasure_chest",
                        Position: game.Position{X: bounds.X + x, Y: bounds.Y + y},
                        Properties: map[string]interface{}{
                                "rarity":   trg.getTreasureRarity(difficulty, rng),
                                "locked":   difficulty &gt; 5,
                                "trapped":  difficulty &gt; 8 &amp;&amp; rng.Float64() &lt; 0.3,
                                "contents": trg.generateTreasureContents(difficulty, rng),
                        },
                }
                room.Features = append(room.Features, treasure)
        }</span>

        // Add guardian if valuable enough
        <span class="cov8" title="1">if difficulty &gt; 7 </span><span class="cov8" title="1">{
                room.Features = append(room.Features, pcg.RoomFeature{
                        Type:     "guardian",
                        Position: game.Position{X: bounds.X + bounds.Width/2, Y: bounds.Y + bounds.Height/2},
                        Properties: map[string]interface{}{
                                "type":       "treasure_guardian",
                                "difficulty": difficulty - 2,
                        },
                })
        }</span>

        // Add single door (secure access)
        <span class="cov8" title="1">room.Doors = []game.Position{
                {X: bounds.X + bounds.Width/2, Y: bounds.Y},
        }

        room.Properties["treasure_value"] = difficulty * 100
        room.Properties["requires_key"] = difficulty &gt; 10

        return room, nil</span>
}

func (trg *TreasureRoomGenerator) getTreasureRarity(difficulty int, rng *rand.Rand) string <span class="cov8" title="1">{
        switch </span>{
        case difficulty &lt; 5:<span class="cov0" title="0">
                return "common"</span>
        case difficulty &lt; 10:<span class="cov8" title="1">
                return "uncommon"</span>
        case difficulty &lt; 15:<span class="cov8" title="1">
                return "rare"</span>
        default:<span class="cov0" title="0">
                return "epic"</span>
        }
}

func (trg *TreasureRoomGenerator) generateTreasureContents(difficulty int, rng *rand.Rand) []string <span class="cov8" title="1">{
        contents := []string{"gold"}

        if difficulty &gt; 3 </span><span class="cov8" title="1">{
                contents = append(contents, "gems")
        }</span>
        <span class="cov8" title="1">if difficulty &gt; 7 </span><span class="cov8" title="1">{
                contents = append(contents, "magic_item")
        }</span>
        <span class="cov8" title="1">if difficulty &gt; 12 </span><span class="cov0" title="0">{
                contents = append(contents, "artifact")
        }</span>

        <span class="cov8" title="1">return contents</span>
}

// PuzzleRoomGenerator creates puzzle and challenge rooms
type PuzzleRoomGenerator struct{}

func (prg *PuzzleRoomGenerator) GenerateRoom(bounds pcg.Rectangle, theme pcg.LevelTheme, difficulty int, genCtx *pcg.GenerationContext) (*pcg.RoomLayout, error) <span class="cov0" title="0">{
        room := &amp;pcg.RoomLayout{
                Type:       pcg.RoomTypePuzzle,
                Bounds:     bounds,
                Tiles:      make([][]game.Tile, bounds.Height),
                Doors:      []game.Position{},
                Features:   []pcg.RoomFeature{},
                Properties: make(map[string]interface{}),
        }

        // Initialize room tiles
        for y := 0; y &lt; bounds.Height; y++ </span><span class="cov0" title="0">{
                room.Tiles[y] = make([]game.Tile, bounds.Width)
                for x := 0; x &lt; bounds.Width; x++ </span><span class="cov0" title="0">{
                        if x == 0 || x == bounds.Width-1 || y == 0 || y == bounds.Height-1 </span><span class="cov0" title="0">{
                                room.Tiles[y][x] = game.Tile{
                                        Type:       game.TileWall,
                                        Walkable:   false,
                                        Properties: make(map[string]interface{}),
                                }
                        }</span> else<span class="cov0" title="0"> {
                                room.Tiles[y][x] = game.Tile{
                                        Type:       game.TileFloor,
                                        Walkable:   true,
                                        Properties: make(map[string]interface{}),
                                }
                        }</span>
                }
        }

        <span class="cov0" title="0">rng := genCtx.RNG

        // Generate puzzle type based on theme
        puzzleType := prg.selectPuzzleType(theme, difficulty, rng)

        // Add puzzle elements
        room.Features = append(room.Features, prg.generatePuzzleElements(bounds, puzzleType, difficulty, rng)...)

        // Add entrance door
        room.Doors = []game.Position{
                {X: bounds.X + bounds.Width/2, Y: bounds.Y},
        }

        // Add exit door (may be locked until puzzle solved)
        exitDoor := game.Position{X: bounds.X + bounds.Width/2, Y: bounds.Y + bounds.Height - 1}
        room.Doors = append(room.Doors, exitDoor)

        room.Properties["puzzle_type"] = puzzleType
        room.Properties["difficulty"] = difficulty
        room.Properties["requires_solution"] = true

        return room, nil</span>
}

func (prg *PuzzleRoomGenerator) selectPuzzleType(theme pcg.LevelTheme, difficulty int, rng *rand.Rand) string <span class="cov0" title="0">{
        var puzzles []string

        switch theme </span>{
        case pcg.ThemeClassic:<span class="cov0" title="0">
                puzzles = []string{"lever_sequence", "pressure_plates", "riddle"}</span>
        case pcg.ThemeMechanical:<span class="cov0" title="0">
                puzzles = []string{"gear_puzzle", "circuit_puzzle", "weight_balance"}</span>
        case pcg.ThemeMagical:<span class="cov0" title="0">
                puzzles = []string{"rune_sequence", "elemental_matching", "spell_focus"}</span>
        default:<span class="cov0" title="0">
                puzzles = []string{"lever_sequence", "pressure_plates", "riddle"}</span>
        }

        <span class="cov0" title="0">return puzzles[rng.Intn(len(puzzles))]</span>
}

func (prg *PuzzleRoomGenerator) generatePuzzleElements(bounds pcg.Rectangle, puzzleType string, difficulty int, rng *rand.Rand) []pcg.RoomFeature <span class="cov0" title="0">{
        var features []pcg.RoomFeature

        elementCount := 2 + difficulty/3

        switch puzzleType </span>{
        case "lever_sequence":<span class="cov0" title="0">
                for i := 0; i &lt; elementCount; i++ </span><span class="cov0" title="0">{
                        x := 1 + rng.Intn(bounds.Width-2)
                        y := 1 + rng.Intn(bounds.Height-2)
                        features = append(features, pcg.RoomFeature{
                                Type:     "lever",
                                Position: game.Position{X: bounds.X + x, Y: bounds.Y + y},
                                Properties: map[string]interface{}{
                                        "sequence_number": i + 1,
                                        "state":           "off",
                                },
                        })
                }</span>
        case "pressure_plates":<span class="cov0" title="0">
                for i := 0; i &lt; elementCount; i++ </span><span class="cov0" title="0">{
                        x := 1 + rng.Intn(bounds.Width-2)
                        y := 1 + rng.Intn(bounds.Height-2)
                        features = append(features, pcg.RoomFeature{
                                Type:     "pressure_plate",
                                Position: game.Position{X: bounds.X + x, Y: bounds.Y + y},
                                Properties: map[string]interface{}{
                                        "activated": false,
                                        "weight":    10 + rng.Intn(50),
                                },
                        })
                }</span>
        default:<span class="cov0" title="0">
                // Generic interactive element
                x := bounds.Width / 2
                y := bounds.Height / 2
                features = append(features, pcg.RoomFeature{
                        Type:     "puzzle_element",
                        Position: game.Position{X: bounds.X + x, Y: bounds.Y + y},
                        Properties: map[string]interface{}{
                                "type": puzzleType,
                        },
                })</span>
        }

        <span class="cov0" title="0">return features</span>
}

// BossRoomGenerator creates climactic boss encounter rooms
type BossRoomGenerator struct{}

func (brg *BossRoomGenerator) GenerateRoom(bounds pcg.Rectangle, theme pcg.LevelTheme, difficulty int, genCtx *pcg.GenerationContext) (*pcg.RoomLayout, error) <span class="cov8" title="1">{
        room := &amp;pcg.RoomLayout{
                Type:       pcg.RoomTypeBoss,
                Bounds:     bounds,
                Tiles:      make([][]game.Tile, bounds.Height),
                Doors:      []game.Position{},
                Features:   []pcg.RoomFeature{},
                Properties: make(map[string]interface{}),
        }

        // Initialize larger room tiles
        for y := 0; y &lt; bounds.Height; y++ </span><span class="cov8" title="1">{
                room.Tiles[y] = make([]game.Tile, bounds.Width)
                for x := 0; x &lt; bounds.Width; x++ </span><span class="cov8" title="1">{
                        if x == 0 || x == bounds.Width-1 || y == 0 || y == bounds.Height-1 </span><span class="cov8" title="1">{
                                room.Tiles[y][x] = game.Tile{
                                        Type:       game.TileWall,
                                        Walkable:   false,
                                        Properties: map[string]interface{}{"reinforced": true},
                                }
                        }</span> else<span class="cov8" title="1"> {
                                room.Tiles[y][x] = game.Tile{
                                        Type:       game.TileFloor,
                                        Walkable:   true,
                                        Properties: map[string]interface{}{"arena": true},
                                }
                        }</span>
                }
        }

        <span class="cov8" title="1">rng := genCtx.RNG

        // Add boss spawn point (center)
        boss := pcg.RoomFeature{
                Type:     "boss_spawn",
                Position: game.Position{X: bounds.X + bounds.Width/2, Y: bounds.Y + bounds.Height/2},
                Properties: map[string]interface{}{
                        "boss_type":  brg.selectBossType(theme, difficulty),
                        "difficulty": difficulty + 2,
                        "phases":     1 + difficulty/8,
                },
        }
        room.Features = append(room.Features, boss)

        // Add environmental features for multi-phase encounters
        phaseCount := 1 + difficulty/8
        for i := 0; i &lt; phaseCount; i++ </span><span class="cov8" title="1">{
                x := 2 + rng.Intn(bounds.Width-4)
                y := 2 + rng.Intn(bounds.Height-4)

                feature := pcg.RoomFeature{
                        Type:     "environmental_hazard",
                        Position: game.Position{X: bounds.X + x, Y: bounds.Y + y},
                        Properties: map[string]interface{}{
                                "phase":   i + 1,
                                "type":    brg.selectHazardType(theme),
                                "trigger": "boss_health_" + fmt.Sprintf("%d", 75-(i*25)),
                        },
                }
                room.Features = append(room.Features, feature)
        }</span>

        // Add single entrance (dramatic entry)
        <span class="cov8" title="1">room.Doors = []game.Position{
                {X: bounds.X + bounds.Width/2, Y: bounds.Y},
        }

        room.Properties["boss_encounter"] = true
        room.Properties["arena_size"] = "large"
        room.Properties["escape_routes"] = brg.generateEscapeRoutes(bounds)

        return room, nil</span>
}

func (brg *BossRoomGenerator) selectBossType(theme pcg.LevelTheme, difficulty int) string <span class="cov8" title="1">{
        switch theme </span>{
        case pcg.ThemeClassic:<span class="cov8" title="1">
                return "dragon"</span>
        case pcg.ThemeHorror:<span class="cov8" title="1">
                return "abomination"</span>
        case pcg.ThemeUndead:<span class="cov8" title="1">
                return "lich"</span>
        case pcg.ThemeMechanical:<span class="cov8" title="1">
                return "war_machine"</span>
        case pcg.ThemeMagical:<span class="cov8" title="1">
                return "archmage"</span>
        case pcg.ThemeElemental:<span class="cov8" title="1">
                return "elemental_lord"</span>
        default:<span class="cov8" title="1">
                return "champion"</span>
        }
}

func (brg *BossRoomGenerator) selectHazardType(theme pcg.LevelTheme) string <span class="cov8" title="1">{
        switch theme </span>{
        case pcg.ThemeClassic:<span class="cov8" title="1">
                return "falling_rocks"</span>
        case pcg.ThemeHorror:<span class="cov8" title="1">
                return "blood_pools"</span>
        case pcg.ThemeMagical:<span class="cov8" title="1">
                return "magic_storm"</span>
        case pcg.ThemeElemental:<span class="cov8" title="1">
                return "elemental_eruption"</span>
        default:<span class="cov8" title="1">
                return "debris"</span>
        }
}

func (brg *BossRoomGenerator) generateEscapeRoutes(bounds pcg.Rectangle) []game.Position <span class="cov8" title="1">{
        // Add potential escape routes for tactical retreats
        return []game.Position{
                {X: bounds.X + 1, Y: bounds.Y + bounds.Height/2},
                {X: bounds.X + bounds.Width - 2, Y: bounds.Y + bounds.Height/2},
        }
}</span>

// Define other room generators with basic implementations

type EntranceRoomGenerator struct{}

func (erg *EntranceRoomGenerator) GenerateRoom(bounds pcg.Rectangle, theme pcg.LevelTheme, difficulty int, genCtx *pcg.GenerationContext) (*pcg.RoomLayout, error) <span class="cov8" title="1">{
        return generateBasicRoom(bounds, "entrance", map[string]interface{}{
                "safe_zone": true,
                "healing":   true,
        })
}</span>

type ExitRoomGenerator struct{}

func (erg *ExitRoomGenerator) GenerateRoom(bounds pcg.Rectangle, theme pcg.LevelTheme, difficulty int, genCtx *pcg.GenerationContext) (*pcg.RoomLayout, error) <span class="cov8" title="1">{
        return generateBasicRoom(bounds, "exit", map[string]interface{}{
                "exit_portal": true,
                "safe_zone":   true,
        })
}</span>

type SecretRoomGenerator struct{}

func (srg *SecretRoomGenerator) GenerateRoom(bounds pcg.Rectangle, theme pcg.LevelTheme, difficulty int, genCtx *pcg.GenerationContext) (*pcg.RoomLayout, error) <span class="cov0" title="0">{
        return generateBasicRoom(bounds, "secret", map[string]interface{}{
                "hidden":       true,
                "special_loot": true,
                "discovery_xp": difficulty * 10,
        })
}</span>

type ShopRoomGenerator struct{}

func (srg *ShopRoomGenerator) GenerateRoom(bounds pcg.Rectangle, theme pcg.LevelTheme, difficulty int, genCtx *pcg.GenerationContext) (*pcg.RoomLayout, error) <span class="cov0" title="0">{
        return generateBasicRoom(bounds, "shop", map[string]interface{}{
                "merchant":    true,
                "safe_zone":   true,
                "buy_prices":  1.0,
                "sell_prices": 0.5,
        })
}</span>

type RestRoomGenerator struct{}

func (rrg *RestRoomGenerator) GenerateRoom(bounds pcg.Rectangle, theme pcg.LevelTheme, difficulty int, genCtx *pcg.GenerationContext) (*pcg.RoomLayout, error) <span class="cov0" title="0">{
        return generateBasicRoom(bounds, "rest", map[string]interface{}{
                "safe_zone":      true,
                "healing":        true,
                "spell_recharge": true,
        })
}</span>

type TrapRoomGenerator struct{}

func (trg *TrapRoomGenerator) GenerateRoom(bounds pcg.Rectangle, theme pcg.LevelTheme, difficulty int, genCtx *pcg.GenerationContext) (*pcg.RoomLayout, error) <span class="cov8" title="1">{
        return generateBasicRoom(bounds, "trap", map[string]interface{}{
                "trap_density": difficulty,
                "hidden_traps": true,
                "danger_level": "high",
        })
}</span>

type StoryRoomGenerator struct{}

func (srg *StoryRoomGenerator) GenerateRoom(bounds pcg.Rectangle, theme pcg.LevelTheme, difficulty int, genCtx *pcg.GenerationContext) (*pcg.RoomLayout, error) <span class="cov0" title="0">{
        return generateBasicRoom(bounds, "story", map[string]interface{}{
                "narrative":   true,
                "safe_zone":   true,
                "lore_points": difficulty,
        })
}</span>

// generateBasicRoom creates a simple room with standard layout
func generateBasicRoom(bounds pcg.Rectangle, roomType string, properties map[string]interface{}) (*pcg.RoomLayout, error) <span class="cov8" title="1">{
        var roomTypeEnum pcg.RoomType
        switch roomType </span>{
        case "entrance":<span class="cov8" title="1">
                roomTypeEnum = pcg.RoomTypeEntrance</span>
        case "exit":<span class="cov8" title="1">
                roomTypeEnum = pcg.RoomTypeExit</span>
        case "secret":<span class="cov0" title="0">
                roomTypeEnum = pcg.RoomTypeSecret</span>
        case "shop":<span class="cov0" title="0">
                roomTypeEnum = pcg.RoomTypeShop</span>
        case "rest":<span class="cov0" title="0">
                roomTypeEnum = pcg.RoomTypeRest</span>
        case "trap":<span class="cov8" title="1">
                roomTypeEnum = pcg.RoomTypeTrap</span>
        case "story":<span class="cov0" title="0">
                roomTypeEnum = pcg.RoomTypeStory</span>
        default:<span class="cov0" title="0">
                roomTypeEnum = pcg.RoomTypeCombat</span>
        }

        <span class="cov8" title="1">room := &amp;pcg.RoomLayout{
                Type:       roomTypeEnum,
                Bounds:     bounds,
                Tiles:      make([][]game.Tile, bounds.Height),
                Doors:      []game.Position{},
                Features:   []pcg.RoomFeature{},
                Properties: properties,
        }

        // Initialize basic room tiles
        for y := 0; y &lt; bounds.Height; y++ </span><span class="cov8" title="1">{
                room.Tiles[y] = make([]game.Tile, bounds.Width)
                for x := 0; x &lt; bounds.Width; x++ </span><span class="cov8" title="1">{
                        if x == 0 || x == bounds.Width-1 || y == 0 || y == bounds.Height-1 </span><span class="cov8" title="1">{
                                room.Tiles[y][x] = game.Tile{
                                        Type:       game.TileWall,
                                        Walkable:   false,
                                        Properties: make(map[string]interface{}),
                                }
                        }</span> else<span class="cov8" title="1"> {
                                room.Tiles[y][x] = game.Tile{
                                        Type:       game.TileFloor,
                                        Walkable:   true,
                                        Properties: make(map[string]interface{}),
                                }
                        }</span>
                }
        }

        // Add basic door
        <span class="cov8" title="1">room.Doors = []game.Position{
                {X: bounds.X + bounds.Width/2, Y: bounds.Y},
        }

        // Add room type specific feature
        if roomType != "entrance" &amp;&amp; roomType != "exit" </span><span class="cov8" title="1">{
                room.Features = append(room.Features, pcg.RoomFeature{
                        Type:       roomType + "_feature",
                        Position:   game.Position{X: bounds.X + bounds.Width/2, Y: bounds.Y + bounds.Height/2},
                        Properties: properties,
                })
        }</span>

        <span class="cov8" title="1">return room, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package pcg

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// PCGManager is the main coordinator for procedural content generation
// Integrates with existing game systems and manages the generation lifecycle
type PCGManager struct {
        registry    *Registry
        factory     *Factory
        validator   *Validator
        logger      *logrus.Logger
        world       *game.World
        seedManager *SeedManager
        metrics     *GenerationMetrics
}

// NewPCGManager creates a new PCG manager instance
func NewPCGManager(world *game.World, logger *logrus.Logger) *PCGManager <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = logrus.New()
        }</span>

        <span class="cov0" title="0">registry := NewRegistry(logger)
        factory := NewFactory(registry, logger)
        validator := NewValidator(false)
        seedManager := NewSeedManager(0) // Will be set by game initialization
        metrics := NewGenerationMetrics()

        return &amp;PCGManager{
                registry:    registry,
                factory:     factory,
                validator:   validator,
                logger:      logger,
                world:       world,
                seedManager: seedManager,
                metrics:     metrics,
        }</span>
}

// InitializeWithSeed sets the base seed for all generation
func (pcg *PCGManager) InitializeWithSeed(seed int64) <span class="cov0" title="0">{
        pcg.seedManager = NewSeedManager(seed)
        pcg.logger.WithField("seed", seed).Info("PCG manager initialized with seed")
}</span>

// RegisterDefaultGenerators registers the built-in generators
func (pcg *PCGManager) RegisterDefaultGenerators() error <span class="cov0" title="0">{
        pcg.logger.Info("Registering default PCG generators")

        // Note: Actual generators are registered by the server initialization
        // to avoid import cycles. This method serves as a placeholder for
        // future expansion and is called to ensure the system is ready.

        return nil
}</span>

// GenerateTerrainForLevel generates terrain for a specific game level
func (pcg *PCGManager) GenerateTerrainForLevel(ctx context.Context, levelID string, width, height int, biome BiomeType, difficulty int) (*game.GameMap, error) <span class="cov0" title="0">{
        startTime := time.Now()
        defer func() </span><span class="cov0" title="0">{
                duration := time.Since(startTime)
                pcg.metrics.RecordGeneration(ContentTypeTerrain, duration)
                pcg.logger.WithFields(logrus.Fields{
                        "content_type": ContentTypeTerrain,
                        "level_id":     levelID,
                        "duration":     duration,
                }).Debug("terrain generation completed")
        }</span>()

        <span class="cov0" title="0">params := TerrainParams{
                GenerationParams: GenerationParams{
                        Seed:        pcg.seedManager.DeriveContextSeed(ContentTypeTerrain, levelID),
                        Difficulty:  difficulty,
                        PlayerLevel: 1, // Could be derived from world state
                        WorldState:  pcg.world,
                        Timeout:     30 * time.Second,
                        Constraints: make(map[string]interface{}),
                },
                BiomeType:    biome,
                Density:      0.45,
                Connectivity: ConnectivityModerate,
                WaterLevel:   0.1,
                Roughness:    0.5,
        }

        // Add terrain-specific constraints
        params.Constraints["width"] = width
        params.Constraints["height"] = height
        params.Constraints["terrain_params"] = params

        gameMap, err := pcg.factory.GenerateTerrain(ctx, "cellular_automata", params)
        if err != nil </span><span class="cov0" title="0">{
                pcg.metrics.RecordError(ContentTypeTerrain)
        }</span>

        <span class="cov0" title="0">return gameMap, err</span>
}

// GenerateItemsForLocation generates items appropriate for a specific location
func (pcg *PCGManager) GenerateItemsForLocation(ctx context.Context, locationID string, itemCount int, minRarity, maxRarity RarityTier, playerLevel int) ([]*game.Item, error) <span class="cov0" title="0">{
        startTime := time.Now()
        defer func() </span><span class="cov0" title="0">{
                duration := time.Since(startTime)
                pcg.metrics.RecordGeneration(ContentTypeItems, duration)
                pcg.logger.WithFields(logrus.Fields{
                        "content_type": ContentTypeItems,
                        "location_id":  locationID,
                        "item_count":   itemCount,
                        "duration":     duration,
                }).Debug("item generation completed")
        }</span>()

        <span class="cov0" title="0">params := ItemParams{
                GenerationParams: GenerationParams{
                        Seed:        pcg.seedManager.DeriveContextSeed(ContentTypeItems, locationID),
                        Difficulty:  pcg.calculateLocationDifficulty(locationID),
                        PlayerLevel: playerLevel,
                        WorldState:  pcg.world,
                        Timeout:     10 * time.Second,
                        Constraints: make(map[string]interface{}),
                },
                MinRarity:       minRarity,
                MaxRarity:       maxRarity,
                EnchantmentRate: 0.2,
                UniqueChance:    0.05,
                LevelScaling:    true,
        }

        // Add item count constraint
        params.Constraints["item_count"] = itemCount

        items, err := pcg.factory.GenerateItems(ctx, "template_based", params)
        if err != nil </span><span class="cov0" title="0">{
                pcg.metrics.RecordError(ContentTypeItems)
        }</span>

        <span class="cov0" title="0">return items, err</span>
}

// GenerateDungeonLevel generates a complete dungeon level
func (pcg *PCGManager) GenerateDungeonLevel(ctx context.Context, levelID string, minRooms, maxRooms int, theme LevelTheme, difficulty int) (*game.Level, error) <span class="cov0" title="0">{
        params := LevelParams{
                GenerationParams: GenerationParams{
                        Seed:        pcg.seedManager.DeriveContextSeed(ContentTypeLevels, levelID),
                        Difficulty:  difficulty,
                        PlayerLevel: pcg.getAveragePartyLevel(),
                        WorldState:  pcg.world,
                        Timeout:     60 * time.Second,
                        Constraints: make(map[string]interface{}),
                },
                MinRooms:      minRooms,
                MaxRooms:      maxRooms,
                RoomTypes:     []RoomType{RoomTypeEntrance, RoomTypeExit, RoomTypeCombat, RoomTypeTreasure},
                CorridorStyle: CorridorWindy,
                LevelTheme:    theme,
                HasBoss:       difficulty &gt;= 10,
                SecretRooms:   maxRooms / 10,
        }

        return pcg.factory.GenerateLevel(ctx, "room_corridor", params)
}</span>

// GenerateQuestForArea generates a quest appropriate for a specific area
func (pcg *PCGManager) GenerateQuestForArea(ctx context.Context, areaID string, questType QuestType, playerLevel int) (*game.Quest, error) <span class="cov0" title="0">{
        params := QuestParams{
                GenerationParams: GenerationParams{
                        Seed:        pcg.seedManager.DeriveContextSeed(ContentTypeQuests, areaID),
                        Difficulty:  pcg.calculateAreaDifficulty(areaID),
                        PlayerLevel: playerLevel,
                        WorldState:  pcg.world,
                        Timeout:     15 * time.Second,
                        Constraints: make(map[string]interface{}),
                },
                QuestType:     questType,
                MinObjectives: 1,
                MaxObjectives: 3,
                RewardTier:    RarityRare,
                Narrative:     NarrativeLinear,
        }

        return pcg.factory.GenerateQuest(ctx, "objective_based", params)
}</span>

// ValidateGeneratedContent validates content before integration into the world
func (pcg *PCGManager) ValidateGeneratedContent(content interface{}) (*ValidationResult, error) <span class="cov0" title="0">{
        switch v := content.(type) </span>{
        case *game.GameMap:<span class="cov0" title="0">
                return pcg.validator.ValidateGameMap(v), nil</span>
        case *game.Item:<span class="cov0" title="0">
                return pcg.validator.ValidateItem(v), nil</span>
        case *game.Level:<span class="cov0" title="0">
                return pcg.validator.ValidateLevel(v), nil</span>
        case *game.Quest:<span class="cov0" title="0">
                return pcg.validator.ValidateQuest(v), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported content type for validation: %T", content)</span>
        }
}

// IntegrateContentIntoWorld integrates generated content into the game world
func (pcg *PCGManager) IntegrateContentIntoWorld(content interface{}, locationID string) error <span class="cov0" title="0">{
        // Validate content before integration
        validationResult, err := pcg.ValidateGeneratedContent(content)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if !validationResult.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("content validation failed: %v", validationResult.Errors)
        }</span>

        // Log warnings if present
        <span class="cov0" title="0">if validationResult.HasWarnings() </span><span class="cov0" title="0">{
                pcg.logger.WithFields(logrus.Fields{
                        "location": locationID,
                        "warnings": validationResult.Warnings,
                }).Warn("Generated content has validation warnings")
        }</span>

        // Integrate based on content type
        <span class="cov0" title="0">switch v := content.(type) </span>{
        case *game.Level:<span class="cov0" title="0">
                return pcg.integrateLevelIntoWorld(v, locationID)</span>
        case *game.Item:<span class="cov0" title="0">
                return pcg.integrateItemIntoWorld(v, locationID)</span>
        case []*game.Item:<span class="cov0" title="0">
                for _, item := range v </span><span class="cov0" title="0">{
                        if err := pcg.integrateItemIntoWorld(item, locationID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported content type for integration: %T", content)</span>
        }
}

// RegenerateContentForLocation regenerates content for a specific location
func (pcg *PCGManager) RegenerateContentForLocation(ctx context.Context, locationID string, contentType ContentType) (interface{}, error) <span class="cov0" title="0">{
        pcg.logger.WithFields(logrus.Fields{
                "location":     locationID,
                "content_type": contentType,
        }).Info("Regenerating content for location")

        // Get current world state for context
        difficulty := pcg.calculateLocationDifficulty(locationID)
        playerLevel := pcg.getAveragePartyLevel()

        switch contentType </span>{
        case ContentTypeTerrain:<span class="cov0" title="0">
                return pcg.GenerateTerrainForLevel(ctx, locationID, 50, 50, BiomeDungeon, difficulty)</span>
        case ContentTypeItems:<span class="cov0" title="0">
                return pcg.GenerateItemsForLocation(ctx, locationID, 3, RarityCommon, RarityRare, playerLevel)</span>
        case ContentTypeLevels:<span class="cov0" title="0">
                return pcg.GenerateDungeonLevel(ctx, locationID, 5, 15, ThemeClassic, difficulty)</span>
        case ContentTypeQuests:<span class="cov0" title="0">
                return pcg.GenerateQuestForArea(ctx, locationID, QuestTypeFetch, playerLevel)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported content type for regeneration: %s", contentType)</span>
        }
}

// GetGenerationStatistics returns statistics about generation activity
func (pcg *PCGManager) GetGenerationStatistics() map[string]interface{} <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Get available generators
        stats["available_generators"] = pcg.registry.ListAllGenerators()

        // Get seed information
        stats["base_seed"] = pcg.seedManager.GetBaseSeed()

        // Include generation metrics
        stats["performance_metrics"] = pcg.metrics.GetStats()

        return stats
}</span>

// GetRegistry returns the generator registry for external registration
func (pcg *PCGManager) GetRegistry() *Registry <span class="cov0" title="0">{
        return pcg.registry
}</span>

// GetMetrics returns the generation metrics instance
func (pcg *PCGManager) GetMetrics() *GenerationMetrics <span class="cov0" title="0">{
        return pcg.metrics
}</span>

// ResetMetrics clears all generation metrics
func (pcg *PCGManager) ResetMetrics() <span class="cov0" title="0">{
        pcg.metrics.Reset()
        pcg.logger.Info("PCG generation metrics reset")
}</span>

// Helper methods for integration

func (pcg *PCGManager) integrateLevelIntoWorld(level *game.Level, locationID string) error <span class="cov0" title="0">{
        // Add level to world - World should provide thread-safe methods for this
        // For now, we'll use a direct approach assuming World has proper synchronization
        pcg.world.Levels = append(pcg.world.Levels, *level)

        pcg.logger.WithFields(logrus.Fields{
                "level_id": level.ID,
                "location": locationID,
                "width":    level.Width,
                "height":   level.Height,
        }).Info("Integrated generated level into world")

        return nil
}</span>

func (pcg *PCGManager) integrateItemIntoWorld(item *game.Item, locationID string) error <span class="cov0" title="0">{
        // Add item to world objects - World should provide thread-safe methods for this
        if pcg.world.Objects == nil </span><span class="cov0" title="0">{
                pcg.world.Objects = make(map[string]game.GameObject)
        }</span>

        <span class="cov0" title="0">pcg.world.Objects[item.ID] = item

        // Update spatial index if available
        if pcg.world.SpatialIndex != nil </span><span class="cov0" title="0">{
                if err := pcg.world.SpatialIndex.Insert(item); err != nil </span><span class="cov0" title="0">{
                        pcg.logger.WithFields(logrus.Fields{
                                "item_id": item.ID,
                                "error":   err.Error(),
                        }).Warn("Failed to add item to spatial index")
                }</span>
        }

        <span class="cov0" title="0">pcg.logger.WithFields(logrus.Fields{
                "item_id":  item.ID,
                "location": locationID,
                "type":     item.Type,
                "value":    item.Value,
        }).Info("Integrated generated item into world")

        return nil</span>
}

// Helper methods for world state analysis

func (pcg *PCGManager) calculateLocationDifficulty(locationID string) int <span class="cov0" title="0">{
        // Analyze world state to determine appropriate difficulty
        // This would examine factors like:
        // - Player party levels
        // - Location depth/progression
        // - Existing challenges in the area
        // - World difficulty curve

        // Simplified implementation
        return 5 // Default moderate difficulty
}</span>

func (pcg *PCGManager) calculateAreaDifficulty(areaID string) int <span class="cov0" title="0">{
        // Similar to location difficulty but for larger areas
        return pcg.calculateLocationDifficulty(areaID)
}</span>

func (pcg *PCGManager) getAveragePartyLevel() int <span class="cov0" title="0">{
        if pcg.world == nil </span><span class="cov0" title="0">{
                return 1
        }</span>

        // Note: In a real implementation, World should provide thread-safe accessors
        <span class="cov0" title="0">if len(pcg.world.Players) == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov0" title="0">totalLevel := 0
        count := 0

        for _, player := range pcg.world.Players </span><span class="cov0" title="0">{
                // Note: Character is a struct, not a pointer, so we check Level directly
                if player.Character.Level &gt; 0 </span><span class="cov0" title="0">{
                        totalLevel += player.Character.Level
                        count++
                }</span>
        }

        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov0" title="0">return totalLevel / count</span>
}

// convertMapContent attempts to convert map[string]interface{} content to appropriate struct types
func (pcg *PCGManager) convertMapContent(content map[string]interface{}, contentType string) (interface{}, error) <span class="cov0" title="0">{
        // Convert map back to JSON, then unmarshal to the correct type
        jsonData, err := json.Marshal(content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal content: %w", err)
        }</span>

        <span class="cov0" title="0">switch contentType </span>{
        case "quests":<span class="cov0" title="0">
                var quest game.Quest
                if err := json.Unmarshal(jsonData, &amp;quest); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal quest content: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;quest, nil</span>
        case "items":<span class="cov0" title="0">
                var item game.Item
                if err := json.Unmarshal(jsonData, &amp;item); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal item content: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;item, nil</span>
        case "levels":<span class="cov0" title="0">
                var level game.Level
                if err := json.Unmarshal(jsonData, &amp;level); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal level content: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;level, nil</span>
        case "maps":<span class="cov0" title="0">
                var gameMap game.GameMap
                if err := json.Unmarshal(jsonData, &amp;gameMap); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal map content: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;gameMap, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported content type for conversion: %s", contentType)</span>
        }
}

// ValidateGeneratedContentWithType validates content with explicit type information
func (pcg *PCGManager) ValidateGeneratedContentWithType(content interface{}, contentType string) (*ValidationResult, error) <span class="cov0" title="0">{
        // Handle map[string]interface{} content by converting to proper types
        if mapContent, ok := content.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                convertedContent, err := pcg.convertMapContent(mapContent, contentType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert map content: %w", err)
                }</span>
                <span class="cov0" title="0">content = convertedContent</span>
        }

        <span class="cov0" title="0">return pcg.ValidateGeneratedContent(content)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package pcg

import (
        "sync"
        "time"
)

// GenerationMetrics tracks performance statistics
type GenerationMetrics struct {
        mu               sync.RWMutex
        GenerationCounts map[ContentType]int64         `json:"generation_counts"`
        AverageTimings   map[ContentType]time.Duration `json:"average_timings"`
        ErrorCounts      map[ContentType]int64         `json:"error_counts"`
        CacheHits        int64                         `json:"cache_hits"`
        CacheMisses      int64                         `json:"cache_misses"`
        TotalGenerations int64                         `json:"total_generations"`
}

// NewGenerationMetrics creates a new metrics tracker
func NewGenerationMetrics() *GenerationMetrics <span class="cov8" title="1">{
        return &amp;GenerationMetrics{
                GenerationCounts: make(map[ContentType]int64),
                AverageTimings:   make(map[ContentType]time.Duration),
                ErrorCounts:      make(map[ContentType]int64),
        }
}</span>

// RecordGeneration records a successful generation
func (gm *GenerationMetrics) RecordGeneration(contentType ContentType, duration time.Duration) <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.GenerationCounts[contentType]++
        gm.TotalGenerations++

        // Update rolling average
        if current, exists := gm.AverageTimings[contentType]; exists </span><span class="cov8" title="1">{
                count := gm.GenerationCounts[contentType]
                gm.AverageTimings[contentType] = (current*time.Duration(count-1) + duration) / time.Duration(count)
        }</span> else<span class="cov8" title="1"> {
                gm.AverageTimings[contentType] = duration
        }</span>
}

// RecordError records a generation error
func (gm *GenerationMetrics) RecordError(contentType ContentType) <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.ErrorCounts[contentType]++
}</span>

// RecordCacheHit records a cache hit
func (gm *GenerationMetrics) RecordCacheHit() <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.CacheHits++
}</span>

// RecordCacheMiss records a cache miss
func (gm *GenerationMetrics) RecordCacheMiss() <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.CacheMisses++
}</span>

// GetStats returns current performance statistics
func (gm *GenerationMetrics) GetStats() map[string]interface{} <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        return map[string]interface{}{
                "generation_counts": gm.GenerationCounts,
                "average_timings":   gm.AverageTimings,
                "error_counts":      gm.ErrorCounts,
                "cache_hits":        gm.CacheHits,
                "cache_misses":      gm.CacheMisses,
                "total_generations": gm.TotalGenerations,
        }
}</span>

// GetGenerationCount returns the total generation count for a content type
func (gm *GenerationMetrics) GetGenerationCount(contentType ContentType) int64 <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        return gm.GenerationCounts[contentType]
}</span>

// GetAverageTiming returns the average generation time for a content type
func (gm *GenerationMetrics) GetAverageTiming(contentType ContentType) time.Duration <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        return gm.AverageTimings[contentType]
}</span>

// GetErrorCount returns the total error count for a content type
func (gm *GenerationMetrics) GetErrorCount(contentType ContentType) int64 <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        return gm.ErrorCounts[contentType]
}</span>

// GetCacheHitRatio returns the cache hit ratio as a percentage
func (gm *GenerationMetrics) GetCacheHitRatio() float64 <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        total := gm.CacheHits + gm.CacheMisses
        if total == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        <span class="cov8" title="1">return float64(gm.CacheHits) / float64(total) * 100.0</span>
}

// Reset clears all metrics data
func (gm *GenerationMetrics) Reset() <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.GenerationCounts = make(map[ContentType]int64)
        gm.AverageTimings = make(map[ContentType]time.Duration)
        gm.ErrorCounts = make(map[ContentType]int64)
        gm.CacheHits = 0
        gm.CacheMisses = 0
        gm.TotalGenerations = 0
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package quests

import (
        "context"
        "fmt"
        "math/rand"

        "goldbox-rpg/pkg/game"
        "goldbox-rpg/pkg/pcg"
)

// ObjectiveBasedGenerator creates quests using objective templates
type ObjectiveBasedGenerator struct {
        version            string
        objectiveTemplates map[pcg.QuestType][]*ObjectiveTemplate
        narrativeEngine    *NarrativeEngine
}

// ObjectiveTemplate defines the structure of quest objectives
type ObjectiveTemplate struct {
        Type         string   `yaml:"type"`
        Description  string   `yaml:"description"`
        Requirements []string `yaml:"requirements"`
        Targets      []string `yaml:"targets"`
        Quantities   [2]int   `yaml:"quantities"`
        Rewards      []string `yaml:"rewards"`
}

// NewObjectiveBasedGenerator creates a new objective-based quest generator
func NewObjectiveBasedGenerator() *ObjectiveBasedGenerator <span class="cov8" title="1">{
        obg := &amp;ObjectiveBasedGenerator{
                version:            "1.0.0",
                objectiveTemplates: make(map[pcg.QuestType][]*ObjectiveTemplate),
                narrativeEngine:    NewNarrativeEngine(),
        }

        // Initialize default templates
        obg.initializeDefaultTemplates()

        return obg
}</span>

// GetType returns the content type this generator produces
func (obg *ObjectiveBasedGenerator) GetType() pcg.ContentType <span class="cov8" title="1">{
        return pcg.ContentTypeQuests
}</span>

// GetVersion returns the generator version for compatibility checking
func (obg *ObjectiveBasedGenerator) GetVersion() string <span class="cov8" title="1">{
        return obg.version
}</span>

// Validate checks if the provided parameters are valid for this generator
func (obg *ObjectiveBasedGenerator) Validate(params pcg.GenerationParams) error <span class="cov8" title="1">{
        if params.Difficulty &lt; 1 || params.Difficulty &gt; 20 </span><span class="cov8" title="1">{
                return fmt.Errorf("difficulty must be between 1 and 20")
        }</span>

        // Check constraint validity if provided
        <span class="cov8" title="1">if minObj, ok := params.Constraints["min_objectives"].(int); ok </span><span class="cov8" title="1">{
                if minObj &lt; 1 </span><span class="cov8" title="1">{
                        return fmt.Errorf("min_objectives must be at least 1")
                }</span>
        }

        <span class="cov8" title="1">if maxObj, ok := params.Constraints["max_objectives"].(int); ok </span><span class="cov8" title="1">{
                if minObj, ok := params.Constraints["min_objectives"].(int); ok </span><span class="cov8" title="1">{
                        if maxObj &lt; minObj </span><span class="cov8" title="1">{
                                return fmt.Errorf("max_objectives must be &gt;= min_objectives")
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// Generate implements the Generator interface
func (obg *ObjectiveBasedGenerator) Generate(ctx context.Context, params pcg.GenerationParams) (interface{}, error) <span class="cov8" title="1">{
        if err := obg.Validate(params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parameter validation failed: %w", err)
        }</span>

        // Create quest parameters from generation parameters
        <span class="cov8" title="1">questParams := pcg.QuestParams{
                GenerationParams: params,
                QuestType:        pcg.QuestTypeFetch, // Default quest type
                MinObjectives:    1,
                MaxObjectives:    3,
                RewardTier:       pcg.RarityCommon,
                Narrative:        pcg.NarrativeLinear,
                RequiredItems:    []string{},
                ForbiddenItems:   []string{},
        }

        // Extract quest type from constraints if provided
        if questTypeStr, ok := params.Constraints["quest_type"].(string); ok </span><span class="cov8" title="1">{
                questParams.QuestType = pcg.QuestType(questTypeStr)
        }</span>

        // Extract objective counts from constraints if provided
        <span class="cov8" title="1">if minObj, ok := params.Constraints["min_objectives"].(int); ok </span><span class="cov8" title="1">{
                questParams.MinObjectives = minObj
        }</span>
        <span class="cov8" title="1">if maxObj, ok := params.Constraints["max_objectives"].(int); ok </span><span class="cov8" title="1">{
                questParams.MaxObjectives = maxObj
        }</span>

        // Extract reward tier from constraints if provided
        <span class="cov8" title="1">if rewardTierStr, ok := params.Constraints["reward_tier"].(string); ok </span><span class="cov8" title="1">{
                questParams.RewardTier = pcg.RarityTier(rewardTierStr)
        }</span>

        <span class="cov8" title="1">return obg.GenerateQuest(ctx, questParams.QuestType, questParams)</span>
}

// GenerateQuest creates a quest with objectives and narrative
func (obg *ObjectiveBasedGenerator) GenerateQuest(ctx context.Context, questType pcg.QuestType, params pcg.QuestParams) (*game.Quest, error) <span class="cov8" title="1">{
        // Create deterministic random generator from seed
        rng := rand.New(rand.NewSource(params.Seed))

        // Generate quest ID
        questID := fmt.Sprintf("quest_%d_%s", params.Seed, questType)

        // Generate objectives
        objectiveCount := rng.Intn(params.MaxObjectives-params.MinObjectives+1) + params.MinObjectives
        objectives, err := obg.generateObjectives(ctx, questType, objectiveCount, params, rng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate objectives: %w", err)
        }</span>

        // Generate narrative context
        <span class="cov8" title="1">narrative, err := obg.narrativeEngine.GenerateQuestNarrative(questType, objectives, params, rng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate narrative: %w", err)
        }</span>

        // Generate rewards
        <span class="cov8" title="1">rewards, err := obg.generateRewards(params.Difficulty, params.RewardTier, rng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate rewards: %w", err)
        }</span>

        // Convert objectives to game format
        <span class="cov8" title="1">gameObjectives := make([]game.QuestObjective, len(objectives))
        for i, obj := range objectives </span><span class="cov8" title="1">{
                gameObjectives[i] = game.QuestObjective{
                        Description: obj.Description,
                        Progress:    0,
                        Required:    obj.Quantity,
                        Completed:   false,
                }
        }</span>

        // Create the quest
        <span class="cov8" title="1">quest := &amp;game.Quest{
                ID:          questID,
                Title:       narrative.Title,
                Description: narrative.Description,
                Status:      game.QuestNotStarted,
                Objectives:  gameObjectives,
                Rewards:     rewards,
        }

        return quest, nil</span>
}

// GenerateQuestChain creates a series of connected quests
func (obg *ObjectiveBasedGenerator) GenerateQuestChain(ctx context.Context, chainLength int, params pcg.QuestParams) ([]*game.Quest, error) <span class="cov8" title="1">{
        if chainLength &lt; 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("chain length must be at least 1")
        }</span>

        <span class="cov8" title="1">quests := make([]*game.Quest, 0, chainLength)
        rng := rand.New(rand.NewSource(params.Seed))

        for i := 0; i &lt; chainLength; i++ </span><span class="cov8" title="1">{
                // Create modified parameters for this quest in the chain
                chainParams := params
                chainParams.Seed = rng.Int63() // Derive new seed for each quest

                // Scale difficulty slightly for later quests in chain
                chainParams.Difficulty += i / 2
                if chainParams.Difficulty &gt; 20 </span><span class="cov0" title="0">{
                        chainParams.Difficulty = 20
                }</span>

                <span class="cov8" title="1">quest, err := obg.GenerateQuest(ctx, params.QuestType, chainParams)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate quest %d in chain: %w", i+1, err)
                }</span>

                // Modify quest title to indicate chain position
                <span class="cov8" title="1">if chainLength &gt; 1 </span><span class="cov8" title="1">{
                        quest.Title = fmt.Sprintf("%s (Part %d)", quest.Title, i+1)
                }</span>

                <span class="cov8" title="1">quests = append(quests, quest)</span>
        }

        <span class="cov8" title="1">return quests, nil</span>
}

// GenerateObjectives creates quest objectives based on available content
func (obg *ObjectiveBasedGenerator) GenerateObjectives(ctx context.Context, world *game.World, params pcg.QuestParams) ([]pcg.QuestObjective, error) <span class="cov8" title="1">{
        rng := rand.New(rand.NewSource(params.Seed))
        objectiveCount := rng.Intn(params.MaxObjectives-params.MinObjectives+1) + params.MinObjectives

        return obg.generateObjectives(ctx, params.QuestType, objectiveCount, params, rng)
}</span>

// generateObjectives creates specific quest objectives
func (obg *ObjectiveBasedGenerator) generateObjectives(ctx context.Context, questType pcg.QuestType, count int, params pcg.QuestParams, rng *rand.Rand) ([]pcg.QuestObjective, error) <span class="cov8" title="1">{
        templates, exists := obg.objectiveTemplates[questType]
        if !exists || len(templates) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no objective templates available for quest type: %s", questType)
        }</span>

        <span class="cov8" title="1">objectives := make([]pcg.QuestObjective, 0, count)

        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                // Select random template
                template := templates[rng.Intn(len(templates))]

                // Determine quantity based on difficulty and template
                minQty, maxQty := template.Quantities[0], template.Quantities[1]
                if maxQty &lt;= minQty </span><span class="cov8" title="1">{
                        maxQty = minQty + 1
                }</span>

                // Scale quantity based on difficulty
                <span class="cov8" title="1">difficultyScale := float64(params.Difficulty) / 10.0
                scaledMax := int(float64(maxQty) * difficultyScale)
                if scaledMax &lt; minQty </span><span class="cov8" title="1">{
                        scaledMax = minQty
                }</span>

                <span class="cov8" title="1">quantity := rng.Intn(scaledMax-minQty+1) + minQty

                // Select target
                target := ""
                if len(template.Targets) &gt; 0 </span><span class="cov8" title="1">{
                        target = template.Targets[rng.Intn(len(template.Targets))]
                }</span>

                <span class="cov8" title="1">objective := pcg.QuestObjective{
                        ID:          fmt.Sprintf("obj_%d_%d", params.Seed, i),
                        Type:        template.Type,
                        Description: template.Description,
                        Target:      target,
                        Quantity:    quantity,
                        Progress:    0,
                        Complete:    false,
                        Optional:    i &gt;= 1 &amp;&amp; rng.Float32() &lt; 0.3, // 30% chance for optional objectives after first
                        Conditions:  make(map[string]interface{}),
                }

                objectives = append(objectives, objective)</span>
        }

        <span class="cov8" title="1">return objectives, nil</span>
}

// generateRewards creates appropriate rewards for quest completion
func (obg *ObjectiveBasedGenerator) generateRewards(difficulty int, tier pcg.RarityTier, rng *rand.Rand) ([]game.QuestReward, error) <span class="cov8" title="1">{
        rewards := make([]game.QuestReward, 0, 3)

        // Always include experience reward
        expReward := game.QuestReward{
                Type:  "exp",
                Value: difficulty * 100 * (rng.Intn(3) + 1), // 100-300 exp per difficulty level
        }
        rewards = append(rewards, expReward)

        // Add gold reward with 80% probability
        if rng.Float32() &lt; 0.8 </span><span class="cov8" title="1">{
                goldReward := game.QuestReward{
                        Type:  "gold",
                        Value: difficulty * 25 * (rng.Intn(4) + 1), // 25-100 gold per difficulty level
                }
                rewards = append(rewards, goldReward)
        }</span>

        // Add item reward based on tier and difficulty
        <span class="cov8" title="1">if difficulty &gt;= 3 &amp;&amp; rng.Float32() &lt; 0.6 </span><span class="cov8" title="1">{
                itemReward := game.QuestReward{
                        Type:   "item",
                        Value:  1,
                        ItemID: fmt.Sprintf("quest_item_%s_%d", tier, rng.Intn(1000)),
                }
                rewards = append(rewards, itemReward)
        }</span>

        <span class="cov8" title="1">return rewards, nil</span>
}

// initializeDefaultTemplates sets up basic objective templates for each quest type
func (obg *ObjectiveBasedGenerator) initializeDefaultTemplates() <span class="cov8" title="1">{
        // Kill quest templates
        obg.objectiveTemplates[pcg.QuestTypeKill] = []*ObjectiveTemplate{
                {
                        Type:         "kill",
                        Description:  "Defeat the dangerous creatures",
                        Requirements: []string{"combat"},
                        Targets:      []string{"goblin", "orc", "skeleton", "wolf"},
                        Quantities:   [2]int{3, 8},
                        Rewards:      []string{"exp", "gold"},
                },
                {
                        Type:         "kill_boss",
                        Description:  "Slay the powerful enemy leader",
                        Requirements: []string{"combat", "tactics"},
                        Targets:      []string{"orc_chief", "goblin_king", "dark_wizard"},
                        Quantities:   [2]int{1, 1},
                        Rewards:      []string{"exp", "gold", "item"},
                },
        }

        // Fetch quest templates
        obg.objectiveTemplates[pcg.QuestTypeFetch] = []*ObjectiveTemplate{
                {
                        Type:         "collect",
                        Description:  "Gather the required materials",
                        Requirements: []string{"exploration"},
                        Targets:      []string{"herb", "crystal", "scroll", "key"},
                        Quantities:   [2]int{5, 15},
                        Rewards:      []string{"exp", "gold"},
                },
                {
                        Type:         "retrieve",
                        Description:  "Recover the lost artifact",
                        Requirements: []string{"exploration", "combat"},
                        Targets:      []string{"ancient_relic", "magic_tome", "royal_crown"},
                        Quantities:   [2]int{1, 1},
                        Rewards:      []string{"exp", "gold", "item"},
                },
        }

        // Explore quest templates
        obg.objectiveTemplates[pcg.QuestTypeExplore] = []*ObjectiveTemplate{
                {
                        Type:         "discover",
                        Description:  "Explore the uncharted territory",
                        Requirements: []string{"movement"},
                        Targets:      []string{"cave", "ruins", "forest", "mountain"},
                        Quantities:   [2]int{1, 3},
                        Rewards:      []string{"exp", "gold"},
                },
                {
                        Type:         "map",
                        Description:  "Chart the area completely",
                        Requirements: []string{"movement", "observation"},
                        Targets:      []string{"dungeon_level", "wilderness_area"},
                        Quantities:   [2]int{80, 100}, // Percentage
                        Rewards:      []string{"exp", "gold"},
                },
        }

        // Delivery quest templates
        obg.objectiveTemplates[pcg.QuestTypeDelivery] = []*ObjectiveTemplate{
                {
                        Type:         "deliver",
                        Description:  "Transport the package safely",
                        Requirements: []string{"movement"},
                        Targets:      []string{"merchant", "guard", "scholar", "noble"},
                        Quantities:   [2]int{1, 3},
                        Rewards:      []string{"exp", "gold"},
                },
        }

        // Escort quest templates
        obg.objectiveTemplates[pcg.QuestTypeEscort] = []*ObjectiveTemplate{
                {
                        Type:         "escort",
                        Description:  "Guide the traveler to safety",
                        Requirements: []string{"movement", "protection"},
                        Targets:      []string{"merchant", "diplomat", "pilgrim"},
                        Quantities:   [2]int{1, 1},
                        Rewards:      []string{"exp", "gold"},
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package quests

import (
        "fmt"
        "math/rand"

        "goldbox-rpg/pkg/pcg"
)

// NarrativeEngine generates quest stories and dialogue
type NarrativeEngine struct {
        storyTemplates map[pcg.QuestType][]*StoryTemplate
        characterPool  []*NPCTemplate
}

// StoryTemplate defines narrative structure
type StoryTemplate struct {
        Theme      string   `yaml:"theme"`
        Setup      string   `yaml:"setup"`
        Motivation string   `yaml:"motivation"`
        Climax     string   `yaml:"climax"`
        Resolution string   `yaml:"resolution"`
        Characters []string `yaml:"characters"`
        Locations  []string `yaml:"locations"`
}

// NPCTemplate defines quest-giver characteristics
type NPCTemplate struct {
        Archetype   string   `yaml:"archetype"`
        Personality []string `yaml:"personality"`
        Motivations []string `yaml:"motivations"`
        Speech      []string `yaml:"speech_patterns"`
}

// QuestNarrative holds the complete story context
type QuestNarrative struct {
        Title         string `yaml:"title"`
        Description   string `yaml:"description"`
        QuestGiver    string `yaml:"quest_giver"`
        StartDialogue string `yaml:"start_dialogue"`
        EndDialogue   string `yaml:"end_dialogue"`
        Lore          string `yaml:"lore"`
}

// NewNarrativeEngine creates a new narrative engine
func NewNarrativeEngine() *NarrativeEngine <span class="cov8" title="1">{
        ne := &amp;NarrativeEngine{
                storyTemplates: make(map[pcg.QuestType][]*StoryTemplate),
                characterPool:  make([]*NPCTemplate, 0),
        }

        // Initialize default templates
        ne.initializeDefaultTemplates()

        return ne
}</span>

// GenerateQuestNarrative creates story context for a quest
func (ne *NarrativeEngine) GenerateQuestNarrative(questType pcg.QuestType, objectives []pcg.QuestObjective, params pcg.QuestParams, rng *rand.Rand) (*QuestNarrative, error) <span class="cov8" title="1">{
        templates, exists := ne.storyTemplates[questType]
        if !exists || len(templates) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no story templates available for quest type: %s", questType)
        }</span>

        // Select random template
        <span class="cov8" title="1">template := templates[rng.Intn(len(templates))]

        // Select quest giver
        questGiver := ne.selectQuestGiver(rng)

        // Generate title based on quest type and objectives
        title := ne.generateTitle(questType, objectives, rng)

        // Create description combining setup and objectives
        description := ne.generateDescription(template, objectives, rng)

        // Generate dialogue
        startDialogue := ne.generateStartDialogue(template, questGiver, rng)
        endDialogue := ne.generateEndDialogue(template, questGiver, rng)

        narrative := &amp;QuestNarrative{
                Title:         title,
                Description:   description,
                QuestGiver:    questGiver.Archetype,
                StartDialogue: startDialogue,
                EndDialogue:   endDialogue,
                Lore:          template.Setup,
        }

        return narrative, nil</span>
}

// selectQuestGiver chooses an appropriate NPC for the quest
func (ne *NarrativeEngine) selectQuestGiver(rng *rand.Rand) *NPCTemplate <span class="cov8" title="1">{
        if len(ne.characterPool) == 0 </span><span class="cov0" title="0">{
                // Return default quest giver if no templates available
                return &amp;NPCTemplate{
                        Archetype:   "Village Elder",
                        Personality: []string{"wise", "concerned"},
                        Motivations: []string{"protect village", "maintain peace"},
                        Speech:      []string{"formal", "respectful"},
                }
        }</span>

        <span class="cov8" title="1">return ne.characterPool[rng.Intn(len(ne.characterPool))]</span>
}

// generateTitle creates an appropriate quest title
func (ne *NarrativeEngine) generateTitle(questType pcg.QuestType, objectives []pcg.QuestObjective, rng *rand.Rand) string <span class="cov8" title="1">{
        titlePrefixes := map[pcg.QuestType][]string{
                pcg.QuestTypeKill:     {"Eliminate", "Destroy", "Hunt", "Slay"},
                pcg.QuestTypeFetch:    {"Retrieve", "Collect", "Gather", "Find"},
                pcg.QuestTypeExplore:  {"Explore", "Discover", "Chart", "Scout"},
                pcg.QuestTypeDelivery: {"Deliver", "Transport", "Carry", "Bring"},
                pcg.QuestTypeEscort:   {"Escort", "Guard", "Protect", "Guide"},
                pcg.QuestTypeDefend:   {"Defend", "Protect", "Guard", "Hold"},
                pcg.QuestTypePuzzle:   {"Solve", "Unravel", "Decode", "Unlock"},
        }

        prefixes, exists := titlePrefixes[questType]
        if !exists || len(prefixes) == 0 </span><span class="cov8" title="1">{
                prefixes = []string{"Complete", "Accomplish"}
        }</span>

        <span class="cov8" title="1">prefix := prefixes[rng.Intn(len(prefixes))]

        suffixes := []string{
                "the Threat", "the Challenge", "the Mission", "the Task",
                "the Problem", "the Request", "the Duty", "the Assignment",
        }

        suffix := suffixes[rng.Intn(len(suffixes))]

        return fmt.Sprintf("%s %s", prefix, suffix)</span>
}

// generateDescription creates a quest description
func (ne *NarrativeEngine) generateDescription(template *StoryTemplate, objectives []pcg.QuestObjective, rng *rand.Rand) string <span class="cov8" title="1">{
        baseDesc := template.Setup

        // Add objective-specific details
        if len(objectives) &gt; 0 </span><span class="cov8" title="1">{
                mainObjective := objectives[0]
                baseDesc += fmt.Sprintf(" You must %s", mainObjective.Description)

                if len(objectives) &gt; 1 </span><span class="cov8" title="1">{
                        baseDesc += fmt.Sprintf(" and complete %d additional tasks", len(objectives)-1)
                }</span>
                <span class="cov8" title="1">baseDesc += "."</span>
        }

        <span class="cov8" title="1">return baseDesc</span>
}

// generateStartDialogue creates quest start dialogue
func (ne *NarrativeEngine) generateStartDialogue(template *StoryTemplate, questGiver *NPCTemplate, rng *rand.Rand) string <span class="cov8" title="1">{
        greetings := []string{
                "Greetings, adventurer!",
                "Ah, you look capable.",
                "Thank goodness you're here.",
                "I've been hoping someone like you would come along.",
        }

        greeting := greetings[rng.Intn(len(greetings))]

        return fmt.Sprintf("%s %s %s", greeting, template.Motivation, "Will you help us?")
}</span>

// generateEndDialogue creates quest completion dialogue
func (ne *NarrativeEngine) generateEndDialogue(template *StoryTemplate, questGiver *NPCTemplate, rng *rand.Rand) string <span class="cov8" title="1">{
        thanks := []string{
                "Excellent work!",
                "You've done it!",
                "Marvelous!",
                "I knew you could do it!",
        }

        thank := thanks[rng.Intn(len(thanks))]

        return fmt.Sprintf("%s %s Please accept this reward as thanks for your service.", thank, template.Resolution)
}</span>

// initializeDefaultTemplates sets up basic story templates
func (ne *NarrativeEngine) initializeDefaultTemplates() <span class="cov8" title="1">{
        // Kill quest templates
        ne.storyTemplates[pcg.QuestTypeKill] = []*StoryTemplate{
                {
                        Theme:      "Monster Threat",
                        Setup:      "Dangerous creatures have been terrorizing the local area.",
                        Motivation: "We need someone brave enough to deal with these monsters.",
                        Climax:     "The final beast falls before your might.",
                        Resolution: "Peace has been restored to the region.",
                        Characters: []string{"worried_villager", "town_guard"},
                        Locations:  []string{"village", "forest", "cave"},
                },
                {
                        Theme:      "Bandit Problem",
                        Setup:      "A group of bandits has been raiding trade routes.",
                        Motivation: "Our merchants can't travel safely anymore.",
                        Climax:     "The bandit leader is defeated.",
                        Resolution: "Trade can resume safely once more.",
                        Characters: []string{"merchant", "caravan_master"},
                        Locations:  []string{"road", "hideout", "camp"},
                },
        }

        // Fetch quest templates
        ne.storyTemplates[pcg.QuestTypeFetch] = []*StoryTemplate{
                {
                        Theme:      "Lost Artifact",
                        Setup:      "An important artifact has gone missing from our collection.",
                        Motivation: "We suspect it may have been taken to the old ruins.",
                        Climax:     "You discover the artifact in the depths of the ruins.",
                        Resolution: "The artifact has been safely returned.",
                        Characters: []string{"scholar", "curator", "priest"},
                        Locations:  []string{"library", "ruins", "temple"},
                },
                {
                        Theme:      "Magical Components",
                        Setup:      "We require rare materials for an important ritual.",
                        Motivation: "These components can only be found in dangerous places.",
                        Climax:     "You gather the last of the required materials.",
                        Resolution: "The ritual can now proceed as planned.",
                        Characters: []string{"wizard", "alchemist", "druid"},
                        Locations:  []string{"tower", "swamp", "mountain"},
                },
        }

        // Explore quest templates
        ne.storyTemplates[pcg.QuestTypeExplore] = []*StoryTemplate{
                {
                        Theme:      "Uncharted Territory",
                        Setup:      "Strange reports have come from the unexplored regions.",
                        Motivation: "We need scouts to investigate these claims.",
                        Climax:     "You uncover the truth behind the mysterious reports.",
                        Resolution: "Your findings will help us prepare for what lies ahead.",
                        Characters: []string{"explorer", "cartographer", "scout"},
                        Locations:  []string{"wilderness", "unknown_region", "frontier"},
                },
        }

        // Initialize character pool
        ne.characterPool = []*NPCTemplate{
                {
                        Archetype:   "Village Elder",
                        Personality: []string{"wise", "patient", "caring"},
                        Motivations: []string{"protect village", "preserve traditions"},
                        Speech:      []string{"formal", "measured"},
                },
                {
                        Archetype:   "Town Guard Captain",
                        Personality: []string{"duty-bound", "serious", "protective"},
                        Motivations: []string{"maintain order", "protect citizens"},
                        Speech:      []string{"direct", "military"},
                },
                {
                        Archetype:   "Merchant",
                        Personality: []string{"practical", "worried", "grateful"},
                        Motivations: []string{"profit", "safe trade"},
                        Speech:      []string{"business-like", "persuasive"},
                },
                {
                        Archetype:   "Scholar",
                        Personality: []string{"curious", "thoughtful", "academic"},
                        Motivations: []string{"knowledge", "research"},
                        Speech:      []string{"verbose", "precise"},
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package quests

import (
        "fmt"

        "goldbox-rpg/pkg/game"
        "goldbox-rpg/pkg/pcg"
)

// ObjectiveGenerator creates specific quest objectives
type ObjectiveGenerator struct {
        world *game.World
}

// NewObjectiveGenerator creates an objective generator
func NewObjectiveGenerator(world *game.World) *ObjectiveGenerator <span class="cov8" title="1">{
        return &amp;ObjectiveGenerator{world: world}
}</span>

// GenerateKillObjective creates kill/defeat objectives
func (og *ObjectiveGenerator) GenerateKillObjective(difficulty int, genCtx *pcg.GenerationContext) (*pcg.QuestObjective, error) <span class="cov8" title="1">{
        if genCtx == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("generation context cannot be nil")
        }</span>

        <span class="cov8" title="1">if difficulty &lt; 1 || difficulty &gt; 10 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("difficulty must be between 1 and 10, got %d", difficulty)
        }</span>
        // Select appropriate enemy types for difficulty
        <span class="cov8" title="1">enemyTypes := og.selectEnemyTypesForDifficulty(difficulty)
        if len(enemyTypes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no enemy types available for difficulty %d", difficulty)
        }</span>

        <span class="cov8" title="1">rng := genCtx.RNG
        enemyType := enemyTypes[rng.Intn(len(enemyTypes))]

        // Determine quantity based on challenge rating
        minQuantity := max(1, difficulty/2)
        maxQuantity := difficulty + 2
        quantity := minQuantity + rng.Intn(maxQuantity-minQuantity+1)

        // Choose location from available areas
        locations := og.getAvailableLocations()
        if len(locations) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no locations available for kill objective")
        }</span>
        <span class="cov8" title="1">location := locations[rng.Intn(len(locations))]

        objective := &amp;pcg.QuestObjective{
                ID:          fmt.Sprintf("obj_%d", rng.Int63()),
                Type:        "kill",
                Description: fmt.Sprintf("Defeat %d %s in %s", quantity, enemyType, location),
                Target:      enemyType,
                Quantity:    quantity,
                Progress:    0,
                Complete:    false,
                Optional:    false,
                Conditions:  map[string]interface{}{"location": location},
        }

        return objective, nil</span>
}

// GenerateFetchObjective creates item retrieval objectives
func (og *ObjectiveGenerator) GenerateFetchObjective(playerLevel int, genCtx *pcg.GenerationContext) (*pcg.QuestObjective, error) <span class="cov8" title="1">{
        if genCtx == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("generation context cannot be nil")
        }</span>

        <span class="cov8" title="1">if playerLevel &lt; 1 || playerLevel &gt; 20 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("player level must be between 1 and 20, got %d", playerLevel)
        }</span>

        // Select item types appropriate for level
        <span class="cov8" title="1">itemTypes := og.selectItemTypesForLevel(playerLevel)
        if len(itemTypes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no item types available for level %d", playerLevel)
        }</span>

        <span class="cov8" title="1">rng := genCtx.RNG
        itemType := itemTypes[rng.Intn(len(itemTypes))]

        // Determine quantity (usually 1 for fetch quests, but can be more for common items)
        quantity := 1
        if isCommonItem(itemType) </span><span class="cov8" title="1">{
                quantity = 1 + rng.Intn(3) // 1-3 for common items
        }</span>

        // Choose pickup and delivery locations
        <span class="cov8" title="1">locations := og.getAvailableLocations()
        if len(locations) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("need at least 2 locations for fetch objective")
        }</span>

        <span class="cov8" title="1">pickupLocation := locations[rng.Intn(len(locations))]
        deliveryLocation := locations[rng.Intn(len(locations))]
        // Ensure different locations
        for deliveryLocation == pickupLocation &amp;&amp; len(locations) &gt; 1 </span><span class="cov0" title="0">{
                deliveryLocation = locations[rng.Intn(len(locations))]
        }</span>

        <span class="cov8" title="1">objective := &amp;pcg.QuestObjective{
                ID:          fmt.Sprintf("obj_%d", rng.Int63()),
                Type:        "fetch",
                Description: fmt.Sprintf("Retrieve %d %s from %s and deliver to %s", quantity, itemType, pickupLocation, deliveryLocation),
                Target:      itemType,
                Quantity:    quantity,
                Progress:    0,
                Complete:    false,
                Optional:    false,
                Conditions:  map[string]interface{}{"pickup": pickupLocation, "delivery": deliveryLocation},
        }

        return objective, nil</span>
}

// GenerateExploreObjective creates exploration objectives
func (og *ObjectiveGenerator) GenerateExploreObjective(worldState *game.World, genCtx *pcg.GenerationContext) (*pcg.QuestObjective, error) <span class="cov8" title="1">{
        if genCtx == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("generation context cannot be nil")
        }</span>
        // Identify unexplored or partially explored areas
        <span class="cov8" title="1">unexploredAreas := og.getUnexploredAreas(worldState)
        if len(unexploredAreas) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no unexplored areas available")
        }</span>

        <span class="cov8" title="1">rng := genCtx.RNG
        targetArea := unexploredAreas[rng.Intn(len(unexploredAreas))]

        // Set discovery requirements (area percentage, landmarks)
        requiredPercentage := 70 + rng.Intn(31) // 70-100%

        // Add optional sub-objectives
        var subObjectives []string
        if rng.Float32() &lt; 0.3 </span><span class="cov0" title="0">{ // 30% chance for hidden areas
                subObjectives = append(subObjectives, "Find hidden areas")
        }</span>
        <span class="cov8" title="1">if rng.Float32() &lt; 0.2 </span><span class="cov0" title="0">{ // 20% chance for secrets
                subObjectives = append(subObjectives, "Discover secrets")
        }</span>

        <span class="cov8" title="1">description := fmt.Sprintf("Explore %d%% of %s", requiredPercentage, targetArea)
        if len(subObjectives) &gt; 0 </span><span class="cov0" title="0">{
                description += fmt.Sprintf(" and %s", subObjectives[0])
        }</span>

        <span class="cov8" title="1">objective := &amp;pcg.QuestObjective{
                ID:          fmt.Sprintf("obj_%d", rng.Int63()),
                Type:        "explore",
                Description: description,
                Target:      targetArea,
                Quantity:    requiredPercentage,
                Progress:    0,
                Complete:    false,
                Optional:    false,
                Conditions:  map[string]interface{}{"area": targetArea, "percentage": requiredPercentage},
        }

        return objective, nil</span>
}

// Helper functions

func (og *ObjectiveGenerator) selectEnemyTypesForDifficulty(difficulty int) []string <span class="cov8" title="1">{
        // Define enemy types by difficulty level
        enemyMap := map[int][]string{
                1:  {"Rat", "Goblin", "Skeleton"},
                2:  {"Orc", "Wolf", "Zombie"},
                3:  {"Hobgoblin", "Bear", "Ghoul"},
                4:  {"Ogre", "Wight", "Owlbear"},
                5:  {"Troll", "Wraith", "Manticore"},
                6:  {"Hill Giant", "Spectre", "Chimera"},
                7:  {"Stone Giant", "Vampire", "Roc"},
                8:  {"Fire Giant", "Lich", "Dragon"},
                9:  {"Storm Giant", "Demon", "Ancient Dragon"},
                10: {"Titan", "Archdevil", "Legendary Dragon"},
        }

        var enemies []string
        // Include enemies from current difficulty and slightly lower
        for level := max(1, difficulty-1); level &lt;= difficulty; level++ </span><span class="cov8" title="1">{
                if levelEnemies, exists := enemyMap[level]; exists </span><span class="cov8" title="1">{
                        enemies = append(enemies, levelEnemies...)
                }</span>
        }

        <span class="cov8" title="1">return enemies</span>
}

func (og *ObjectiveGenerator) selectItemTypesForLevel(playerLevel int) []string <span class="cov8" title="1">{
        // Define item types by level ranges
        if playerLevel &lt;= 3 </span><span class="cov8" title="1">{
                return []string{"Iron Sword", "Leather Armor", "Health Potion", "Rope", "Torch"}
        }</span> else<span class="cov8" title="1"> if playerLevel &lt;= 6 </span><span class="cov8" title="1">{
                return []string{"Steel Sword", "Chain Mail", "Greater Health Potion", "Magic Scroll", "Silver Amulet"}
        }</span> else<span class="cov8" title="1"> if playerLevel &lt;= 10 </span><span class="cov8" title="1">{
                return []string{"Enchanted Sword", "Plate Armor", "Elixir", "Spell Component", "Gem"}
        }</span> else<span class="cov8" title="1"> if playerLevel &lt;= 15 </span><span class="cov8" title="1">{
                return []string{"Magic Weapon", "Enchanted Armor", "Rare Potion", "Ancient Scroll", "Crystal"}
        }</span> else<span class="cov8" title="1"> {
                return []string{"Legendary Weapon", "Artifact Armor", "Divine Elixir", "Lost Tome", "Divine Relic"}
        }</span>
}

func (og *ObjectiveGenerator) getAvailableLocations() []string <span class="cov8" title="1">{
        // Return default locations - in a real implementation, this would query the world state
        return []string{
                "Dark Cave",
                "Abandoned Mine",
                "Ancient Ruins",
                "Haunted Forest",
                "Forgotten Temple",
                "Underground Cavern",
                "Crumbling Tower",
                "Mystic Grove",
                "Desolate Wasteland",
                "Hidden Valley",
        }
}</span>

func (og *ObjectiveGenerator) getUnexploredAreas(worldState *game.World) []string <span class="cov8" title="1">{
        // In a real implementation, this would analyze the world state to find unexplored areas
        // For now, return some default unexplored areas
        return []string{
                "Northern Wilderness",
                "Eastern Marshlands",
                "Southern Desert",
                "Western Mountains",
                "Deep Forest",
                "Underground Tunnels",
                "Floating Islands",
                "Shadow Realm",
        }
}</span>

func isCommonItem(itemType string) bool <span class="cov8" title="1">{
        commonItems := map[string]bool{
                "Health Potion": true,
                "Rope":          true,
                "Torch":         true,
                "Rations":       true,
                "Arrow":         true,
        }
        return commonItems[itemType]
}</span>

func max(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package pcg

import (
        "context"
        "fmt"
        "sync"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// Registry manages all registered PCG generators and provides factory methods
// Thread-safe registry following the established locking patterns
type Registry struct {
        mu         sync.RWMutex
        generators map[ContentType]map[string]Generator
        logger     *logrus.Logger
}

// NewRegistry creates a new generator registry
func NewRegistry(logger *logrus.Logger) *Registry <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = logrus.New()
        }</span>

        <span class="cov0" title="0">return &amp;Registry{
                generators: make(map[ContentType]map[string]Generator),
                logger:     logger,
        }</span>
}

// RegisterGenerator registers a new generator with the registry
// Generator names must be unique within their content type
func (r *Registry) RegisterGenerator(name string, generator Generator) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        contentType := generator.GetType()

        // Initialize content type map if needed
        if r.generators[contentType] == nil </span><span class="cov0" title="0">{
                r.generators[contentType] = make(map[string]Generator)
        }</span>

        // Check for duplicate names
        <span class="cov0" title="0">if _, exists := r.generators[contentType][name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("generator '%s' already registered for content type '%s'", name, contentType)
        }</span>

        <span class="cov0" title="0">r.generators[contentType][name] = generator

        r.logger.WithFields(logrus.Fields{
                "generator":    name,
                "content_type": contentType,
                "version":      generator.GetVersion(),
        }).Info("Registered PCG generator")

        return nil</span>
}

// UnregisterGenerator removes a generator from the registry
func (r *Registry) UnregisterGenerator(contentType ContentType, name string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.generators[contentType] == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no generators registered for content type '%s'", contentType)
        }</span>

        <span class="cov0" title="0">if _, exists := r.generators[contentType][name]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("generator '%s' not found for content type '%s'", name, contentType)
        }</span>

        <span class="cov0" title="0">delete(r.generators[contentType], name)

        r.logger.WithFields(logrus.Fields{
                "generator":    name,
                "content_type": contentType,
        }).Info("Unregistered PCG generator")

        return nil</span>
}

// GetGenerator retrieves a specific generator by content type and name
func (r *Registry) GetGenerator(contentType ContentType, name string) (Generator, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        if r.generators[contentType] == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no generators registered for content type '%s'", contentType)
        }</span>

        <span class="cov0" title="0">generator, exists := r.generators[contentType][name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generator '%s' not found for content type '%s'", name, contentType)
        }</span>

        <span class="cov0" title="0">return generator, nil</span>
}

// ListGenerators returns all registered generators for a content type
func (r *Registry) ListGenerators(contentType ContentType) []string <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        if r.generators[contentType] == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov0" title="0">names := make([]string, 0, len(r.generators[contentType]))
        for name := range r.generators[contentType] </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>

        <span class="cov0" title="0">return names</span>
}

// ListAllGenerators returns all registered generators grouped by content type
func (r *Registry) ListAllGenerators() map[ContentType][]string <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        result := make(map[ContentType][]string)
        for contentType, generators := range r.generators </span><span class="cov0" title="0">{
                names := make([]string, 0, len(generators))
                for name := range generators </span><span class="cov0" title="0">{
                        names = append(names, name)
                }</span>
                <span class="cov0" title="0">result[contentType] = names</span>
        }

        <span class="cov0" title="0">return result</span>
}

// GenerateContent creates content using the specified generator
func (r *Registry) GenerateContent(ctx context.Context, contentType ContentType, generatorName string, params GenerationParams) (interface{}, error) <span class="cov0" title="0">{
        generator, err := r.GetGenerator(contentType, generatorName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate parameters before generation
        <span class="cov0" title="0">if err := generator.Validate(params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parameter validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.WithFields(logrus.Fields{
                "generator":    generatorName,
                "content_type": contentType,
                "seed":         params.Seed,
                "difficulty":   params.Difficulty,
        }).Info("Starting content generation")

        // Generate content with timeout handling
        resultChan := make(chan interface{}, 1)
        errorChan := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                result, err := generator.Generate(ctx, params)
                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>
                <span class="cov0" title="0">resultChan &lt;- result</span>
        }()

        <span class="cov0" title="0">select </span>{
        case result := &lt;-resultChan:<span class="cov0" title="0">
                r.logger.WithFields(logrus.Fields{
                        "generator":    generatorName,
                        "content_type": contentType,
                }).Info("Content generation completed successfully")
                return result, nil</span>

        case err := &lt;-errorChan:<span class="cov0" title="0">
                r.logger.WithFields(logrus.Fields{
                        "generator":    generatorName,
                        "content_type": contentType,
                        "error":        err.Error(),
                }).Error("Content generation failed")
                return nil, err</span>

        case &lt;-ctx.Done():<span class="cov0" title="0">
                r.logger.WithFields(logrus.Fields{
                        "generator":    generatorName,
                        "content_type": contentType,
                }).Warn("Content generation cancelled or timed out")
                return nil, ctx.Err()</span>
        }
}

// Factory provides convenient factory methods for content generation
type Factory struct {
        registry *Registry
        logger   *logrus.Logger
}

// NewFactory creates a new factory instance
func NewFactory(registry *Registry, logger *logrus.Logger) *Factory <span class="cov0" title="0">{
        return &amp;Factory{
                registry: registry,
                logger:   logger,
        }
}</span>

// GenerateTerrain generates terrain using the specified generator
func (f *Factory) GenerateTerrain(ctx context.Context, generatorName string, params TerrainParams) (*game.GameMap, error) <span class="cov0" title="0">{
        result, err := f.registry.GenerateContent(ctx, ContentTypeTerrain, generatorName, params.GenerationParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">gameMap, ok := result.(*game.GameMap)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("terrain generator returned unexpected type: %T", result)
        }</span>

        <span class="cov0" title="0">return gameMap, nil</span>
}

// GenerateItems generates items using the specified generator
func (f *Factory) GenerateItems(ctx context.Context, generatorName string, params ItemParams) ([]*game.Item, error) <span class="cov0" title="0">{
        result, err := f.registry.GenerateContent(ctx, ContentTypeItems, generatorName, params.GenerationParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Handle both single items and item arrays
        <span class="cov0" title="0">switch v := result.(type) </span>{
        case *game.Item:<span class="cov0" title="0">
                return []*game.Item{v}, nil</span>
        case []*game.Item:<span class="cov0" title="0">
                return v, nil</span>
        case []game.Item:<span class="cov0" title="0">
                items := make([]*game.Item, len(v))
                for i := range v </span><span class="cov0" title="0">{
                        items[i] = &amp;v[i]
                }</span>
                <span class="cov0" title="0">return items, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("item generator returned unexpected type: %T", result)</span>
        }
}

// GenerateLevel generates a level using the specified generator
func (f *Factory) GenerateLevel(ctx context.Context, generatorName string, params LevelParams) (*game.Level, error) <span class="cov0" title="0">{
        result, err := f.registry.GenerateContent(ctx, ContentTypeLevels, generatorName, params.GenerationParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">level, ok := result.(*game.Level)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("level generator returned unexpected type: %T", result)
        }</span>

        <span class="cov0" title="0">return level, nil</span>
}

// GenerateQuest generates a quest using the specified generator
func (f *Factory) GenerateQuest(ctx context.Context, generatorName string, params QuestParams) (*game.Quest, error) <span class="cov0" title="0">{
        result, err := f.registry.GenerateContent(ctx, ContentTypeQuests, generatorName, params.GenerationParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">quest, ok := result.(*game.Quest)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("quest generator returned unexpected type: %T", result)
        }</span>

        <span class="cov0" title="0">return quest, nil</span>
}

// GetDefaultRegistry returns a registry with default generators registered
func GetDefaultRegistry(logger *logrus.Logger) *Registry <span class="cov0" title="0">{
        registry := NewRegistry(logger)

        // Register default generators (these would be implemented in their respective packages)
        // This demonstrates the registration pattern

        return registry
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package pcg

import (
        "crypto/sha256"
        "encoding/binary"
        "fmt"
        "math/rand"
        "time"
)

// SeedManager provides deterministic seeding for reproducible content generation
// Follows the established deterministic patterns in the existing dice system
type SeedManager struct {
        baseSeed     int64
        contextSeeds map[string]int64
}

// NewSeedManager creates a new seed manager with a base seed
func NewSeedManager(baseSeed int64) *SeedManager <span class="cov0" title="0">{
        if baseSeed == 0 </span><span class="cov0" title="0">{
                baseSeed = time.Now().UnixNano()
        }</span>

        <span class="cov0" title="0">return &amp;SeedManager{
                baseSeed:     baseSeed,
                contextSeeds: make(map[string]int64),
        }</span>
}

// GetBaseSeed returns the base seed used for all generation
func (sm *SeedManager) GetBaseSeed() int64 <span class="cov0" title="0">{
        return sm.baseSeed
}</span>

// DeriveContextSeed creates a deterministic seed for a specific context
// This ensures that the same content type/name combination always produces
// the same seed, enabling reproducible generation across sessions
func (sm *SeedManager) DeriveContextSeed(contentType ContentType, name string) int64 <span class="cov0" title="0">{
        context := fmt.Sprintf("%s:%s", contentType, name)

        if seed, exists := sm.contextSeeds[context]; exists </span><span class="cov0" title="0">{
                return seed
        }</span>

        // Create deterministic seed by hashing base seed + context
        <span class="cov0" title="0">hasher := sha256.New()
        hasher.Write([]byte(fmt.Sprintf("%d:%s", sm.baseSeed, context)))
        hash := hasher.Sum(nil)

        // Convert first 8 bytes of hash to int64
        seed := int64(binary.BigEndian.Uint64(hash[:8]))

        sm.contextSeeds[context] = seed
        return seed</span>
}

// DeriveParameterSeed creates a seed based on generation parameters
// This allows for controlled variation within the same generator context
func (sm *SeedManager) DeriveParameterSeed(baseSeed int64, params GenerationParams) int64 <span class="cov0" title="0">{
        hasher := sha256.New()

        // Include critical parameters that should affect generation
        paramString := fmt.Sprintf("%d:%d:%d",
                baseSeed,
                params.Difficulty,
                params.PlayerLevel)

        // Include any additional constraints that should affect seeding
        for key, value := range params.Constraints </span><span class="cov0" title="0">{
                paramString += fmt.Sprintf(":%s=%v", key, value)
        }</span>

        <span class="cov0" title="0">hasher.Write([]byte(paramString))
        hash := hasher.Sum(nil)

        return int64(binary.BigEndian.Uint64(hash[:8]))</span>
}

// CreateRNG creates a new random number generator with the derived seed
// This provides the same pattern as the existing DiceRoller system
func (sm *SeedManager) CreateRNG(contentType ContentType, name string, params GenerationParams) *rand.Rand <span class="cov0" title="0">{
        contextSeed := sm.DeriveContextSeed(contentType, name)
        finalSeed := sm.DeriveParameterSeed(contextSeed, params)

        return rand.New(rand.NewSource(finalSeed))
}</span>

// CreateSubRNG creates a child RNG for a specific generation phase
// This allows deterministic sub-generation within a larger generation process
func (sm *SeedManager) CreateSubRNG(parentRNG *rand.Rand, phase string) *rand.Rand <span class="cov0" title="0">{
        // Use the parent RNG to get a deterministic seed for the sub-phase
        subSeed := parentRNG.Int63()

        // Hash the phase name with the sub-seed for determinism
        hasher := sha256.New()
        hasher.Write([]byte(fmt.Sprintf("%d:%s", subSeed, phase)))
        hash := hasher.Sum(nil)

        finalSeed := int64(binary.BigEndian.Uint64(hash[:8]))
        return rand.New(rand.NewSource(finalSeed))
}</span>

// SaveableState represents the state that can be saved/loaded for reproducibility
type SaveableState struct {
        BaseSeed     int64            `yaml:"base_seed"`
        ContextSeeds map[string]int64 `yaml:"context_seeds"`
}

// GetSaveableState returns the current state for persistence
func (sm *SeedManager) GetSaveableState() SaveableState <span class="cov0" title="0">{
        return SaveableState{
                BaseSeed:     sm.baseSeed,
                ContextSeeds: sm.contextSeeds,
        }
}</span>

// LoadState restores the seed manager from saved state
func (sm *SeedManager) LoadState(state SaveableState) <span class="cov0" title="0">{
        sm.baseSeed = state.BaseSeed
        sm.contextSeeds = make(map[string]int64)

        for context, seed := range state.ContextSeeds </span><span class="cov0" title="0">{
                sm.contextSeeds[context] = seed
        }</span>
}

// GenerationContext provides context and seeded RNG for generators
type GenerationContext struct {
        RNG     *rand.Rand
        Seed    int64
        Phase   string
        SeedMgr *SeedManager
        SubRNGs map[string]*rand.Rand
}

// NewGenerationContext creates a new generation context
func NewGenerationContext(seedMgr *SeedManager, contentType ContentType, name string, params GenerationParams) *GenerationContext <span class="cov0" title="0">{
        rng := seedMgr.CreateRNG(contentType, name, params)

        return &amp;GenerationContext{
                RNG:     rng,
                Seed:    seedMgr.DeriveContextSeed(contentType, name),
                Phase:   "main",
                SeedMgr: seedMgr,
                SubRNGs: make(map[string]*rand.Rand),
        }
}</span>

// GetSubRNG returns a deterministic sub-RNG for the specified phase
func (gc *GenerationContext) GetSubRNG(phase string) *rand.Rand <span class="cov0" title="0">{
        if subRNG, exists := gc.SubRNGs[phase]; exists </span><span class="cov0" title="0">{
                return subRNG
        }</span>

        <span class="cov0" title="0">subRNG := gc.SeedMgr.CreateSubRNG(gc.RNG, phase)
        gc.SubRNGs[phase] = subRNG
        return subRNG</span>
}

// RollDice provides dice rolling functionality using the context's RNG
// This integrates with the existing dice system patterns
func (gc *GenerationContext) RollDice(sides int) int <span class="cov0" title="0">{
        if sides &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return gc.RNG.Intn(sides) + 1</span>
}

// RollMultipleDice rolls multiple dice and returns individual results
func (gc *GenerationContext) RollMultipleDice(count, sides int) []int <span class="cov0" title="0">{
        results := make([]int, count)
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = gc.RollDice(sides)
        }</span>
        <span class="cov0" title="0">return results</span>
}

// RollDiceSum rolls multiple dice and returns the sum
func (gc *GenerationContext) RollDiceSum(count, sides int) int <span class="cov0" title="0">{
        total := 0
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                total += gc.RollDice(sides)
        }</span>
        <span class="cov0" title="0">return total</span>
}

// RandomChoice selects a random element from a slice
func (gc *GenerationContext) RandomChoice(choices []string) string <span class="cov0" title="0">{
        if len(choices) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return choices[gc.RNG.Intn(len(choices))]</span>
}

// RandomFloat returns a random float64 between 0.0 and 1.0
func (gc *GenerationContext) RandomFloat() float64 <span class="cov0" title="0">{
        return gc.RNG.Float64()
}</span>

// RandomFloatRange returns a random float64 between min and max
func (gc *GenerationContext) RandomFloatRange(min, max float64) float64 <span class="cov0" title="0">{
        return min + gc.RNG.Float64()*(max-min)
}</span>

// RandomIntRange returns a random int between min and max (inclusive)
func (gc *GenerationContext) RandomIntRange(min, max int) int <span class="cov0" title="0">{
        if min &gt;= max </span><span class="cov0" title="0">{
                return min
        }</span>
        <span class="cov0" title="0">return min + gc.RNG.Intn(max-min+1)</span>
}

// WeightedChoice selects from choices based on weights
func (gc *GenerationContext) WeightedChoice(choices []string, weights []float64) string <span class="cov0" title="0">{
        if len(choices) == 0 || len(choices) != len(weights) </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Calculate total weight
        <span class="cov0" title="0">totalWeight := 0.0
        for _, weight := range weights </span><span class="cov0" title="0">{
                totalWeight += weight
        }</span>

        <span class="cov0" title="0">if totalWeight &lt;= 0 </span><span class="cov0" title="0">{
                return gc.RandomChoice(choices)
        }</span>

        // Random value between 0 and total weight
        <span class="cov0" title="0">randomValue := gc.RNG.Float64() * totalWeight

        // Find the selected choice
        currentWeight := 0.0
        for i, weight := range weights </span><span class="cov0" title="0">{
                currentWeight += weight
                if randomValue &lt;= currentWeight </span><span class="cov0" title="0">{
                        return choices[i]
                }</span>
        }

        // Fallback to last choice
        <span class="cov0" title="0">return choices[len(choices)-1]</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package terrain

import (
        "fmt"

        "goldbox-rpg/pkg/pcg"
)

// BiomeDefinition defines the characteristics of a biome
type BiomeDefinition struct {
        Type              pcg.BiomeType         `yaml:"type"`
        DefaultDensity    float64               `yaml:"default_density"`
        WaterLevelRange   [2]float64            `yaml:"water_level_range"`
        RoughnessRange    [2]float64            `yaml:"roughness_range"`
        ConnectivityLevel pcg.ConnectivityLevel `yaml:"connectivity_level"`
        Features          []pcg.TerrainFeature  `yaml:"features"`
        TileDistribution  map[string]float64    `yaml:"tile_distribution"`
}

// biomeDefinitions holds the default biome configurations
var biomeDefinitions = map[pcg.BiomeType]*BiomeDefinition{
        pcg.BiomeCave: {
                Type:              pcg.BiomeCave,
                DefaultDensity:    0.45,
                WaterLevelRange:   [2]float64{0.0, 0.1},
                RoughnessRange:    [2]float64{0.6, 0.8},
                ConnectivityLevel: pcg.ConnectivityModerate,
                Features:          []pcg.TerrainFeature{pcg.FeatureStalactites, pcg.FeatureUndergroundRiver},
                TileDistribution: map[string]float64{
                        "wall":  0.45,
                        "floor": 0.50,
                        "water": 0.03,
                        "deep":  0.02,
                },
        },
        pcg.BiomeDungeon: {
                Type:              pcg.BiomeDungeon,
                DefaultDensity:    0.40,
                WaterLevelRange:   [2]float64{0.0, 0.05},
                RoughnessRange:    [2]float64{0.3, 0.5},
                ConnectivityLevel: pcg.ConnectivityHigh,
                Features:          []pcg.TerrainFeature{pcg.FeatureSecretDoors, pcg.FeatureTraps},
                TileDistribution: map[string]float64{
                        "wall":   0.40,
                        "floor":  0.55,
                        "door":   0.03,
                        "secret": 0.02,
                },
        },
        pcg.BiomeForest: {
                Type:              pcg.BiomeForest,
                DefaultDensity:    0.35,
                WaterLevelRange:   [2]float64{0.05, 0.15},
                RoughnessRange:    [2]float64{0.4, 0.7},
                ConnectivityLevel: pcg.ConnectivityModerate,
                Features:          []pcg.TerrainFeature{pcg.FeatureTrees, pcg.FeatureStreams},
                TileDistribution: map[string]float64{
                        "trees": 0.35,
                        "grass": 0.50,
                        "water": 0.10,
                        "rocks": 0.05,
                },
        },
        pcg.BiomeMountain: {
                Type:              pcg.BiomeMountain,
                DefaultDensity:    0.60,
                WaterLevelRange:   [2]float64{0.0, 0.05},
                RoughnessRange:    [2]float64{0.7, 0.9},
                ConnectivityLevel: pcg.ConnectivityLow,
                Features:          []pcg.TerrainFeature{pcg.FeatureCliffs, pcg.FeatureCrevasses},
                TileDistribution: map[string]float64{
                        "rock": 0.60,
                        "path": 0.25,
                        "snow": 0.10,
                        "ice":  0.05,
                },
        },
        pcg.BiomeSwamp: {
                Type:              pcg.BiomeSwamp,
                DefaultDensity:    0.30,
                WaterLevelRange:   [2]float64{0.25, 0.40},
                RoughnessRange:    [2]float64{0.2, 0.4},
                ConnectivityLevel: pcg.ConnectivityLow,
                Features:          []pcg.TerrainFeature{pcg.FeatureBogs, pcg.FeatureVines},
                TileDistribution: map[string]float64{
                        "mud":   0.30,
                        "water": 0.35,
                        "reeds": 0.25,
                        "solid": 0.10,
                },
        },
        pcg.BiomeDesert: {
                Type:              pcg.BiomeDesert,
                DefaultDensity:    0.15,
                WaterLevelRange:   [2]float64{0.0, 0.02},
                RoughnessRange:    [2]float64{0.1, 0.3},
                ConnectivityLevel: pcg.ConnectivityHigh,
                Features:          []pcg.TerrainFeature{pcg.FeatureDunes, pcg.FeatureOasis},
                TileDistribution: map[string]float64{
                        "sand":   0.85,
                        "rock":   0.10,
                        "water":  0.02,
                        "cactus": 0.03,
                },
        },
}

// GetBiomeDefinition returns the definition for a specific biome
func GetBiomeDefinition(biome pcg.BiomeType) (*BiomeDefinition, error) <span class="cov8" title="1">{
        def, exists := biomeDefinitions[biome]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unknown biome type: %s", biome)
        }</span>

        // Return a copy to prevent modification
        <span class="cov8" title="1">result := *def
        return &amp;result, nil</span>
}

// ApplyBiomeModifications modifies generation parameters based on biome
func ApplyBiomeModifications(params *pcg.TerrainParams, biome pcg.BiomeType) error <span class="cov8" title="1">{
        def, err := GetBiomeDefinition(biome)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Apply biome-specific modifications
        <span class="cov8" title="1">if params.Density == 0 </span><span class="cov8" title="1">{
                params.Density = def.DefaultDensity
        }</span>

        <span class="cov8" title="1">params.BiomeType = biome
        params.Connectivity = def.ConnectivityLevel

        // Adjust water level if not specified
        if params.WaterLevel == 0 </span><span class="cov8" title="1">{
                params.WaterLevel = (def.WaterLevelRange[0] + def.WaterLevelRange[1]) / 2
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetBiomeFeatures returns the available features for a biome
func GetBiomeFeatures(biome pcg.BiomeType) ([]pcg.TerrainFeature, error) <span class="cov8" title="1">{
        def, err := GetBiomeDefinition(biome)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return def.Features, nil</span>
}

// GetBiomeTileDistribution returns the tile distribution for a biome
func GetBiomeTileDistribution(biome pcg.BiomeType) (map[string]float64, error) <span class="cov8" title="1">{
        def, err := GetBiomeDefinition(biome)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return a copy to prevent modification
        <span class="cov8" title="1">result := make(map[string]float64)
        for k, v := range def.TileDistribution </span><span class="cov8" title="1">{
                result[k] = v
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package terrain

import (
        "fmt"
        "math/rand"

        "goldbox-rpg/pkg/game"
        "goldbox-rpg/pkg/pcg"
)

// CellularAutomataConfig holds configuration for the algorithm
type CellularAutomataConfig struct {
        WallThreshold   int `yaml:"wall_threshold"`   // Neighbor count for wall formation
        FloorThreshold  int `yaml:"floor_threshold"`  // Neighbor count for floor formation
        MaxIterations   int `yaml:"max_iterations"`   // Maximum CA iterations
        SmoothingPasses int `yaml:"smoothing_passes"` // Post-processing smoothing
        EdgeBuffer      int `yaml:"edge_buffer"`      // Border wall thickness
        MinRoomSize     int `yaml:"min_room_size"`    // Minimum viable room size
}

// DefaultCAConfig returns default cellular automata configuration
func DefaultCAConfig() *CellularAutomataConfig <span class="cov8" title="1">{
        return &amp;CellularAutomataConfig{
                WallThreshold:   5,
                FloorThreshold:  3,
                MaxIterations:   6,
                SmoothingPasses: 2,
                EdgeBuffer:      1,
                MinRoomSize:     16,
        }
}</span>

// RunCellularAutomata executes the cellular automata algorithm
func RunCellularAutomata(gameMap *game.GameMap, config *CellularAutomataConfig, genCtx *pcg.GenerationContext) error <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = DefaultCAConfig()
        }</span>

        // Step 1: Initialize random noise based on density
        <span class="cov8" title="1">if err := initializeRandomNoise(gameMap, genCtx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize noise: %w", err)
        }</span>

        // Step 2: Apply cellular automata rules for specified iterations
        <span class="cov8" title="1">for i := 0; i &lt; config.MaxIterations; i++ </span><span class="cov8" title="1">{
                if err := applyCellularAutomataStep(gameMap, config, genCtx.RNG); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed CA iteration %d: %w", i, err)
                }</span>
        }

        // Step 3: Remove small disconnected areas
        <span class="cov8" title="1">if err := removeSmallAreas(gameMap, config.MinRoomSize); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove small areas: %w", err)
        }</span>

        // Step 4: Apply smoothing passes
        <span class="cov8" title="1">for i := 0; i &lt; config.SmoothingPasses; i++ </span><span class="cov8" title="1">{
                if err := applySmoothingPass(gameMap); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed smoothing pass %d: %w", i, err)
                }</span>
        }

        // Step 5: Ensure proper edge boundaries
        <span class="cov8" title="1">if err := enforceEdgeBoundaries(gameMap, config.EdgeBuffer); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to enforce edge boundaries: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// initializeRandomNoise fills the map with random noise based on density
func initializeRandomNoise(gameMap *game.GameMap, genCtx *pcg.GenerationContext) error <span class="cov8" title="1">{
        // For terrain generation, we need a density parameter
        // This should come from the terrain parameters
        density := 0.45 // Default density for cave generation

        for y := 0; y &lt; gameMap.Height; y++ </span><span class="cov8" title="1">{
                for x := 0; x &lt; gameMap.Width; x++ </span><span class="cov8" title="1">{
                        if genCtx.RandomFloat() &lt; density </span><span class="cov8" title="1">{
                                gameMap.Tiles[y][x].Walkable = false
                                gameMap.Tiles[y][x].Transparent = false
                                gameMap.Tiles[y][x].SpriteX = 1 // Wall sprite
                                gameMap.Tiles[y][x].SpriteY = 0
                        }</span> else<span class="cov8" title="1"> {
                                gameMap.Tiles[y][x].Walkable = true
                                gameMap.Tiles[y][x].Transparent = true
                                gameMap.Tiles[y][x].SpriteX = 0 // Floor sprite
                                gameMap.Tiles[y][x].SpriteY = 0
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// applyCellularAutomataStep applies one iteration of the cellular automata rules
func applyCellularAutomataStep(gameMap *game.GameMap, config *CellularAutomataConfig, rng *rand.Rand) error <span class="cov8" title="1">{
        newTiles := make([][]game.MapTile, gameMap.Height)
        for i := range newTiles </span><span class="cov8" title="1">{
                newTiles[i] = make([]game.MapTile, gameMap.Width)
                copy(newTiles[i], gameMap.Tiles[i])
        }</span>

        <span class="cov8" title="1">for y := 0; y &lt; gameMap.Height; y++ </span><span class="cov8" title="1">{
                for x := 0; x &lt; gameMap.Width; x++ </span><span class="cov8" title="1">{
                        wallCount := countNeighborWalls(gameMap, x, y)

                        if wallCount &gt;= config.WallThreshold </span><span class="cov8" title="1">{
                                newTiles[y][x].Walkable = false
                                newTiles[y][x].Transparent = false
                                newTiles[y][x].SpriteX = 1 // Wall sprite
                                newTiles[y][x].SpriteY = 0
                        }</span> else<span class="cov8" title="1"> if wallCount &lt;= config.FloorThreshold </span><span class="cov8" title="1">{
                                newTiles[y][x].Walkable = true
                                newTiles[y][x].Transparent = true
                                newTiles[y][x].SpriteX = 0 // Floor sprite
                                newTiles[y][x].SpriteY = 0
                        }</span>
                        // Tiles with neighbor counts between thresholds remain unchanged
                }
        }

        <span class="cov8" title="1">gameMap.Tiles = newTiles
        return nil</span>
}

// countNeighborWalls counts wall tiles in the 8-neighborhood around a position
func countNeighborWalls(gameMap *game.GameMap, x, y int) int <span class="cov8" title="1">{
        wallCount := 0

        for dy := -1; dy &lt;= 1; dy++ </span><span class="cov8" title="1">{
                for dx := -1; dx &lt;= 1; dx++ </span><span class="cov8" title="1">{
                        if dx == 0 &amp;&amp; dy == 0 </span><span class="cov8" title="1">{
                                continue</span> // Skip the center tile
                        }

                        <span class="cov8" title="1">nx, ny := x+dx, y+dy

                        // Treat out-of-bounds as walls
                        if nx &lt; 0 || nx &gt;= gameMap.Width || ny &lt; 0 || ny &gt;= gameMap.Height </span><span class="cov8" title="1">{
                                wallCount++
                        }</span> else<span class="cov8" title="1"> if !gameMap.Tiles[ny][nx].Walkable </span><span class="cov8" title="1">{
                                wallCount++
                        }</span>
                }
        }

        <span class="cov8" title="1">return wallCount</span>
}

// removeSmallAreas removes disconnected floor areas smaller than minSize
func removeSmallAreas(gameMap *game.GameMap, minSize int) error <span class="cov8" title="1">{
        visited := make([][]bool, gameMap.Height)
        for i := range visited </span><span class="cov8" title="1">{
                visited[i] = make([]bool, gameMap.Width)
        }</span>

        <span class="cov8" title="1">for y := 0; y &lt; gameMap.Height; y++ </span><span class="cov8" title="1">{
                for x := 0; x &lt; gameMap.Width; x++ </span><span class="cov8" title="1">{
                        if !visited[y][x] &amp;&amp; gameMap.Tiles[y][x].Walkable </span><span class="cov8" title="1">{
                                area := floodFillArea(gameMap, x, y, visited)
                                if len(area) &lt; minSize </span><span class="cov8" title="1">{
                                        // Convert small area to walls
                                        for _, pos := range area </span><span class="cov8" title="1">{
                                                gameMap.Tiles[pos.Y][pos.X].Walkable = false
                                                gameMap.Tiles[pos.Y][pos.X].Transparent = false
                                                gameMap.Tiles[pos.Y][pos.X].SpriteX = 1 // Wall sprite
                                                gameMap.Tiles[pos.Y][pos.X].SpriteY = 0
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// floodFillArea performs flood fill to find connected floor areas
func floodFillArea(gameMap *game.GameMap, startX, startY int, visited [][]bool) []game.Position <span class="cov8" title="1">{
        var area []game.Position
        var stack []game.Position

        stack = append(stack, game.Position{X: startX, Y: startY})

        for len(stack) &gt; 0 </span><span class="cov8" title="1">{
                pos := stack[len(stack)-1]
                stack = stack[:len(stack)-1]

                if pos.X &lt; 0 || pos.X &gt;= gameMap.Width || pos.Y &lt; 0 || pos.Y &gt;= gameMap.Height </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if visited[pos.Y][pos.X] || !gameMap.Tiles[pos.Y][pos.X].Walkable </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">visited[pos.Y][pos.X] = true
                area = append(area, pos)

                // Add 4-connected neighbors
                stack = append(stack, game.Position{X: pos.X + 1, Y: pos.Y})
                stack = append(stack, game.Position{X: pos.X - 1, Y: pos.Y})
                stack = append(stack, game.Position{X: pos.X, Y: pos.Y + 1})
                stack = append(stack, game.Position{X: pos.X, Y: pos.Y - 1})</span>
        }

        <span class="cov8" title="1">return area</span>
}

// applySmoothingPass applies one smoothing iteration to reduce noise
func applySmoothingPass(gameMap *game.GameMap) error <span class="cov8" title="1">{
        newTiles := make([][]game.MapTile, gameMap.Height)
        for i := range newTiles </span><span class="cov8" title="1">{
                newTiles[i] = make([]game.MapTile, gameMap.Width)
                copy(newTiles[i], gameMap.Tiles[i])
        }</span>

        <span class="cov8" title="1">for y := 1; y &lt; gameMap.Height-1; y++ </span><span class="cov8" title="1">{
                for x := 1; x &lt; gameMap.Width-1; x++ </span><span class="cov8" title="1">{
                        wallCount := countNeighborWalls(gameMap, x, y)

                        // Smooth isolated walls and floors
                        if !gameMap.Tiles[y][x].Walkable &amp;&amp; wallCount &lt; 3 </span><span class="cov8" title="1">{
                                newTiles[y][x].Walkable = true
                                newTiles[y][x].Transparent = true
                                newTiles[y][x].SpriteX = 0 // Floor sprite
                                newTiles[y][x].SpriteY = 0
                        }</span> else<span class="cov8" title="1"> if gameMap.Tiles[y][x].Walkable &amp;&amp; wallCount &gt; 5 </span><span class="cov8" title="1">{
                                newTiles[y][x].Walkable = false
                                newTiles[y][x].Transparent = false
                                newTiles[y][x].SpriteX = 1 // Wall sprite
                                newTiles[y][x].SpriteY = 0
                        }</span>
                }
        }

        <span class="cov8" title="1">gameMap.Tiles = newTiles
        return nil</span>
}

// enforceEdgeBoundaries ensures map edges are walls with specified buffer
func enforceEdgeBoundaries(gameMap *game.GameMap, buffer int) error <span class="cov8" title="1">{
        for y := 0; y &lt; gameMap.Height; y++ </span><span class="cov8" title="1">{
                for x := 0; x &lt; gameMap.Width; x++ </span><span class="cov8" title="1">{
                        if x &lt; buffer || x &gt;= gameMap.Width-buffer || y &lt; buffer || y &gt;= gameMap.Height-buffer </span><span class="cov8" title="1">{
                                gameMap.Tiles[y][x].Walkable = false
                                gameMap.Tiles[y][x].Transparent = false
                                gameMap.Tiles[y][x].SpriteX = 1 // Wall sprite
                                gameMap.Tiles[y][x].SpriteY = 0
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package terrain

import (
        "context"
        "fmt"
        "math"

        "goldbox-rpg/pkg/game"
        "goldbox-rpg/pkg/pcg"
)

// CellularAutomataGenerator implements terrain generation using cellular automata
// Particularly effective for generating cave systems and natural-looking dungeons
type CellularAutomataGenerator struct {
        version string
}

// NewCellularAutomataGenerator creates a new cellular automata terrain generator
func NewCellularAutomataGenerator() *CellularAutomataGenerator <span class="cov0" title="0">{
        return &amp;CellularAutomataGenerator{
                version: "1.0.0",
        }
}</span>

// Generate implements the Generator interface
func (cag *CellularAutomataGenerator) Generate(ctx context.Context, params pcg.GenerationParams) (interface{}, error) <span class="cov0" title="0">{
        // Extract terrain-specific parameters
        terrainParams, ok := params.Constraints["terrain_params"].(pcg.TerrainParams)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing or invalid terrain parameters")
        }</span>

        // Extract dimensions from constraints
        <span class="cov0" title="0">width, ok := params.Constraints["width"].(int)
        if !ok </span><span class="cov0" title="0">{
                width = 50 // Default width
        }</span>

        <span class="cov0" title="0">height, ok := params.Constraints["height"].(int)
        if !ok </span><span class="cov0" title="0">{
                height = 50 // Default height
        }</span>

        <span class="cov0" title="0">return cag.GenerateTerrain(ctx, width, height, terrainParams)</span>
}

// GenerateTerrain implements the TerrainGenerator interface
func (cag *CellularAutomataGenerator) GenerateTerrain(ctx context.Context, width, height int, params pcg.TerrainParams) (*game.GameMap, error) <span class="cov0" title="0">{
        // Create generation context with seeded RNG
        seedMgr := pcg.NewSeedManager(params.Seed)
        genCtx := pcg.NewGenerationContext(seedMgr, pcg.ContentTypeTerrain, "cellular_automata", params.GenerationParams)

        // Initialize the map
        gameMap := &amp;game.GameMap{
                Width:  width,
                Height: height,
                Tiles:  make([][]game.MapTile, height),
        }

        // Initialize tiles array
        for y := 0; y &lt; height; y++ </span><span class="cov0" title="0">{
                gameMap.Tiles[y] = make([]game.MapTile, width)
        }</span>

        // Generate initial random layout
        <span class="cov0" title="0">cag.generateInitialLayout(gameMap, genCtx, params)

        // Apply cellular automata iterations
        iterations := cag.calculateIterations(params.Difficulty)
        for i := 0; i &lt; iterations; i++ </span><span class="cov0" title="0">{
                // Check for context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">cag.applyCellularAutomataStep(gameMap, genCtx)</span>
        }

        // Post-process the map based on biome and parameters
        <span class="cov0" title="0">if err := cag.postProcessMap(gameMap, genCtx, params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("post-processing failed: %w", err)
        }</span>

        // Apply connectivity requirements
        <span class="cov0" title="0">if params.Connectivity != pcg.ConnectivityNone </span><span class="cov0" title="0">{
                if err := cag.ensureConnectivity(gameMap, genCtx, params.Connectivity); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("connectivity enforcement failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return gameMap, nil</span>
}

// GenerateBiome implements the TerrainGenerator interface
func (cag *CellularAutomataGenerator) GenerateBiome(ctx context.Context, biome pcg.BiomeType, bounds pcg.Rectangle, params pcg.TerrainParams) (*game.GameMap, error) <span class="cov0" title="0">{
        // Adjust parameters based on biome characteristics
        adjustedParams := cag.adjustParamsForBiome(params, biome)

        return cag.GenerateTerrain(ctx, bounds.Width, bounds.Height, adjustedParams)
}</span>

// ValidateConnectivity implements the TerrainGenerator interface
func (cag *CellularAutomataGenerator) ValidateConnectivity(terrain *game.GameMap) bool <span class="cov0" title="0">{
        validator := pcg.NewValidator(true)
        result := validator.ValidateGameMap(terrain)
        return result.IsValid()
}</span>

// GetType implements the Generator interface
func (cag *CellularAutomataGenerator) GetType() pcg.ContentType <span class="cov0" title="0">{
        return pcg.ContentTypeTerrain
}</span>

// GetVersion implements the Generator interface
func (cag *CellularAutomataGenerator) GetVersion() string <span class="cov0" title="0">{
        return cag.version
}</span>

// Validate implements the Generator interface
func (cag *CellularAutomataGenerator) Validate(params pcg.GenerationParams) error <span class="cov0" title="0">{
        validator := pcg.NewValidator(false)

        // Check if terrain parameters are provided
        if _, ok := params.Constraints["terrain_params"]; !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("terrain_params must be provided in constraints")
        }</span>

        <span class="cov0" title="0">terrainParams, ok := params.Constraints["terrain_params"].(pcg.TerrainParams)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("terrain_params must be of type TerrainParams")
        }</span>

        <span class="cov0" title="0">result := validator.ValidateTerrainParams(terrainParams)
        if !result.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %v", result.Errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// generateInitialLayout creates the initial random layout for cellular automata
func (cag *CellularAutomataGenerator) generateInitialLayout(gameMap *game.GameMap, genCtx *pcg.GenerationContext, params pcg.TerrainParams) <span class="cov0" title="0">{
        // Use density parameter to determine fill probability
        fillProbability := params.Density
        if fillProbability &lt;= 0 </span><span class="cov0" title="0">{
                fillProbability = 0.45 // Default density for caves
        }</span>

        <span class="cov0" title="0">for y := 0; y &lt; gameMap.Height; y++ </span><span class="cov0" title="0">{
                for x := 0; x &lt; gameMap.Width; x++ </span><span class="cov0" title="0">{
                        // Edge tiles are always walls for boundary
                        if x == 0 || y == 0 || x == gameMap.Width-1 || y == gameMap.Height-1 </span><span class="cov0" title="0">{
                                gameMap.Tiles[y][x] = cag.createWallTile()
                        }</span> else<span class="cov0" title="0"> {
                                // Random fill based on density
                                if genCtx.RandomFloat() &lt; fillProbability </span><span class="cov0" title="0">{
                                        gameMap.Tiles[y][x] = cag.createWallTile()
                                }</span> else<span class="cov0" title="0"> {
                                        gameMap.Tiles[y][x] = cag.createFloorTile()
                                }</span>
                        }
                }
        }
}

// applyCellularAutomataStep applies one iteration of the cellular automata algorithm
func (cag *CellularAutomataGenerator) applyCellularAutomataStep(gameMap *game.GameMap, genCtx *pcg.GenerationContext) <span class="cov0" title="0">{
        newTiles := make([][]game.MapTile, gameMap.Height)
        for y := 0; y &lt; gameMap.Height; y++ </span><span class="cov0" title="0">{
                newTiles[y] = make([]game.MapTile, gameMap.Width)
        }</span>

        <span class="cov0" title="0">for y := 0; y &lt; gameMap.Height; y++ </span><span class="cov0" title="0">{
                for x := 0; x &lt; gameMap.Width; x++ </span><span class="cov0" title="0">{
                        wallCount := cag.countAdjacentWalls(gameMap, x, y)

                        // Apply cellular automata rules
                        if wallCount &gt;= 5 </span><span class="cov0" title="0">{
                                newTiles[y][x] = cag.createWallTile()
                        }</span> else<span class="cov0" title="0"> if wallCount &lt;= 3 </span><span class="cov0" title="0">{
                                newTiles[y][x] = cag.createFloorTile()
                        }</span> else<span class="cov0" title="0"> {
                                // Keep current state for borderline cases
                                newTiles[y][x] = gameMap.Tiles[y][x]
                        }</span>
                }
        }

        <span class="cov0" title="0">gameMap.Tiles = newTiles</span>
}

// countAdjacentWalls counts walls in the 3x3 neighborhood around a position
func (cag *CellularAutomataGenerator) countAdjacentWalls(gameMap *game.GameMap, centerX, centerY int) int <span class="cov0" title="0">{
        count := 0

        for y := centerY - 1; y &lt;= centerY+1; y++ </span><span class="cov0" title="0">{
                for x := centerX - 1; x &lt;= centerX+1; x++ </span><span class="cov0" title="0">{
                        // Count out-of-bounds as walls
                        if x &lt; 0 || y &lt; 0 || x &gt;= gameMap.Width || y &gt;= gameMap.Height </span><span class="cov0" title="0">{
                                count++
                        }</span> else<span class="cov0" title="0"> if !gameMap.Tiles[y][x].Walkable </span><span class="cov0" title="0">{
                                count++
                        }</span>
                }
        }

        <span class="cov0" title="0">return count</span>
}

// postProcessMap applies biome-specific post-processing
func (cag *CellularAutomataGenerator) postProcessMap(gameMap *game.GameMap, genCtx *pcg.GenerationContext, params pcg.TerrainParams) error <span class="cov0" title="0">{
        switch params.BiomeType </span>{
        case pcg.BiomeCave:<span class="cov0" title="0">
                return cag.postProcessCave(gameMap, genCtx, params)</span>
        case pcg.BiomeDungeon:<span class="cov0" title="0">
                return cag.postProcessDungeon(gameMap, genCtx, params)</span>
        case pcg.BiomeSwamp:<span class="cov0" title="0">
                return cag.postProcessSwamp(gameMap, genCtx, params)</span>
        default:<span class="cov0" title="0">
                return cag.postProcessGeneric(gameMap, genCtx, params)</span>
        }
}

// postProcessCave applies cave-specific post-processing
func (cag *CellularAutomataGenerator) postProcessCave(gameMap *game.GameMap, genCtx *pcg.GenerationContext, params pcg.TerrainParams) error <span class="cov0" title="0">{
        // Add water pools based on water level parameter
        if params.WaterLevel &gt; 0 </span><span class="cov0" title="0">{
                cag.addWaterFeatures(gameMap, genCtx, params.WaterLevel)
        }</span>

        // Add stalactites/stalagmites based on roughness
        <span class="cov0" title="0">if params.Roughness &gt; 0.5 </span><span class="cov0" title="0">{
                cag.addCaveFeatures(gameMap, genCtx, params.Roughness)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// postProcessDungeon applies dungeon-specific post-processing
func (cag *CellularAutomataGenerator) postProcessDungeon(gameMap *game.GameMap, genCtx *pcg.GenerationContext, params pcg.TerrainParams) error <span class="cov0" title="0">{
        // Add door positions for dungeon rooms
        cag.addDungeonDoors(gameMap, genCtx)

        // Add torch positions for lighting
        cag.addTorchPositions(gameMap, genCtx)

        return nil
}</span>

// postProcessSwamp applies swamp-specific post-processing
func (cag *CellularAutomataGenerator) postProcessSwamp(gameMap *game.GameMap, genCtx *pcg.GenerationContext, params pcg.TerrainParams) error <span class="cov0" title="0">{
        // Add extensive water features
        cag.addWaterFeatures(gameMap, genCtx, math.Max(params.WaterLevel, 0.3))

        // Add vegetation density
        cag.addVegetation(gameMap, genCtx, 0.7)

        return nil
}</span>

// postProcessGeneric applies generic post-processing
func (cag *CellularAutomataGenerator) postProcessGeneric(gameMap *game.GameMap, genCtx *pcg.GenerationContext, params pcg.TerrainParams) error <span class="cov0" title="0">{
        // Apply water level if specified
        if params.WaterLevel &gt; 0 </span><span class="cov0" title="0">{
                cag.addWaterFeatures(gameMap, genCtx, params.WaterLevel)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ensureConnectivity ensures the map meets connectivity requirements
func (cag *CellularAutomataGenerator) ensureConnectivity(gameMap *game.GameMap, genCtx *pcg.GenerationContext, level pcg.ConnectivityLevel) error <span class="cov0" title="0">{
        switch level </span>{
        case pcg.ConnectivityMinimal:<span class="cov0" title="0">
                return cag.ensureMinimalConnectivity(gameMap, genCtx)</span>
        case pcg.ConnectivityModerate:<span class="cov0" title="0">
                return cag.ensureModerateConnectivity(gameMap, genCtx)</span>
        case pcg.ConnectivityHigh:<span class="cov0" title="0">
                return cag.ensureHighConnectivity(gameMap, genCtx)</span>
        case pcg.ConnectivityComplete:<span class="cov0" title="0">
                return cag.ensureCompleteConnectivity(gameMap, genCtx)</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// ensureMinimalConnectivity ensures basic connectivity between major areas
func (cag *CellularAutomataGenerator) ensureMinimalConnectivity(gameMap *game.GameMap, genCtx *pcg.GenerationContext) error <span class="cov0" title="0">{
        // Find all disconnected walkable regions
        regions := cag.findWalkableRegions(gameMap)

        if len(regions) &lt;= 1 </span><span class="cov0" title="0">{
                return nil // Already connected or no walkable areas
        }</span>

        // Connect the largest regions
        <span class="cov0" title="0">mainRegion := cag.findLargestRegion(regions)
        for i, region := range regions </span><span class="cov0" title="0">{
                if i != mainRegion </span><span class="cov0" title="0">{
                        cag.connectRegions(gameMap, regions[mainRegion], region)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper methods for connectivity (simplified implementations)
func (cag *CellularAutomataGenerator) ensureModerateConnectivity(gameMap *game.GameMap, genCtx *pcg.GenerationContext) error <span class="cov0" title="0">{
        // More sophisticated connectivity ensuring multiple paths
        return cag.ensureMinimalConnectivity(gameMap, genCtx)
}</span>

func (cag *CellularAutomataGenerator) ensureHighConnectivity(gameMap *game.GameMap, genCtx *pcg.GenerationContext) error <span class="cov0" title="0">{
        // High connectivity with redundant paths
        return cag.ensureMinimalConnectivity(gameMap, genCtx)
}</span>

func (cag *CellularAutomataGenerator) ensureCompleteConnectivity(gameMap *game.GameMap, genCtx *pcg.GenerationContext) error <span class="cov0" title="0">{
        // Complete connectivity ensuring all areas are reachable
        return cag.ensureMinimalConnectivity(gameMap, genCtx)
}</span>

// Utility methods for tile creation
func (cag *CellularAutomataGenerator) createWallTile() game.MapTile <span class="cov0" title="0">{
        return game.MapTile{
                SpriteX:     1, // Wall sprite coordinates
                SpriteY:     0,
                Walkable:    false,
                Transparent: false,
        }
}</span>

func (cag *CellularAutomataGenerator) createFloorTile() game.MapTile <span class="cov0" title="0">{
        return game.MapTile{
                SpriteX:     0, // Floor sprite coordinates
                SpriteY:     0,
                Walkable:    true,
                Transparent: true,
        }
}</span>

func (cag *CellularAutomataGenerator) createWaterTile() game.MapTile <span class="cov0" title="0">{
        return game.MapTile{
                SpriteX:     2, // Water sprite coordinates
                SpriteY:     0,
                Walkable:    false, // Water is not walkable by default
                Transparent: true,
        }
}</span>

// Helper methods (simplified implementations)
func (cag *CellularAutomataGenerator) calculateIterations(difficulty int) int <span class="cov0" title="0">{
        // More difficult areas get more iterations for complexity
        return 4 + (difficulty / 5)
}</span>

func (cag *CellularAutomataGenerator) adjustParamsForBiome(params pcg.TerrainParams, biome pcg.BiomeType) pcg.TerrainParams <span class="cov0" title="0">{
        adjusted := params

        switch biome </span>{
        case pcg.BiomeCave:<span class="cov0" title="0">
                adjusted.Density = 0.45
                adjusted.WaterLevel = 0.1</span>
        case pcg.BiomeDungeon:<span class="cov0" title="0">
                adjusted.Density = 0.4
                adjusted.WaterLevel = 0.05</span>
        case pcg.BiomeSwamp:<span class="cov0" title="0">
                adjusted.Density = 0.3
                adjusted.WaterLevel = 0.4</span>
        }

        <span class="cov0" title="0">return adjusted</span>
}

// Feature addition methods (simplified implementations)
func (cag *CellularAutomataGenerator) addWaterFeatures(gameMap *game.GameMap, genCtx *pcg.GenerationContext, waterLevel float64) <span class="cov0" title="0">{
        // Add water tiles to low-lying floor areas
        for y := 1; y &lt; gameMap.Height-1; y++ </span><span class="cov0" title="0">{
                for x := 1; x &lt; gameMap.Width-1; x++ </span><span class="cov0" title="0">{
                        if gameMap.Tiles[y][x].Walkable &amp;&amp; genCtx.RandomFloat() &lt; waterLevel </span><span class="cov0" title="0">{
                                gameMap.Tiles[y][x] = cag.createWaterTile()
                        }</span>
                }
        }
}

func (cag *CellularAutomataGenerator) addCaveFeatures(gameMap *game.GameMap, genCtx *pcg.GenerationContext, roughness float64) {<span class="cov0" title="0">
        // Add cave-specific features based on roughness
        // This is a simplified implementation
}</span>

func (cag *CellularAutomataGenerator) addDungeonDoors(gameMap *game.GameMap, genCtx *pcg.GenerationContext) {<span class="cov0" title="0">
        // Add door markers for dungeon entrances
        // This is a simplified implementation
}</span>

func (cag *CellularAutomataGenerator) addTorchPositions(gameMap *game.GameMap, genCtx *pcg.GenerationContext) {<span class="cov0" title="0">
        // Add torch positions for dungeon lighting
        // This is a simplified implementation
}</span>

func (cag *CellularAutomataGenerator) addVegetation(gameMap *game.GameMap, genCtx *pcg.GenerationContext, density float64) {<span class="cov0" title="0">
        // Add vegetation features for swamp biomes
        // This is a simplified implementation
}</span>

// Connectivity helper methods (simplified implementations)
func (cag *CellularAutomataGenerator) findWalkableRegions(gameMap *game.GameMap) [][]game.Position <span class="cov0" title="0">{
        // Return connected components of walkable tiles
        // This is a simplified implementation that would use flood fill
        return [][]game.Position{}
}</span>

func (cag *CellularAutomataGenerator) findLargestRegion(regions [][]game.Position) int <span class="cov0" title="0">{
        maxSize := 0
        maxIndex := 0

        for i, region := range regions </span><span class="cov0" title="0">{
                if len(region) &gt; maxSize </span><span class="cov0" title="0">{
                        maxSize = len(region)
                        maxIndex = i
                }</span>
        }

        <span class="cov0" title="0">return maxIndex</span>
}

func (cag *CellularAutomataGenerator) connectRegions(gameMap *game.GameMap, region1, region2 []game.Position) {<span class="cov0" title="0">
        // Create a path between two regions by carving through walls
        // This is a simplified implementation
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package terrain

import (
        "context"
        "fmt"

        "goldbox-rpg/pkg/game"
        "goldbox-rpg/pkg/pcg"
)

// MazeGenerator creates maze-like terrain structures
type MazeGenerator struct {
        version string
}

// NewMazeGenerator creates a new maze terrain generator
func NewMazeGenerator() *MazeGenerator <span class="cov8" title="1">{
        return &amp;MazeGenerator{version: "1.0.0"}
}</span>

// Generate implements the Generator interface for maze terrain
func (mg *MazeGenerator) Generate(ctx context.Context, params pcg.GenerationParams) (interface{}, error) <span class="cov8" title="1">{
        // Extract terrain-specific parameters
        terrainParams, ok := params.Constraints["terrain_params"].(pcg.TerrainParams)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing or invalid terrain parameters")
        }</span>

        // Extract dimensions from constraints
        <span class="cov8" title="1">width, ok := params.Constraints["width"].(int)
        if !ok </span><span class="cov8" title="1">{
                width = 50 // Default width
        }</span>

        <span class="cov8" title="1">height, ok := params.Constraints["height"].(int)
        if !ok </span><span class="cov8" title="1">{
                height = 50 // Default height
        }</span>

        <span class="cov8" title="1">return mg.GenerateTerrain(ctx, width, height, terrainParams)</span>
}

// GetType implements the Generator interface
func (mg *MazeGenerator) GetType() pcg.ContentType <span class="cov8" title="1">{
        return pcg.ContentTypeTerrain
}</span>

// GetVersion implements the Generator interface
func (mg *MazeGenerator) GetVersion() string <span class="cov8" title="1">{
        return mg.version
}</span>

// Validate implements the Generator interface
func (mg *MazeGenerator) Validate(params pcg.GenerationParams) error <span class="cov8" title="1">{
        // Check if required constraints are present
        if params.Constraints == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("constraints required for maze generation")
        }</span>

        // Validate dimensions
        <span class="cov8" title="1">if width, ok := params.Constraints["width"].(int); ok &amp;&amp; width &lt; 5 </span><span class="cov8" title="1">{
                return fmt.Errorf("width must be at least 5 for maze generation")
        }</span>

        <span class="cov8" title="1">if height, ok := params.Constraints["height"].(int); ok &amp;&amp; height &lt; 5 </span><span class="cov8" title="1">{
                return fmt.Errorf("height must be at least 5 for maze generation")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GenerateTerrain creates maze-style terrain using recursive backtracking
func (mg *MazeGenerator) GenerateTerrain(ctx context.Context, width, height int, params pcg.TerrainParams) (*game.GameMap, error) <span class="cov8" title="1">{
        // Create generation context
        seedMgr := pcg.NewSeedManager(params.Seed)
        genCtx := pcg.NewGenerationContext(seedMgr, pcg.ContentTypeTerrain, "maze", params.GenerationParams)

        // Apply biome modifications
        if err := ApplyBiomeModifications(&amp;params, params.BiomeType); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply biome modifications: %w", err)
        }</span>

        // Initialize game map
        <span class="cov8" title="1">gameMap := &amp;game.GameMap{
                Width:  width,
                Height: height,
                Tiles:  make([][]game.MapTile, height),
        }

        for i := range gameMap.Tiles </span><span class="cov8" title="1">{
                gameMap.Tiles[i] = make([]game.MapTile, width)
        }</span>

        // Step 1: Create grid with all walls
        <span class="cov8" title="1">if err := mg.initializeAllWalls(gameMap); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize walls: %w", err)
        }</span>

        // Step 2: Use recursive backtracking to carve passages
        <span class="cov8" title="1">if err := mg.recursiveBacktrackMaze(gameMap, genCtx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate maze: %w", err)
        }</span>

        // Step 3: Add rooms and special features based on biome
        <span class="cov8" title="1">if err := mg.addSpecialFeatures(gameMap, params, genCtx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add special features: %w", err)
        }</span>

        // Step 4: Apply biome-specific modifications
        <span class="cov8" title="1">if err := mg.applyBiomeSpecificFeatures(gameMap, params, genCtx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply biome features: %w", err)
        }</span>

        <span class="cov8" title="1">return gameMap, nil</span>
}

// ValidateConnectivity implements the TerrainGenerator interface
func (mg *MazeGenerator) ValidateConnectivity(terrain *game.GameMap) bool <span class="cov8" title="1">{
        // Find first walkable tile
        var start *game.Position
        for y := 0; y &lt; terrain.Height &amp;&amp; start == nil; y++ </span><span class="cov8" title="1">{
                for x := 0; x &lt; terrain.Width &amp;&amp; start == nil; x++ </span><span class="cov8" title="1">{
                        if terrain.Tiles[y][x].Walkable </span><span class="cov8" title="1">{
                                start = &amp;game.Position{X: x, Y: y}
                        }</span>
                }
        }

        <span class="cov8" title="1">if start == nil </span><span class="cov8" title="1">{
                return false // No walkable tiles
        }</span>

        // Count total walkable tiles
        <span class="cov8" title="1">totalWalkable := 0
        for y := 0; y &lt; terrain.Height; y++ </span><span class="cov8" title="1">{
                for x := 0; x &lt; terrain.Width; x++ </span><span class="cov8" title="1">{
                        if terrain.Tiles[y][x].Walkable </span><span class="cov8" title="1">{
                                totalWalkable++
                        }</span>
                }
        }

        // Flood fill from start position
        <span class="cov8" title="1">visited := make([][]bool, terrain.Height)
        for i := range visited </span><span class="cov8" title="1">{
                visited[i] = make([]bool, terrain.Width)
        }</span>

        <span class="cov8" title="1">reachable := mg.floodFillCount(terrain, start.X, start.Y, visited)

        // All walkable tiles should be reachable
        return reachable == totalWalkable</span>
}

// GenerateBiome implements the TerrainGenerator interface
func (mg *MazeGenerator) GenerateBiome(ctx context.Context, biome pcg.BiomeType, bounds pcg.Rectangle, params pcg.TerrainParams) (*game.GameMap, error) <span class="cov8" title="1">{
        // Set biome type and generate terrain for the specified bounds
        params.BiomeType = biome
        return mg.GenerateTerrain(ctx, bounds.Width, bounds.Height, params)
}</span>

// initializeAllWalls fills the entire map with walls
func (mg *MazeGenerator) initializeAllWalls(gameMap *game.GameMap) error <span class="cov8" title="1">{
        for y := 0; y &lt; gameMap.Height; y++ </span><span class="cov8" title="1">{
                for x := 0; x &lt; gameMap.Width; x++ </span><span class="cov8" title="1">{
                        gameMap.Tiles[y][x].Walkable = false
                        gameMap.Tiles[y][x].Transparent = false
                        gameMap.Tiles[y][x].SpriteX = 1 // Wall sprite
                        gameMap.Tiles[y][x].SpriteY = 0
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// recursiveBacktrackMaze generates maze using recursive backtracking algorithm
func (mg *MazeGenerator) recursiveBacktrackMaze(gameMap *game.GameMap, genCtx *pcg.GenerationContext) error <span class="cov8" title="1">{
        // Stack for backtracking
        var stack []game.Position
        visited := make([][]bool, gameMap.Height)
        for i := range visited </span><span class="cov8" title="1">{
                visited[i] = make([]bool, gameMap.Width)
        }</span>

        // Start from an odd coordinate to ensure proper maze structure
        <span class="cov8" title="1">startX, startY := 1, 1
        if startX &gt;= gameMap.Width </span><span class="cov0" title="0">{
                startX = 0
        }</span>
        <span class="cov8" title="1">if startY &gt;= gameMap.Height </span><span class="cov0" title="0">{
                startY = 0
        }</span>

        // Mark starting position as passage
        <span class="cov8" title="1">gameMap.Tiles[startY][startX].Walkable = true
        gameMap.Tiles[startY][startX].Transparent = true
        gameMap.Tiles[startY][startX].SpriteX = 0 // Floor sprite
        gameMap.Tiles[startY][startX].SpriteY = 0
        visited[startY][startX] = true

        stack = append(stack, game.Position{X: startX, Y: startY})

        for len(stack) &gt; 0 </span><span class="cov8" title="1">{
                current := stack[len(stack)-1]

                // Get unvisited neighbors (2 steps away to maintain wall thickness)
                neighbors := mg.getUnvisitedNeighbors(current, visited, gameMap)

                if len(neighbors) &gt; 0 </span><span class="cov8" title="1">{
                        // Choose random neighbor
                        neighbor := neighbors[genCtx.RandomIntRange(0, len(neighbors)-1)]

                        // Remove wall between current and neighbor
                        wallX := (current.X + neighbor.X) / 2
                        wallY := (current.Y + neighbor.Y) / 2

                        // Carve passage to neighbor
                        gameMap.Tiles[neighbor.Y][neighbor.X].Walkable = true
                        gameMap.Tiles[neighbor.Y][neighbor.X].Transparent = true
                        gameMap.Tiles[neighbor.Y][neighbor.X].SpriteX = 0
                        gameMap.Tiles[neighbor.Y][neighbor.X].SpriteY = 0

                        // Carve wall between
                        gameMap.Tiles[wallY][wallX].Walkable = true
                        gameMap.Tiles[wallY][wallX].Transparent = true
                        gameMap.Tiles[wallY][wallX].SpriteX = 0
                        gameMap.Tiles[wallY][wallX].SpriteY = 0

                        visited[neighbor.Y][neighbor.X] = true
                        stack = append(stack, neighbor)
                }</span> else<span class="cov8" title="1"> {
                        // No unvisited neighbors, backtrack
                        stack = stack[:len(stack)-1]
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getUnvisitedNeighbors returns unvisited neighbors that are 2 steps away
func (mg *MazeGenerator) getUnvisitedNeighbors(pos game.Position, visited [][]bool, gameMap *game.GameMap) []game.Position <span class="cov8" title="1">{
        var neighbors []game.Position

        // Check all four directions, 2 steps away
        directions := []struct{ dx, dy int }{
                {0, -2}, // North
                {2, 0},  // East
                {0, 2},  // South
                {-2, 0}, // West
        }

        for _, dir := range directions </span><span class="cov8" title="1">{
                nx, ny := pos.X+dir.dx, pos.Y+dir.dy

                if nx &gt;= 0 &amp;&amp; nx &lt; gameMap.Width &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; gameMap.Height </span><span class="cov8" title="1">{
                        if !visited[ny][nx] </span><span class="cov8" title="1">{
                                neighbors = append(neighbors, game.Position{X: nx, Y: ny})
                        }</span>
                }
        }

        <span class="cov8" title="1">return neighbors</span>
}

// addSpecialFeatures adds rooms and special features to the maze
func (mg *MazeGenerator) addSpecialFeatures(gameMap *game.GameMap, params pcg.TerrainParams, genCtx *pcg.GenerationContext) error <span class="cov8" title="1">{
        // Add some larger open areas (rooms) based on difficulty
        roomCount := params.Difficulty / 3
        if roomCount &lt; 1 </span><span class="cov8" title="1">{
                roomCount = 1
        }</span>
        <span class="cov8" title="1">if roomCount &gt; 5 </span><span class="cov0" title="0">{
                roomCount = 5
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; roomCount; i++ </span><span class="cov8" title="1">{
                roomSize := genCtx.RandomIntRange(3, 7)
                roomX := genCtx.RandomIntRange(1, gameMap.Width-roomSize-1)
                roomY := genCtx.RandomIntRange(1, gameMap.Height-roomSize-1)

                // Create room
                for y := roomY; y &lt; roomY+roomSize; y++ </span><span class="cov8" title="1">{
                        for x := roomX; x &lt; roomX+roomSize; x++ </span><span class="cov8" title="1">{
                                if x &lt; gameMap.Width &amp;&amp; y &lt; gameMap.Height </span><span class="cov8" title="1">{
                                        gameMap.Tiles[y][x].Walkable = true
                                        gameMap.Tiles[y][x].Transparent = true
                                        gameMap.Tiles[y][x].SpriteX = 0
                                        gameMap.Tiles[y][x].SpriteY = 0
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// applyBiomeSpecificFeatures adds biome-specific elements to the maze
func (mg *MazeGenerator) applyBiomeSpecificFeatures(gameMap *game.GameMap, params pcg.TerrainParams, genCtx *pcg.GenerationContext) error <span class="cov8" title="1">{
        features, err := GetBiomeFeatures(params.BiomeType)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Apply each feature with some probability
        <span class="cov8" title="1">for _, feature := range features </span><span class="cov8" title="1">{
                if genCtx.RandomFloat() &lt; 0.3 </span><span class="cov8" title="1">{ // 30% chance for each feature
                        switch feature </span>{
                        case pcg.FeatureWater:<span class="cov0" title="0">
                                mg.addWaterFeatures(gameMap, genCtx)</span>
                        case pcg.FeatureTraps:<span class="cov8" title="1">
                                mg.addTrapFeatures(gameMap, genCtx)</span>
                        case pcg.FeatureSecretDoors:<span class="cov8" title="1">
                                mg.addSecretDoors(gameMap, genCtx)</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// addWaterFeatures adds water tiles to some floor areas
func (mg *MazeGenerator) addWaterFeatures(gameMap *game.GameMap, genCtx *pcg.GenerationContext) <span class="cov0" title="0">{
        waterCount := genCtx.RandomIntRange(2, 8)

        for i := 0; i &lt; waterCount; i++ </span><span class="cov0" title="0">{
                x := genCtx.RandomIntRange(0, gameMap.Width-1)
                y := genCtx.RandomIntRange(0, gameMap.Height-1)

                if gameMap.Tiles[y][x].Walkable </span><span class="cov0" title="0">{
                        gameMap.Tiles[y][x].SpriteX = 2 // Water sprite
                        gameMap.Tiles[y][x].SpriteY = 0
                }</span>
        }
}

// addTrapFeatures marks some floor tiles as potentially dangerous
func (mg *MazeGenerator) addTrapFeatures(gameMap *game.GameMap, genCtx *pcg.GenerationContext) <span class="cov8" title="1">{
        trapCount := genCtx.RandomIntRange(1, 5)

        for i := 0; i &lt; trapCount; i++ </span><span class="cov8" title="1">{
                x := genCtx.RandomIntRange(0, gameMap.Width-1)
                y := genCtx.RandomIntRange(0, gameMap.Height-1)

                if gameMap.Tiles[y][x].Walkable </span><span class="cov8" title="1">{
                        gameMap.Tiles[y][x].SpriteX = 3 // Trap sprite
                        gameMap.Tiles[y][x].SpriteY = 0
                }</span>
        }
}

// addSecretDoors converts some walls to secret passages
func (mg *MazeGenerator) addSecretDoors(gameMap *game.GameMap, genCtx *pcg.GenerationContext) <span class="cov8" title="1">{
        secretCount := genCtx.RandomIntRange(1, 3)

        for i := 0; i &lt; secretCount; i++ </span><span class="cov8" title="1">{
                x := genCtx.RandomIntRange(1, gameMap.Width-2)
                y := genCtx.RandomIntRange(1, gameMap.Height-2)

                if !gameMap.Tiles[y][x].Walkable </span><span class="cov8" title="1">{
                        // Check if this wall has passages on both sides
                        if (gameMap.Tiles[y][x-1].Walkable &amp;&amp; gameMap.Tiles[y][x+1].Walkable) ||
                                (gameMap.Tiles[y-1][x].Walkable &amp;&amp; gameMap.Tiles[y+1][x].Walkable) </span><span class="cov8" title="1">{
                                gameMap.Tiles[y][x].Walkable = true
                                gameMap.Tiles[y][x].Transparent = true
                                gameMap.Tiles[y][x].SpriteX = 4 // Secret door sprite
                                gameMap.Tiles[y][x].SpriteY = 0
                        }</span>
                }
        }
}

// floodFillCount performs flood fill and returns the count of reachable tiles
func (mg *MazeGenerator) floodFillCount(gameMap *game.GameMap, startX, startY int, visited [][]bool) int <span class="cov8" title="1">{
        if startX &lt; 0 || startX &gt;= gameMap.Width || startY &lt; 0 || startY &gt;= gameMap.Height </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">if visited[startY][startX] || !gameMap.Tiles[startY][startX].Walkable </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">visited[startY][startX] = true
        count := 1

        // Check 4-connected neighbors
        count += mg.floodFillCount(gameMap, startX+1, startY, visited)
        count += mg.floodFillCount(gameMap, startX-1, startY, visited)
        count += mg.floodFillCount(gameMap, startX, startY+1, visited)
        count += mg.floodFillCount(gameMap, startX, startY-1, visited)

        return count</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package pcg

import "goldbox-rpg/pkg/game"

// BiomeType represents different terrain biomes for generation
type BiomeType string

const (
        BiomeForest    BiomeType = "forest"
        BiomeMountain  BiomeType = "mountain"
        BiomeDesert    BiomeType = "desert"
        BiomeSwamp     BiomeType = "swamp"
        BiomeCave      BiomeType = "cave"
        BiomeDungeon   BiomeType = "dungeon"
        BiomeCoastal   BiomeType = "coastal"
        BiomeUrban     BiomeType = "urban"
        BiomeWasteland BiomeType = "wasteland"
)

// RarityTier represents item rarity levels
type RarityTier string

const (
        RarityCommon    RarityTier = "common"
        RarityUncommon  RarityTier = "uncommon"
        RarityRare      RarityTier = "rare"
        RarityEpic      RarityTier = "epic"
        RarityLegendary RarityTier = "legendary"
        RarityArtifact  RarityTier = "artifact"
)

// RoomType represents different types of rooms in generated levels
type RoomType string

const (
        RoomTypeEntrance RoomType = "entrance"
        RoomTypeExit     RoomType = "exit"
        RoomTypeCombat   RoomType = "combat"
        RoomTypeTreasure RoomType = "treasure"
        RoomTypePuzzle   RoomType = "puzzle"
        RoomTypeBoss     RoomType = "boss"
        RoomTypeSecret   RoomType = "secret"
        RoomTypeShop     RoomType = "shop"
        RoomTypeRest     RoomType = "rest"
        RoomTypeTrap     RoomType = "trap"
        RoomTypeStory    RoomType = "story"
)

// CorridorStyle represents different corridor generation approaches
type CorridorStyle string

const (
        CorridorStraight CorridorStyle = "straight"
        CorridorWindy    CorridorStyle = "windy"
        CorridorMaze     CorridorStyle = "maze"
        CorridorOrganic  CorridorStyle = "organic"
        CorridorMinimal  CorridorStyle = "minimal"
)

// LevelTheme represents thematic constraints for level generation
type LevelTheme string

const (
        ThemeClassic    LevelTheme = "classic"
        ThemeHorror     LevelTheme = "horror"
        ThemeNatural    LevelTheme = "natural"
        ThemeMechanical LevelTheme = "mechanical"
        ThemeMagical    LevelTheme = "magical"
        ThemeUndead     LevelTheme = "undead"
        ThemeElemental  LevelTheme = "elemental"
)

// QuestType represents different categories of quests
type QuestType string

const (
        QuestTypeFetch    QuestType = "fetch"
        QuestTypeKill     QuestType = "kill"
        QuestTypeEscort   QuestType = "escort"
        QuestTypeExplore  QuestType = "explore"
        QuestTypeDefend   QuestType = "defend"
        QuestTypePuzzle   QuestType = "puzzle"
        QuestTypeDelivery QuestType = "delivery"
        QuestTypeSurvival QuestType = "survival"
        QuestTypeStory    QuestType = "story"
)

// NarrativeType represents different story generation styles
type NarrativeType string

const (
        NarrativeLinear    NarrativeType = "linear"
        NarrativeBranching NarrativeType = "branching"
        NarrativeOpen      NarrativeType = "open"
        NarrativeEpisodic  NarrativeType = "episodic"
)

// ConnectivityLevel represents how connected terrain features should be
type ConnectivityLevel string

const (
        ConnectivityNone     ConnectivityLevel = "none"
        ConnectivityLow      ConnectivityLevel = "low"
        ConnectivityMinimal  ConnectivityLevel = "minimal"
        ConnectivityModerate ConnectivityLevel = "moderate"
        ConnectivityHigh     ConnectivityLevel = "high"
        ConnectivityComplete ConnectivityLevel = "complete"
)

// TerrainFeature represents special features that can be included in terrain
type TerrainFeature string

const (
        FeatureWater            TerrainFeature = "water"
        FeatureMountain         TerrainFeature = "mountain"
        FeatureForest           TerrainFeature = "forest"
        FeatureCave             TerrainFeature = "cave"
        FeatureRuins            TerrainFeature = "ruins"
        FeatureRoad             TerrainFeature = "road"
        FeatureBridge           TerrainFeature = "bridge"
        FeatureTown             TerrainFeature = "town"
        FeatureShrine           TerrainFeature = "shrine"
        FeatureStalactites      TerrainFeature = "stalactites"
        FeatureUndergroundRiver TerrainFeature = "underground_river"
        FeatureSecretDoors      TerrainFeature = "secret_doors"
        FeatureTraps            TerrainFeature = "traps"
        FeatureTrees            TerrainFeature = "trees"
        FeatureStreams          TerrainFeature = "streams"
        FeatureCliffs           TerrainFeature = "cliffs"
        FeatureCrevasses        TerrainFeature = "crevasses"
        FeatureBogs             TerrainFeature = "bogs"
        FeatureVines            TerrainFeature = "vines"
        FeatureDunes            TerrainFeature = "dunes"
        FeatureOasis            TerrainFeature = "oasis"
)

// ItemSetType represents collections of related items
type ItemSetType string

const (
        ItemSetArmor    ItemSetType = "armor"
        ItemSetWeapons  ItemSetType = "weapons"
        ItemSetJewelry  ItemSetType = "jewelry"
        ItemSetTools    ItemSetType = "tools"
        ItemSetConsumab ItemSetType = "consumables"
        ItemSetMagical  ItemSetType = "magical"
        ItemSetCrafting ItemSetType = "crafting"
)

// Rectangle represents a rectangular area for spatial operations
type Rectangle struct {
        X, Y          int // Top-left corner coordinates
        Width, Height int // Dimensions
}

// Contains checks if a position is within the rectangle
func (r Rectangle) Contains(x, y int) bool <span class="cov0" title="0">{
        return x &gt;= r.X &amp;&amp; x &lt; r.X+r.Width &amp;&amp; y &gt;= r.Y &amp;&amp; y &lt; r.Y+r.Height
}</span>

// Intersects checks if this rectangle intersects with another
func (r Rectangle) Intersects(other Rectangle) bool <span class="cov0" title="0">{
        return r.X &lt; other.X+other.Width &amp;&amp;
                r.X+r.Width &gt; other.X &amp;&amp;
                r.Y &lt; other.Y+other.Height &amp;&amp;
                r.Y+r.Height &gt; other.Y
}</span>

// RoomLayout represents the layout of a generated room
type RoomLayout struct {
        ID         string                 `yaml:"id"`         // Unique room identifier
        Type       RoomType               `yaml:"type"`       // Room type classification
        Bounds     Rectangle              `yaml:"bounds"`     // Room dimensions and position
        Tiles      [][]game.Tile          `yaml:"tiles"`      // Room tile data
        Doors      []game.Position        `yaml:"doors"`      // Door/entrance positions
        Features   []RoomFeature          `yaml:"features"`   // Special room features
        Difficulty int                    `yaml:"difficulty"` // Challenge rating
        Properties map[string]interface{} `yaml:"properties"` // Additional room data
        Connected  []string               `yaml:"connected"`  // IDs of connected rooms
}

// Corridor represents a connection between rooms
type Corridor struct {
        ID       string            `yaml:"id"`       // Unique corridor identifier
        Start    game.Position     `yaml:"start"`    // Starting position
        End      game.Position     `yaml:"end"`      // Ending position
        Path     []game.Position   `yaml:"path"`     // Corridor path tiles
        Width    int               `yaml:"width"`    // Corridor width
        Style    CorridorStyle     `yaml:"style"`    // Generation style used
        Features []CorridorFeature `yaml:"features"` // Special corridor features
}

// RoomFeature represents special features within rooms
type RoomFeature struct {
        Type       string                 `yaml:"type"`       // Feature type (chest, altar, etc.)
        Position   game.Position          `yaml:"position"`   // Location within room
        Properties map[string]interface{} `yaml:"properties"` // Feature-specific data
}

// CorridorFeature represents special features within corridors
type CorridorFeature struct {
        Type       string                 `yaml:"type"`       // Feature type (trap, secret door, etc.)
        Position   game.Position          `yaml:"position"`   // Location within corridor
        Properties map[string]interface{} `yaml:"properties"` // Feature-specific data
}

// ItemTemplate represents a template for procedural item generation
type ItemTemplate struct {
        BaseType   string                `yaml:"base_type"`   // Base item type (sword, armor, etc.)
        NameParts  []string              `yaml:"name_parts"`  // Name generation components
        StatRanges map[string]StatRange  `yaml:"stat_ranges"` // Stat generation ranges
        Properties []string              `yaml:"properties"`  // Possible item properties
        Enchants   []EnchantmentTemplate `yaml:"enchants"`    // Available enchantments
        Materials  []string              `yaml:"materials"`   // Possible materials
        Rarities   []RarityTier          `yaml:"rarities"`    // Applicable rarity tiers
}

// StatRange represents a range for procedural stat generation
type StatRange struct {
        Min     int     `yaml:"min"`     // Minimum value
        Max     int     `yaml:"max"`     // Maximum value
        Scaling float64 `yaml:"scaling"` // Level scaling factor
}

// EnchantmentTemplate represents a template for procedural enchantments
type EnchantmentTemplate struct {
        Name         string                 `yaml:"name"`         // Enchantment name
        Type         string                 `yaml:"type"`         // Enchantment type
        MinLevel     int                    `yaml:"min_level"`    // Minimum required level
        MaxLevel     int                    `yaml:"max_level"`    // Maximum applicable level
        Effects      []game.Effect          `yaml:"effects"`      // Enchantment effects
        Restrictions map[string]interface{} `yaml:"restrictions"` // Usage restrictions
}

// QuestObjective represents a single quest objective
type QuestObjective struct {
        ID          string                 `yaml:"id"`          // Unique objective ID
        Type        string                 `yaml:"type"`        // Objective type
        Description string                 `yaml:"description"` // Human-readable description
        Target      string                 `yaml:"target"`      // Target entity/location
        Quantity    int                    `yaml:"quantity"`    // Required quantity
        Progress    int                    `yaml:"progress"`    // Current progress
        Complete    bool                   `yaml:"complete"`    // Completion status
        Optional    bool                   `yaml:"optional"`    // Whether objective is optional
        Conditions  map[string]interface{} `yaml:"conditions"`  // Completion conditions
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package utils

import (
        "math"
)

// PerlinNoise generates Perlin noise for terrain generation
type PerlinNoise struct {
        seed        int64
        permutation []int
}

// NewPerlinNoise creates a new Perlin noise generator with seed
func NewPerlinNoise(seed int64) *PerlinNoise <span class="cov8" title="1">{
        pn := &amp;PerlinNoise{
                seed:        seed,
                permutation: make([]int, 512),
        }

        // Initialize permutation table with seed
        pn.initPermutation()
        return pn
}</span>

// initPermutation initializes the permutation table deterministically from seed
func (pn *PerlinNoise) initPermutation() <span class="cov8" title="1">{
        // Standard Perlin permutation table
        p := []int{
                151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,
                140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148,
                247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32,
                57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175,
                74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122,
                60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54,
                65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169,
                200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64,
                52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212,
                207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213,
                119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
                129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104,
                218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241,
                81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157,
                184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
                222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
        }

        // Shuffle based on seed (simple linear congruential generator)
        rng := pn.seed
        for i := len(p) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{
                rng = (rng*1103515245 + 12345) &amp; 0x7fffffff
                j := int(rng) % (i + 1)
                p[i], p[j] = p[j], p[i]
        }</span>

        // Double the permutation table
        <span class="cov8" title="1">for i := 0; i &lt; 256; i++ </span><span class="cov8" title="1">{
                pn.permutation[i] = p[i]
                pn.permutation[i+256] = p[i]
        }</span>
}

// Noise2D generates 2D Perlin noise value at coordinates
func (pn *PerlinNoise) Noise2D(x, y float64) float64 <span class="cov8" title="1">{
        // Find unit square that contains point
        xi := int(math.Floor(x)) &amp; 255
        yi := int(math.Floor(y)) &amp; 255

        // Find relative x,y of point in square
        xf := x - math.Floor(x)
        yf := y - math.Floor(y)

        // Compute fade curves for each of x,y
        u := fade(xf)
        v := fade(yf)

        // Hash coordinates of square corners
        aa := pn.permutation[pn.permutation[xi]+yi]
        ab := pn.permutation[pn.permutation[xi]+yi+1]
        ba := pn.permutation[pn.permutation[xi+1]+yi]
        bb := pn.permutation[pn.permutation[xi+1]+yi+1]

        // Add blended results from 4 corners of square
        x1 := lerp(u, grad2d(aa, xf, yf), grad2d(ba, xf-1, yf))
        x2 := lerp(u, grad2d(ab, xf, yf-1), grad2d(bb, xf-1, yf-1))

        return lerp(v, x1, x2)
}</span>

// FractalNoise generates fractal noise by combining multiple octaves
func (pn *PerlinNoise) FractalNoise(x, y float64, octaves int, persistence, scale float64) float64 <span class="cov0" title="0">{
        var value float64
        var amplitude float64 = 1.0
        var frequency float64 = scale

        for i := 0; i &lt; octaves; i++ </span><span class="cov0" title="0">{
                value += pn.Noise2D(x*frequency, y*frequency) * amplitude
                amplitude *= persistence
                frequency *= 2.0
        }</span>

        <span class="cov0" title="0">return value</span>
}

// SimplexNoise provides faster alternative to Perlin noise
type SimplexNoise struct {
        seed int64
        grad [][]float64
        perm []int
}

// NewSimplexNoise creates a new Simplex noise generator
func NewSimplexNoise(seed int64) *SimplexNoise <span class="cov8" title="1">{
        sn := &amp;SimplexNoise{
                seed: seed,
                grad: [][]float64{
                        {1, 1}, {-1, 1}, {1, -1}, {-1, -1},
                        {1, 0}, {-1, 0}, {1, 0}, {-1, 0},
                        {0, 1}, {0, -1}, {0, 1}, {0, -1},
                },
                perm: make([]int, 512),
        }

        sn.initPermutation()
        return sn
}</span>

// initPermutation initializes permutation table for simplex noise
func (sn *SimplexNoise) initPermutation() <span class="cov8" title="1">{
        p := make([]int, 256)
        for i := 0; i &lt; 256; i++ </span><span class="cov8" title="1">{
                p[i] = i
        }</span>

        // Shuffle based on seed
        <span class="cov8" title="1">rng := sn.seed
        for i := len(p) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{
                rng = (rng*1103515245 + 12345) &amp; 0x7fffffff
                j := int(rng) % (i + 1)
                p[i], p[j] = p[j], p[i]
        }</span>

        // Double the permutation table
        <span class="cov8" title="1">for i := 0; i &lt; 256; i++ </span><span class="cov8" title="1">{
                sn.perm[i] = p[i]
                sn.perm[i+256] = p[i]
        }</span>
}

// Noise2D generates 2D Simplex noise
func (sn *SimplexNoise) Noise2D(x, y float64) float64 <span class="cov8" title="1">{
        var F2 = 0.5 * (math.Sqrt(3.0) - 1.0)
        var G2 = (3.0 - math.Sqrt(3.0)) / 6.0

        // Skew the input space to determine which simplex cell we're in
        s := (x + y) * F2
        i := int(math.Floor(x + s))
        j := int(math.Floor(y + s))

        t := float64(i+j) * G2
        X0 := float64(i) - t
        Y0 := float64(j) - t
        x0 := x - X0
        y0 := y - Y0

        // Determine which simplex we are in
        var i1, j1 int
        if x0 &gt; y0 </span><span class="cov8" title="1">{
                i1, j1 = 1, 0
        }</span> else<span class="cov8" title="1"> {
                i1, j1 = 0, 1
        }</span>

        // Calculate the contribution from the three corners
        <span class="cov8" title="1">x1 := x0 - float64(i1) + G2
        y1 := y0 - float64(j1) + G2
        x2 := x0 - 1.0 + 2.0*G2
        y2 := y0 - 1.0 + 2.0*G2

        // Work out the hashed gradient indices of the three simplex corners
        ii := i &amp; 255
        jj := j &amp; 255
        gi0 := sn.perm[ii+sn.perm[jj]] % 12
        gi1 := sn.perm[ii+i1+sn.perm[jj+j1]] % 12
        gi2 := sn.perm[ii+1+sn.perm[jj+1]] % 12

        // Calculate the contribution from the three corners
        var n0, n1, n2 float64

        t0 := 0.5 - x0*x0 - y0*y0
        if t0 &lt; 0 </span><span class="cov0" title="0">{
                n0 = 0.0
        }</span> else<span class="cov8" title="1"> {
                t0 *= t0
                n0 = t0 * t0 * dot2d(sn.grad[gi0], x0, y0)
        }</span>

        <span class="cov8" title="1">t1 := 0.5 - x1*x1 - y1*y1
        if t1 &lt; 0 </span><span class="cov8" title="1">{
                n1 = 0.0
        }</span> else<span class="cov8" title="1"> {
                t1 *= t1
                n1 = t1 * t1 * dot2d(sn.grad[gi1], x1, y1)
        }</span>

        <span class="cov8" title="1">t2 := 0.5 - x2*x2 - y2*y2
        if t2 &lt; 0 </span><span class="cov0" title="0">{
                n2 = 0.0
        }</span> else<span class="cov8" title="1"> {
                t2 *= t2
                n2 = t2 * t2 * dot2d(sn.grad[gi2], x2, y2)
        }</span>

        // Add contributions from each corner to get the final noise value
        <span class="cov8" title="1">return 70.0 * (n0 + n1 + n2)</span>
}

// Helper functions

// fade implements the 6t^5 - 15t^4 + 10t^3 fade function
func fade(t float64) float64 <span class="cov8" title="1">{
        return t * t * t * (t*(t*6-15) + 10)
}</span>

// lerp performs linear interpolation
func lerp(t, a, b float64) float64 <span class="cov8" title="1">{
        return a + t*(b-a)
}</span>

// grad2d calculates gradient for 2D Perlin noise
func grad2d(hash int, x, y float64) float64 <span class="cov8" title="1">{
        h := hash &amp; 3
        u := x
        if h &gt;= 2 </span><span class="cov8" title="1">{
                u = y
        }</span>
        <span class="cov8" title="1">v := y
        if h &gt;= 2 </span><span class="cov8" title="1">{
                v = x
        }</span>

        <span class="cov8" title="1">uSign := 1.0
        if (h &amp; 1) != 0 </span><span class="cov8" title="1">{
                uSign = -1.0
        }</span>

        <span class="cov8" title="1">vSign := 1.0
        if (h &amp; 2) != 0 </span><span class="cov8" title="1">{
                vSign = -1.0
        }</span>

        <span class="cov8" title="1">return uSign*u + vSign*v</span>
}

// dot2d calculates dot product for simplex noise
func dot2d(g []float64, x, y float64) float64 <span class="cov8" title="1">{
        return g[0]*x + g[1]*y
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package utils

import (
        "container/heap"
        "math"

        "goldbox-rpg/pkg/game"
)

// PathfindingResult represents the result of pathfinding
type PathfindingResult struct {
        Path     []game.Position `json:"path"`
        Found    bool            `json:"found"`
        Distance int             `json:"distance"`
}

// Node represents a node in the A* pathfinding algorithm
type Node struct {
        Position game.Position
        G        int   // Cost from start to this node
        H        int   // Heuristic cost from this node to goal
        F        int   // Total cost (G + H)
        Parent   *Node // Parent node for path reconstruction
        Index    int   // Index in the priority queue
}

// PriorityQueue implements a priority queue for A* pathfinding
type PriorityQueue []*Node

func (pq PriorityQueue) Len() int <span class="cov8" title="1">{ return len(pq) }</span>

func (pq PriorityQueue) Less(i, j int) bool <span class="cov8" title="1">{
        return pq[i].F &lt; pq[j].F
}</span>

func (pq PriorityQueue) Swap(i, j int) <span class="cov8" title="1">{
        pq[i], pq[j] = pq[j], pq[i]
        pq[i].Index = i
        pq[j].Index = j
}</span>

func (pq *PriorityQueue) Push(x interface{}) <span class="cov8" title="1">{
        n := len(*pq)
        node := x.(*Node)
        node.Index = n
        *pq = append(*pq, node)
}</span>

func (pq *PriorityQueue) Pop() interface{} <span class="cov8" title="1">{
        old := *pq
        n := len(old)
        node := old[n-1]
        node.Index = -1
        *pq = old[0 : n-1]
        return node
}</span>

// AStarPathfind finds optimal path using A* algorithm
func AStarPathfind(gameMap *game.GameMap, start, goal game.Position) *PathfindingResult <span class="cov8" title="1">{
        // Check if start and goal are valid
        if !isValidPosition(gameMap, start) || !isValidPosition(gameMap, goal) </span><span class="cov8" title="1">{
                return &amp;PathfindingResult{Found: false}
        }</span>

        // Check if start and goal are walkable
        <span class="cov8" title="1">if !gameMap.Tiles[start.Y][start.X].Walkable || !gameMap.Tiles[goal.Y][goal.X].Walkable </span><span class="cov8" title="1">{
                return &amp;PathfindingResult{Found: false}
        }</span>

        // Initialize open and closed sets
        <span class="cov8" title="1">openSet := &amp;PriorityQueue{}
        heap.Init(openSet)

        closedSet := make(map[game.Position]bool)
        nodeMap := make(map[game.Position]*Node)

        // Create start node
        startNode := &amp;Node{
                Position: start,
                G:        0,
                H:        manhattanDistance(start, goal),
                Parent:   nil,
        }
        startNode.F = startNode.G + startNode.H

        heap.Push(openSet, startNode)
        nodeMap[start] = startNode

        for openSet.Len() &gt; 0 </span><span class="cov8" title="1">{
                // Get node with lowest F cost
                current := heap.Pop(openSet).(*Node)

                // Check if we reached the goal
                if current.Position == goal </span><span class="cov8" title="1">{
                        path := reconstructPath(current)
                        return &amp;PathfindingResult{
                                Path:     path,
                                Found:    true,
                                Distance: len(path) - 1,
                        }
                }</span>

                // Add current to closed set
                <span class="cov8" title="1">closedSet[current.Position] = true

                // Check all neighbors
                neighbors := getNeighbors(gameMap, current.Position)
                for _, neighborPos := range neighbors </span><span class="cov8" title="1">{
                        if closedSet[neighborPos] </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">tentativeG := current.G + 1 // Cost to move to neighbor

                        // Check if this neighbor is already in open set
                        neighborNode, exists := nodeMap[neighborPos]
                        if !exists </span><span class="cov8" title="1">{
                                // Create new node
                                neighborNode = &amp;Node{
                                        Position: neighborPos,
                                        G:        tentativeG,
                                        H:        manhattanDistance(neighborPos, goal),
                                        Parent:   current,
                                }
                                neighborNode.F = neighborNode.G + neighborNode.H
                                heap.Push(openSet, neighborNode)
                                nodeMap[neighborPos] = neighborNode
                        }</span> else<span class="cov8" title="1"> if tentativeG &lt; neighborNode.G </span><span class="cov0" title="0">{
                                // This path to neighbor is better than previous one
                                neighborNode.G = tentativeG
                                neighborNode.F = neighborNode.G + neighborNode.H
                                neighborNode.Parent = current
                                heap.Fix(openSet, neighborNode.Index)
                        }</span>
                }
        }

        // No path found
        <span class="cov8" title="1">return &amp;PathfindingResult{Found: false}</span>
}

// FloodFill finds all connected walkable areas
func FloodFill(gameMap *game.GameMap, start game.Position) []game.Position <span class="cov8" title="1">{
        if !isValidPosition(gameMap, start) || !gameMap.Tiles[start.Y][start.X].Walkable </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">visited := make(map[game.Position]bool)
        var result []game.Position
        var stack []game.Position

        stack = append(stack, start)

        for len(stack) &gt; 0 </span><span class="cov8" title="1">{
                current := stack[len(stack)-1]
                stack = stack[:len(stack)-1]

                if visited[current] </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !isValidPosition(gameMap, current) || !gameMap.Tiles[current.Y][current.X].Walkable </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">visited[current] = true
                result = append(result, current)

                // Add 4-connected neighbors
                neighbors := []game.Position{
                        {X: current.X + 1, Y: current.Y},
                        {X: current.X - 1, Y: current.Y},
                        {X: current.X, Y: current.Y + 1},
                        {X: current.X, Y: current.Y - 1},
                }

                for _, neighbor := range neighbors </span><span class="cov8" title="1">{
                        if !visited[neighbor] </span><span class="cov8" title="1">{
                                stack = append(stack, neighbor)
                        }</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

// ValidateConnectivity checks if all walkable areas are connected
func ValidateConnectivity(gameMap *game.GameMap) bool <span class="cov8" title="1">{
        // Find all walkable tiles
        var walkableTiles []game.Position
        for y := 0; y &lt; gameMap.Height; y++ </span><span class="cov8" title="1">{
                for x := 0; x &lt; gameMap.Width; x++ </span><span class="cov8" title="1">{
                        if gameMap.Tiles[y][x].Walkable </span><span class="cov8" title="1">{
                                walkableTiles = append(walkableTiles, game.Position{X: x, Y: y})
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(walkableTiles) == 0 </span><span class="cov8" title="1">{
                return true // No walkable tiles, technically connected
        }</span>

        // Use flood fill from first walkable tile
        <span class="cov8" title="1">reachable := FloodFill(gameMap, walkableTiles[0])

        // Check if all walkable tiles are reachable
        return len(reachable) == len(walkableTiles)</span>
}

// Helper functions

// isValidPosition checks if a position is within map bounds
func isValidPosition(gameMap *game.GameMap, pos game.Position) bool <span class="cov8" title="1">{
        return pos.X &gt;= 0 &amp;&amp; pos.X &lt; gameMap.Width &amp;&amp; pos.Y &gt;= 0 &amp;&amp; pos.Y &lt; gameMap.Height
}</span>

// manhattanDistance calculates Manhattan distance between two positions
func manhattanDistance(a, b game.Position) int <span class="cov8" title="1">{
        return int(math.Abs(float64(a.X-b.X)) + math.Abs(float64(a.Y-b.Y)))
}</span>

// getNeighbors returns valid walkable neighbors of a position
func getNeighbors(gameMap *game.GameMap, pos game.Position) []game.Position <span class="cov8" title="1">{
        neighbors := []game.Position{
                {X: pos.X + 1, Y: pos.Y},
                {X: pos.X - 1, Y: pos.Y},
                {X: pos.X, Y: pos.Y + 1},
                {X: pos.X, Y: pos.Y - 1},
        }

        var validNeighbors []game.Position
        for _, neighbor := range neighbors </span><span class="cov8" title="1">{
                if isValidPosition(gameMap, neighbor) &amp;&amp; gameMap.Tiles[neighbor.Y][neighbor.X].Walkable </span><span class="cov8" title="1">{
                        validNeighbors = append(validNeighbors, neighbor)
                }</span>
        }

        <span class="cov8" title="1">return validNeighbors</span>
}

// reconstructPath builds the path from goal back to start
func reconstructPath(node *Node) []game.Position <span class="cov8" title="1">{
        var path []game.Position
        current := node

        for current != nil </span><span class="cov8" title="1">{
                path = append([]game.Position{current.Position}, path...)
                current = current.Parent
        }</span>

        <span class="cov8" title="1">return path</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package pcg

import (
        "fmt"
        "strings"

        "goldbox-rpg/pkg/game"
)

// ValidationResult represents the result of content validation
type ValidationResult struct {
        Valid    bool     `yaml:"valid"`
        Errors   []string `yaml:"errors"`
        Warnings []string `yaml:"warnings"`
}

// IsValid returns true if validation passed without errors
func (vr *ValidationResult) IsValid() bool <span class="cov0" title="0">{
        return vr.Valid &amp;&amp; len(vr.Errors) == 0
}</span>

// HasWarnings returns true if there are validation warnings
func (vr *ValidationResult) HasWarnings() bool <span class="cov0" title="0">{
        return len(vr.Warnings) &gt; 0
}</span>

// AddError adds an error to the validation result
func (vr *ValidationResult) AddError(message string) <span class="cov0" title="0">{
        vr.Errors = append(vr.Errors, message)
        vr.Valid = false
}</span>

// AddWarning adds a warning to the validation result
func (vr *ValidationResult) AddWarning(message string) <span class="cov0" title="0">{
        vr.Warnings = append(vr.Warnings, message)
}</span>

// Merge combines another validation result into this one
func (vr *ValidationResult) Merge(other *ValidationResult) <span class="cov0" title="0">{
        vr.Errors = append(vr.Errors, other.Errors...)
        vr.Warnings = append(vr.Warnings, other.Warnings...)
        if !other.Valid </span><span class="cov0" title="0">{
                vr.Valid = false
        }</span>
}

// Validator provides validation for generated content
type Validator struct {
        strictMode bool
}

// NewValidator creates a new content validator
func NewValidator(strictMode bool) *Validator <span class="cov0" title="0">{
        return &amp;Validator{
                strictMode: strictMode,
        }
}</span>

// ValidateGenerationParams validates common generation parameters
func (v *Validator) ValidateGenerationParams(params GenerationParams) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        // Validate seed (any int64 value is acceptable)

        // Validate difficulty range
        if params.Difficulty &lt; 1 || params.Difficulty &gt; 20 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("difficulty must be between 1 and 20, got %d", params.Difficulty))
        }</span>

        // Validate player level
        <span class="cov0" title="0">if params.PlayerLevel &lt; 1 || params.PlayerLevel &gt; 20 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("player level must be between 1 and 20, got %d", params.PlayerLevel))
        }</span>

        // Validate timeout
        <span class="cov0" title="0">if params.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                result.AddWarning("timeout not specified or invalid, generation may run indefinitely")
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateTerrainParams validates terrain-specific parameters
func (v *Validator) ValidateTerrainParams(params TerrainParams) *ValidationResult <span class="cov0" title="0">{
        result := v.ValidateGenerationParams(params.GenerationParams)

        // Validate biome type
        validBiomes := []BiomeType{
                BiomeForest, BiomeMountain, BiomeDesert, BiomeSwamp,
                BiomeCave, BiomeDungeon, BiomeCoastal, BiomeUrban, BiomeWasteland,
        }

        valid := false
        for _, validBiome := range validBiomes </span><span class="cov0" title="0">{
                if params.BiomeType == validBiome </span><span class="cov0" title="0">{
                        valid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid biome type: %s", params.BiomeType))
        }</span>

        // Validate density
        <span class="cov0" title="0">if params.Density &lt; 0.0 || params.Density &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("density must be between 0.0 and 1.0, got %f", params.Density))
        }</span>

        // Validate water level
        <span class="cov0" title="0">if params.WaterLevel &lt; 0.0 || params.WaterLevel &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("water level must be between 0.0 and 1.0, got %f", params.WaterLevel))
        }</span>

        // Validate roughness
        <span class="cov0" title="0">if params.Roughness &lt; 0.0 || params.Roughness &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("roughness must be between 0.0 and 1.0, got %f", params.Roughness))
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateItemParams validates item-specific parameters
func (v *Validator) ValidateItemParams(params ItemParams) *ValidationResult <span class="cov0" title="0">{
        result := v.ValidateGenerationParams(params.GenerationParams)

        // Validate rarity tiers
        validRarities := []RarityTier{
                RarityCommon, RarityUncommon, RarityRare,
                RarityEpic, RarityLegendary, RarityArtifact,
        }

        // Check minimum rarity
        minValid := false
        for _, validRarity := range validRarities </span><span class="cov0" title="0">{
                if params.MinRarity == validRarity </span><span class="cov0" title="0">{
                        minValid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !minValid </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid minimum rarity: %s", params.MinRarity))
        }</span>

        // Check maximum rarity
        <span class="cov0" title="0">maxValid := false
        for _, validRarity := range validRarities </span><span class="cov0" title="0">{
                if params.MaxRarity == validRarity </span><span class="cov0" title="0">{
                        maxValid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !maxValid </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid maximum rarity: %s", params.MaxRarity))
        }</span>

        // Validate enchantment rate
        <span class="cov0" title="0">if params.EnchantmentRate &lt; 0.0 || params.EnchantmentRate &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("enchantment rate must be between 0.0 and 1.0, got %f", params.EnchantmentRate))
        }</span>

        // Validate unique chance
        <span class="cov0" title="0">if params.UniqueChance &lt; 0.0 || params.UniqueChance &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("unique chance must be between 0.0 and 1.0, got %f", params.UniqueChance))
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateLevelParams validates level-specific parameters
func (v *Validator) ValidateLevelParams(params LevelParams) *ValidationResult <span class="cov0" title="0">{
        result := v.ValidateGenerationParams(params.GenerationParams)

        // Validate room counts
        if params.MinRooms &lt; 1 </span><span class="cov0" title="0">{
                result.AddError("minimum rooms must be at least 1")
        }</span>

        <span class="cov0" title="0">if params.MaxRooms &lt; params.MinRooms </span><span class="cov0" title="0">{
                result.AddError("maximum rooms must be greater than or equal to minimum rooms")
        }</span>

        <span class="cov0" title="0">if params.MaxRooms &gt; 100 </span><span class="cov0" title="0">{
                result.AddWarning("maximum rooms is very high, generation may be slow")
        }</span>

        // Validate secret rooms
        <span class="cov0" title="0">if params.SecretRooms &lt; 0 </span><span class="cov0" title="0">{
                result.AddError("secret rooms cannot be negative")
        }</span>

        <span class="cov0" title="0">if params.SecretRooms &gt; params.MaxRooms/2 </span><span class="cov0" title="0">{
                result.AddWarning("high number of secret rooms relative to total rooms")
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateGameMap validates a generated game map
func (v *Validator) ValidateGameMap(gameMap *game.GameMap) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        if gameMap == nil </span><span class="cov0" title="0">{
                result.AddError("game map is nil")
                return result
        }</span>

        // Validate dimensions
        <span class="cov0" title="0">if gameMap.Width &lt;= 0 || gameMap.Height &lt;= 0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid map dimensions: %dx%d", gameMap.Width, gameMap.Height))
        }</span>

        // Validate tiles array
        <span class="cov0" title="0">if len(gameMap.Tiles) != gameMap.Height </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("tiles array height mismatch: expected %d, got %d", gameMap.Height, len(gameMap.Tiles)))
        }</span>

        <span class="cov0" title="0">for y, row := range gameMap.Tiles </span><span class="cov0" title="0">{
                if len(row) != gameMap.Width </span><span class="cov0" title="0">{
                        result.AddError(fmt.Sprintf("tiles array width mismatch at row %d: expected %d, got %d", y, gameMap.Width, len(row)))
                }</span>
        }

        // Check for walkable path connectivity if in strict mode
        <span class="cov0" title="0">if v.strictMode </span><span class="cov0" title="0">{
                if !v.validateMapConnectivity(gameMap) </span><span class="cov0" title="0">{
                        result.AddError("map lacks proper connectivity between walkable areas")
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ValidateItem validates a generated item
func (v *Validator) ValidateItem(item *game.Item) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        if item == nil </span><span class="cov0" title="0">{
                result.AddError("item is nil")
                return result
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if strings.TrimSpace(item.ID) == "" </span><span class="cov0" title="0">{
                result.AddError("item ID cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(item.Name) == "" </span><span class="cov0" title="0">{
                result.AddError("item name cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(item.Type) == "" </span><span class="cov0" title="0">{
                result.AddError("item type cannot be empty")
        }</span>

        // Validate value
        <span class="cov0" title="0">if item.Value &lt; 0 </span><span class="cov0" title="0">{
                result.AddError("item value cannot be negative")
        }</span>

        // Validate weight
        <span class="cov0" title="0">if item.Weight &lt; 0 </span><span class="cov0" title="0">{
                result.AddError("item weight cannot be negative")
        }</span>

        // Validate armor class for armor items
        <span class="cov0" title="0">if item.Type == "armor" &amp;&amp; item.AC &lt;= 0 </span><span class="cov0" title="0">{
                result.AddWarning("armor item has zero or negative AC")
        }</span>

        // Validate damage for weapon items
        <span class="cov0" title="0">if item.Type == "weapon" &amp;&amp; strings.TrimSpace(item.Damage) == "" </span><span class="cov0" title="0">{
                result.AddWarning("weapon item has no damage specification")
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateLevel validates a generated level
func (v *Validator) ValidateLevel(level *game.Level) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        if level == nil </span><span class="cov0" title="0">{
                result.AddError("level is nil")
                return result
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if strings.TrimSpace(level.ID) == "" </span><span class="cov0" title="0">{
                result.AddError("level ID cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(level.Name) == "" </span><span class="cov0" title="0">{
                result.AddError("level name cannot be empty")
        }</span>

        // Validate dimensions
        <span class="cov0" title="0">if level.Width &lt;= 0 || level.Height &lt;= 0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid level dimensions: %dx%d", level.Width, level.Height))
        }</span>

        // Validate tiles array
        <span class="cov0" title="0">if len(level.Tiles) != level.Height </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("tiles array height mismatch: expected %d, got %d", level.Height, len(level.Tiles)))
        }</span>

        <span class="cov0" title="0">for y, row := range level.Tiles </span><span class="cov0" title="0">{
                if len(row) != level.Width </span><span class="cov0" title="0">{
                        result.AddError(fmt.Sprintf("tiles array width mismatch at row %d: expected %d, got %d", y, level.Width, len(row)))
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ValidateQuest validates a generated quest
func (v *Validator) ValidateQuest(quest *game.Quest) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        if quest == nil </span><span class="cov0" title="0">{
                result.AddError("quest is nil")
                return result
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if strings.TrimSpace(quest.ID) == "" </span><span class="cov0" title="0">{
                result.AddError("quest ID cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(quest.Title) == "" </span><span class="cov0" title="0">{
                result.AddError("quest title cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(quest.Description) == "" </span><span class="cov0" title="0">{
                result.AddError("quest description cannot be empty")
        }</span>

        // Validate status
        <span class="cov0" title="0">validStatuses := []game.QuestStatus{
                game.QuestNotStarted, game.QuestActive,
                game.QuestCompleted, game.QuestFailed,
        }

        statusValid := false
        for _, validStatus := range validStatuses </span><span class="cov0" title="0">{
                if quest.Status == validStatus </span><span class="cov0" title="0">{
                        statusValid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !statusValid </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid quest status: %v", quest.Status))
        }</span>

        // Validate objectives (at least one objective should be present)
        <span class="cov0" title="0">if len(quest.Objectives) == 0 </span><span class="cov0" title="0">{
                result.AddWarning("quest has no objectives")
        }</span>

        // Validate rewards (at least one reward is recommended)
        <span class="cov0" title="0">if len(quest.Rewards) == 0 </span><span class="cov0" title="0">{
                result.AddWarning("quest has no rewards")
        }</span>

        <span class="cov0" title="0">return result</span>
}

// validateMapConnectivity checks if walkable areas in the map are properly connected
func (v *Validator) validateMapConnectivity(gameMap *game.GameMap) bool <span class="cov0" title="0">{
        if !v.isValidMapDimensions(gameMap) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">walkableTiles := v.findWalkableTiles(gameMap)
        if len(walkableTiles) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">reachableCount := v.performConnectivityFloodFill(gameMap, walkableTiles[0])
        return reachableCount == len(walkableTiles)</span>
}

// isValidMapDimensions checks if the game map has valid dimensions
func (v *Validator) isValidMapDimensions(gameMap *game.GameMap) bool <span class="cov0" title="0">{
        return gameMap.Width &gt; 0 &amp;&amp; gameMap.Height &gt; 0
}</span>

// findWalkableTiles discovers all walkable positions in the game map
func (v *Validator) findWalkableTiles(gameMap *game.GameMap) []game.Position <span class="cov0" title="0">{
        walkableTiles := make([]game.Position, 0)
        for y := 0; y &lt; gameMap.Height; y++ </span><span class="cov0" title="0">{
                for x := 0; x &lt; gameMap.Width; x++ </span><span class="cov0" title="0">{
                        if gameMap.Tiles[y][x].Walkable </span><span class="cov0" title="0">{
                                walkableTiles = append(walkableTiles, game.Position{X: x, Y: y})
                        }</span>
                }
        }
        <span class="cov0" title="0">return walkableTiles</span>
}

// performConnectivityFloodFill uses flood fill algorithm to count reachable walkable tiles
func (v *Validator) performConnectivityFloodFill(gameMap *game.GameMap, startPos game.Position) int <span class="cov0" title="0">{
        visited := make(map[game.Position]bool)
        queue := []game.Position{startPos}
        visited[startPos] = true
        reachableCount := 1

        directions := v.getCardinalDirections()

        for len(queue) &gt; 0 </span><span class="cov0" title="0">{
                current := queue[0]
                queue = queue[1:]

                adjacentPositions := v.getAdjacentWalkablePositions(gameMap, current, directions, visited)
                for _, pos := range adjacentPositions </span><span class="cov0" title="0">{
                        visited[pos] = true
                        queue = append(queue, pos)
                        reachableCount++
                }</span>
        }

        <span class="cov0" title="0">return reachableCount</span>
}

// getCardinalDirections returns the four cardinal movement directions
func (v *Validator) getCardinalDirections() []game.Position <span class="cov0" title="0">{
        return []game.Position{
                {X: 0, Y: -1}, // North
                {X: 1, Y: 0},  // East
                {X: 0, Y: 1},  // South
                {X: -1, Y: 0}, // West
        }
}</span>

// getAdjacentWalkablePositions finds all unvisited walkable positions adjacent to current position
func (v *Validator) getAdjacentWalkablePositions(gameMap *game.GameMap, current game.Position, directions []game.Position, visited map[game.Position]bool) []game.Position <span class="cov0" title="0">{
        var adjacent []game.Position

        for _, dir := range directions </span><span class="cov0" title="0">{
                next := game.Position{
                        X: current.X + dir.X,
                        Y: current.Y + dir.Y,
                }

                if v.isValidPosition(gameMap, next) &amp;&amp; !visited[next] &amp;&amp; gameMap.Tiles[next.Y][next.X].Walkable </span><span class="cov0" title="0">{
                        adjacent = append(adjacent, next)
                }</span>
        }

        <span class="cov0" title="0">return adjacent</span>
}

// isValidPosition checks if a position is within the map boundaries
func (v *Validator) isValidPosition(gameMap *game.GameMap, pos game.Position) bool <span class="cov0" title="0">{
        return pos.X &gt;= 0 &amp;&amp; pos.X &lt; gameMap.Width &amp;&amp; pos.Y &gt;= 0 &amp;&amp; pos.Y &lt; gameMap.Height
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">// Package server implements the game server and combat system functionality
package server

import (
        "fmt"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// DefaultTurnDuration defines the default time limit for combat turns.
// Players have this amount of time to complete their actions before the turn automatically ends.
var DefaultTurnDuration = 10 * time.Second

// CombatState represents the current state of an active combat encounter.
// It tracks all participating entities, combat progression, and environmental effects.
//
// Fields:
//   - ActiveCombatants: IDs of all entities currently participating in combat
//   - RoundCount: Current combat round number (increments each full initiative cycle)
//   - CombatZone: Center position defining the combat area boundaries
//   - StatusEffects: Map of entity IDs to their currently active effects
//
// Combat lifecycle:
// 1. Combat starts with participants entering initiative order
// 2. Round counter tracks combat progression
// 3. Status effects are managed per-entity
// 4. Combat zone defines spatial boundaries for the encounter
type CombatState struct {
        // ActiveCombatants contains the IDs of all entities currently in combat
        ActiveCombatants []string `yaml:"combat_active_entities"`
        // RoundCount tracks the current combat round number
        RoundCount int `yaml:"combat_round_count"`
        // CombatZone defines the center position of the combat area
        CombatZone game.Position `yaml:"combat_zone_center"`
        // StatusEffects maps entity IDs to their active effects
        StatusEffects map[string][]game.Effect `yaml:"combat_status_effects"`
}

// TurnManager handles combat turn sequencing and initiative tracking.
// It manages the flow of combat rounds, turn timeouts, and coordinated group actions.
//
// Core responsibilities:
// - Initiative order management and turn progression
// - Combat round tracking and state transitions
// - Turn timer enforcement with configurable durations
// - Allied group coordination for team-based combat
// - Delayed action scheduling and execution
//
// Fields:
//   - CurrentRound: Current combat round number
//   - Initiative: Ordered list of entity IDs by initiative roll
//   - CurrentIndex: Position in initiative order (whose turn it is)
//   - IsInCombat: Flag indicating active combat state
//   - CombatGroups: Maps entity IDs to their allied group members
//   - DelayedActions: Queue of actions scheduled for future execution
//   - turnTimer: Internal timer for enforcing turn time limits
//   - turnDuration: Configurable duration for each turn
type TurnManager struct {
        // CurrentRound represents the current combat round number
        CurrentRound int `yaml:"turn_current_round"`
        // Initiative holds entity IDs in their initiative order
        Initiative []string `yaml:"turn_initiative_order"`
        // CurrentIndex tracks the current actor's position in the initiative order
        CurrentIndex int `yaml:"turn_current_index"`
        // IsInCombat indicates whether combat is currently active
        IsInCombat bool `yaml:"turn_in_combat"`
        // CombatGroups maps entity IDs to their allied group members
        CombatGroups map[string][]string `yaml:"turn_combat_groups"`
        // DelayedActions holds actions to be executed at a later time
        DelayedActions []DelayedAction `yaml:"turn_delayed_actions"`
        turnTimer      *time.Timer     // Timer for turn timeouts
        turnDuration   time.Duration   // Duration for turn timeouts
}

// NewTurnManager creates and initializes a new TurnManager instance.
// It sets up the turn management system with default values and empty state.
//
// Returns:
//   - *TurnManager: Fully initialized turn manager ready for combat
//
// Initial state:
// - CurrentRound: 0 (no combat started)
// - Initiative: Empty slice (no participants)
// - CurrentIndex: 0 (first position)
// - IsInCombat: false (not in combat)
// - Empty combat groups and delayed actions
// - Default turn duration configuration
func NewTurnManager() *TurnManager <span class="cov8" title="1">{
        return &amp;TurnManager{
                CurrentRound:   0,
                Initiative:     []string{},
                CurrentIndex:   0,
                IsInCombat:     false,
                CombatGroups:   make(map[string][]string),
                DelayedActions: make([]DelayedAction, 0),
                turnTimer:      nil, // Initialize as nil, will be set when combat starts
                turnDuration:   DefaultTurnDuration,
        }
}</span>

// Update applies the provided updates to the TurnManager.
//
// Parameters:
//   - turnUpdates: Map of field names to their new values
//
// Returns:
//   - any: Updated TurnManager instance
func (tm *TurnManager) Update(turnUpdates map[string]interface{}) error <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "Update",
        }).Debug("updating turn manager state")

        // Update fields if present in updates map
        if round, ok := turnUpdates["current_round"].(int); ok </span><span class="cov0" title="0">{
                tm.CurrentRound = round
        }</span>

        <span class="cov0" title="0">if initiative, ok := turnUpdates["initiative_order"].([]string); ok </span><span class="cov0" title="0">{
                // Always validate initiative order to prevent corruption
                if err := tm.validateInitiativeOrder(initiative); err != nil </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "function": "Update",
                                "error":    err.Error(),
                        }).Error("invalid initiative order in update")
                        return fmt.Errorf("failed to update initiative: %w", err)
                }</span>
                <span class="cov0" title="0">tm.Initiative = initiative</span>
        }

        <span class="cov0" title="0">if index, ok := turnUpdates["current_index"].(int); ok </span><span class="cov0" title="0">{
                tm.CurrentIndex = index
        }</span>

        <span class="cov0" title="0">if inCombat, ok := turnUpdates["in_combat"].(bool); ok </span><span class="cov0" title="0">{
                tm.IsInCombat = inCombat
        }</span>

        <span class="cov0" title="0">if groups, ok := turnUpdates["combat_groups"].(map[string][]string); ok </span><span class="cov0" title="0">{
                tm.CombatGroups = groups
        }</span>

        <span class="cov0" title="0">if actions, ok := turnUpdates["delayed_actions"].([]DelayedAction); ok </span><span class="cov0" title="0">{
                tm.DelayedActions = actions
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "Update",
        }).Debug("turn manager state updated")

        return nil</span>
}

// Clone creates and returns a deep copy of the TurnManager
func (tm *TurnManager) Clone() *TurnManager <span class="cov0" title="0">{
        // Create new TurnManager
        clone := &amp;TurnManager{
                CurrentRound:   tm.CurrentRound,
                CurrentIndex:   tm.CurrentIndex,
                IsInCombat:     tm.IsInCombat,
                Initiative:     make([]string, len(tm.Initiative)),
                CombatGroups:   make(map[string][]string),
                DelayedActions: make([]DelayedAction, len(tm.DelayedActions)),
        }

        // Copy initiative slice
        copy(clone.Initiative, tm.Initiative)

        // Deep copy combat groups map
        for k, v := range tm.CombatGroups </span><span class="cov0" title="0">{
                groupCopy := make([]string, len(v))
                copy(groupCopy, v)
                clone.CombatGroups[k] = groupCopy
        }</span>

        // Copy delayed actions
        <span class="cov0" title="0">copy(clone.DelayedActions, tm.DelayedActions)

        return clone</span>
}

// Serialize returns a map representation of the TurnManager state.
func (tm *TurnManager) Serialize() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "current_round":    tm.CurrentRound,
                "initiative_order": tm.Initiative,
                "current_index":    tm.CurrentIndex,
                "in_combat":        tm.IsInCombat,
                "combat_groups":    tm.CombatGroups,
                "delayed_actions":  tm.DelayedActions,
        }
}</span>

// DelayedAction represents a combat action scheduled for future execution.
// It enables complex combat mechanics like spell casting times and triggered abilities.
//
// Use cases:
// - Spell casting with casting times (e.g., 3-second fireball)
// - Triggered abilities that activate later
// - Environmental effects with delays
// - Coordinated group actions
//
// Fields:
//   - ActorID: Entity performing the action
//   - ActionType: Type of action (spell, attack, movement, etc.)
//   - Target: Position where action takes effect
//   - TriggerTime: Game time when action should execute
//   - Parameters: Additional action-specific data
//
// The action queue processes DelayedActions when their TriggerTime is reached.
type DelayedAction struct {
        // ActorID is the ID of the entity performing the action
        ActorID string `yaml:"action_actor_id"`
        // ActionType defines the type of action to be performed
        ActionType string `yaml:"action_type"`
        // Target specifies the position where the action will take effect
        Target game.Position `yaml:"action_target_pos"`
        // TriggerTime determines when the action should be executed
        TriggerTime game.GameTime `yaml:"action_trigger_time"`
        // Parameters contains additional data needed for the action
        Parameters []string `yaml:"action_parameters"`
}

// IsCurrentTurn checks if the given entity is the current actor in combat.
//
// Parameters:
//   - entityID: The ID of the entity to check
//
// Returns:
//   - bool: true if it's the entity's turn, false otherwise
func (tm *TurnManager) IsCurrentTurn(entityID string) bool <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "IsCurrentTurn",
                "entityID": entityID,
        }).Debug("checking if entity has current turn")

        if !tm.IsInCombat || tm.CurrentIndex &gt;= len(tm.Initiative) </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":      "IsCurrentTurn",
                        "isInCombat":    tm.IsInCombat,
                        "currentIndex":  tm.CurrentIndex,
                        "initiativeLen": len(tm.Initiative),
                }).Debug("combat inactive or invalid index")
                return false
        }</span>

        <span class="cov8" title="1">isCurrent := tm.Initiative[tm.CurrentIndex] == entityID
        logrus.WithFields(logrus.Fields{
                "function":  "IsCurrentTurn",
                "entityID":  entityID,
                "isCurrent": isCurrent,
        }).Debug("turn check complete")

        return isCurrent</span>
}

// StartCombat initializes a new combat encounter with the given initiative order.
//
// Parameters:
//   - initiative: Ordered slice of entity IDs representing turn order
func (tm *TurnManager) StartCombat(initiative []string) error <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function":        "StartCombat",
                "initiativeCount": len(initiative),
        }).Debug("starting new combat")

        // Validate initiative order
        if err := tm.validateInitiativeOrder(initiative); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "StartCombat",
                        "error":    err.Error(),
                }).Error("invalid initiative order")
                return fmt.Errorf("failed to start combat: %w", err)
        }</span>

        <span class="cov8" title="1">tm.IsInCombat = true
        tm.Initiative = initiative
        tm.CurrentIndex = 0
        tm.CurrentRound = 1
        tm.startTurnTimer()

        logrus.WithFields(logrus.Fields{
                "function": "StartCombat",
                "round":    tm.CurrentRound,
        }).Info("combat started successfully")
        return nil</span>
}

func (tm *TurnManager) startTurnTimer() <span class="cov8" title="1">{
        if tm.turnTimer != nil </span><span class="cov0" title="0">{
                tm.turnTimer.Stop()
        }</span>
        <span class="cov8" title="1">tm.turnTimer = time.AfterFunc(tm.turnDuration, tm.endTurn)</span>
}

func (tm *TurnManager) endTurn() <span class="cov0" title="0">{
        // Check if initiative is valid before accessing it
        if len(tm.Initiative) == 0 || tm.CurrentIndex &gt;= len(tm.Initiative) </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":      "endTurn",
                        "currentIndex":  tm.CurrentIndex,
                        "initiativeLen": len(tm.Initiative),
                }).Error("invalid initiative state during endTurn")
                return
        }</span>

        <span class="cov0" title="0">currentActor := tm.Initiative[tm.CurrentIndex]

        // Check if actor took action
        actorHasAction := false
        for _, action := range tm.DelayedActions </span><span class="cov0" title="0">{
                if action.ActorID == currentActor </span><span class="cov0" title="0">{
                        actorHasAction = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !actorHasAction </span><span class="cov0" title="0">{
                if err := tm.moveToTopOfInitiative(currentActor); err != nil </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "function":     "endTurn",
                                "currentActor": currentActor,
                                "error":        err.Error(),
                        }).Error("failed to move actor to top of initiative")
                        // Continue without reordering if validation fails
                }</span>
        }

        // Process delayed actions
        <span class="cov0" title="0">tm.processDelayedActions()

        // Advance turn
        tm.CurrentIndex = (tm.CurrentIndex + 1) % len(tm.Initiative)
        if tm.CurrentIndex == 0 </span><span class="cov0" title="0">{
                tm.CurrentRound++
        }</span>

        <span class="cov0" title="0">if tm.IsInCombat </span><span class="cov0" title="0">{
                tm.startTurnTimer()
        }</span>
}

// AdvanceTurn moves to the next entity in the initiative order.
// Increments the round counter when returning to the first entity.
//
// Returns:
//   - string: The ID of the next entity in the initiative order, or empty string if not in combat
func (tm *TurnManager) AdvanceTurn() string <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function":   "AdvanceTurn",
                "isInCombat": tm.IsInCombat,
        }).Debug("checking combat state")

        if !tm.IsInCombat </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "AdvanceTurn",
                }).Debug("not in combat, returning")
                return ""
        }</span>

        // Check if initiative is valid before accessing it
        <span class="cov8" title="1">if len(tm.Initiative) == 0 </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "AdvanceTurn",
                }).Error("initiative is empty during AdvanceTurn")
                return ""
        }</span>

        // Ensure CurrentIndex is within bounds
        <span class="cov8" title="1">if tm.CurrentIndex &gt;= len(tm.Initiative) </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":      "AdvanceTurn",
                        "currentIndex":  tm.CurrentIndex,
                        "initiativeLen": len(tm.Initiative),
                }).Error("CurrentIndex out of bounds, resetting to 0")
                tm.CurrentIndex = 0
        }</span>

        <span class="cov8" title="1">prevIndex := tm.CurrentIndex
        tm.CurrentIndex = (tm.CurrentIndex + 1) % len(tm.Initiative)

        if tm.CurrentIndex == 0 </span><span class="cov0" title="0">{
                tm.CurrentRound++
                logrus.WithFields(logrus.Fields{
                        "function": "AdvanceTurn",
                        "round":    tm.CurrentRound,
                }).Info("new combat round started")
        }</span>

        <span class="cov8" title="1">nextEntity := tm.Initiative[tm.CurrentIndex]
        logrus.WithFields(logrus.Fields{
                "function":   "AdvanceTurn",
                "prevIndex":  prevIndex,
                "nextIndex":  tm.CurrentIndex,
                "nextEntity": nextEntity,
        }).Debug("turn advanced")

        return nextEntity</span>
}

// processDelayedActions checks and executes any delayed actions that are due.
// Removes executed actions from the pending actions list.
func (s *RPCServer) processDelayedActions() <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "processDelayedActions",
        }).Debug("processing delayed actions")

        currentTime := s.state.TimeManager.CurrentTime
        totalActions := len(s.state.TurnManager.DelayedActions)

        logrus.WithFields(logrus.Fields{
                "function":    "processDelayedActions",
                "currentTime": currentTime,
                "actionCount": totalActions,
        }).Debug("checking delayed actions")

        for i := totalActions - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                action := s.state.TurnManager.DelayedActions[i]

                logrus.WithFields(logrus.Fields{
                        "function":    "processDelayedActions",
                        "actionIndex": i,
                        "actorID":     action.ActorID,
                        "actionType":  action.ActionType,
                        "triggerTime": action.TriggerTime,
                }).Debug("checking action timing")

                if isTimeToExecute(currentTime, action.TriggerTime) </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "function":   "processDelayedActions",
                                "actorID":    action.ActorID,
                                "actionType": action.ActionType,
                        }).Info("executing delayed action")

                        s.executeDelayedAction(action)
                        s.state.TurnManager.DelayedActions = append(
                                s.state.TurnManager.DelayedActions[:i],
                                s.state.TurnManager.DelayedActions[i+1:]...,
                        )
                }</span>
        }

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function":         "processDelayedActions",
                "remainingActions": len(s.state.TurnManager.DelayedActions),
        }).Debug("finished processing delayed actions")</span>
}

// checkCombatEnd determines if combat should end based on remaining hostile groups.
//
// Returns:
//   - bool: true if combat ended, false if it should continue
func (s *RPCServer) checkCombatEnd() bool <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function":   "checkCombatEnd",
                "isInCombat": s.state.TurnManager.IsInCombat,
        }).Debug("checking if combat should end")

        if !s.state.TurnManager.IsInCombat </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "checkCombatEnd",
                }).Debug("not in combat, returning")
                return false
        }</span>

        <span class="cov0" title="0">hostileGroups := s.getHostileGroups()
        logrus.WithFields(logrus.Fields{
                "function":          "checkCombatEnd",
                "hostileGroupCount": len(hostileGroups),
        }).Debug("got hostile groups")

        if len(hostileGroups) &lt;= 1 </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "checkCombatEnd",
                }).Info("ending combat - only one or no hostile groups remain")
                s.endCombat()
                return true
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "checkCombatEnd",
        }).Debug("combat continues")
        return false</span>
}

// executeDelayedAction handles the execution of a delayed combat action.
// Implementation depends on the specific action type.
//
// Parameters:
//   - action: The DelayedAction to execute
func (s *RPCServer) executeDelayedAction(action DelayedAction) {<span class="cov0" title="0">
        // Implement the logic to execute the delayed action here
}</span>

// getHostileGroups returns groups of allied entities in combat.
//
// Returns:
//   - [][]string: Slice of entity ID groups, where each group represents allied entities
func (s *RPCServer) getHostileGroups() [][]string <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "getHostileGroups",
        }).Debug("getting hostile groups")

        groups := make([][]string, 0)
        processed := make(map[string]bool)

        logrus.WithFields(logrus.Fields{
                "function":    "getHostileGroups",
                "groupsCount": len(s.state.TurnManager.CombatGroups),
        }).Debug("processing combat groups")

        for id := range s.state.TurnManager.CombatGroups </span><span class="cov0" title="0">{
                if !processed[id] </span><span class="cov0" title="0">{
                        group := s.state.TurnManager.CombatGroups[id]
                        groups = append(groups, group)
                        for _, memberID := range group </span><span class="cov0" title="0">{
                                processed[memberID] = true
                        }</span>

                        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                                "function":     "getHostileGroups",
                                "groupLeader":  id,
                                "membersCount": len(group),
                        }).Debug("processed group")</span>
                }
        }

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function":          "getHostileGroups",
                "hostileGroupCount": len(groups),
        }).Info("hostile groups identified")

        return groups</span>
}

// endCombat terminates the current combat encounter and emits a combat end event.
func (s *RPCServer) endCombat() <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "endCombat",
        }).Debug("ending combat")

        // Stop the turn timer if it's running
        if s.state.TurnManager.turnTimer != nil </span><span class="cov0" title="0">{
                s.state.TurnManager.turnTimer.Stop()
                s.state.TurnManager.turnTimer = nil
        }</span>

        <span class="cov0" title="0">s.state.TurnManager.IsInCombat = false
        s.state.TurnManager.Initiative = nil
        s.state.TurnManager.CurrentIndex = 0

        logrus.WithFields(logrus.Fields{
                "function": "endCombat",
                "rounds":   s.state.TurnManager.CurrentRound,
        }).Info("combat ended")

        s.eventSys.Emit(game.GameEvent{
                Type: EventCombatEnd,
                Data: map[string]interface{}{
                        "rounds_completed": s.state.TurnManager.CurrentRound,
                },
        })

        logrus.WithFields(logrus.Fields{
                "function": "endCombat",
        }).Debug("combat cleanup complete")</span>
}

// applyDamage applies damage to a game object, handling death if applicable.
//
// Parameters:
//   - target: The GameObject receiving damage
//   - damage: Amount of damage to apply
//
// Returns:
//   - error: Error if target cannot receive damage
func (s *RPCServer) applyDamage(target game.GameObject, damage int) error <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "applyDamage",
                "damage":   damage,
                "targetID": target.GetID(),
        }).Debug("applying damage to target")

        // Handle both Character and Player types
        var char *game.Character
        if player, ok := target.(*game.Player); ok </span><span class="cov8" title="1">{
                char = &amp;player.Character
        }</span> else<span class="cov0" title="0"> if character, ok := target.(*game.Character); ok </span><span class="cov0" title="0">{
                char = character
        }</span> else<span class="cov0" title="0"> {
                err := fmt.Errorf("target cannot receive damage")
                logrus.WithFields(logrus.Fields{
                        "function": "applyDamage",
                        "error":    err.Error(),
                }).Error("invalid target type")
                return err
        }</span>

        <span class="cov8" title="1">oldHP := char.HP
        char.HP -= damage

        if char.HP &lt; 0 </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "applyDamage",
                        "charID":   char.GetID(),
                }).Debug("clamping HP to 0")
                char.HP = 0
        }</span>

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function": "applyDamage",
                "charID":   char.GetID(),
                "oldHP":    oldHP,
                "newHP":    char.HP,
                "damage":   damage,
        }).Info("damage applied to character")

        if char.HP == 0 </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "applyDamage",
                        "charID":   char.GetID(),
                }).Info("character died from damage")
                s.handleCharacterDeath(char)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ADDED: calculateWeaponDamage computes total damage output for a weapon attack.
// It combines base weapon damage with attacker bonuses and modifiers.
//
// Damage calculation:
// 1. Base weapon damage (from weapon item properties)
// 2. Strength bonus for melee weapons
// 3. Dexterity bonus for ranged weapons
// 4. Weapon proficiency bonuses
// 5. Additional enchantments or effects
//
// Parameters:
//   - weapon: Weapon item being used (nil for unarmed attacks)
//   - attacker: Player character making the attack
//
// Returns:
//   - int: Total calculated damage value
//
// Special cases: Handles unarmed attacks when weapon is nil
func calculateWeaponDamage(weapon *game.Item, attacker *game.Player) int <span class="cov8" title="1">{
        // Handle nil weapon (unarmed attack)
        if weapon == nil </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function":   "calculateWeaponDamage",
                        "weaponID":   "unarmed",
                        "attackerID": attacker.GetID(),
                }).Debug("calculating unarmed damage")

                // Unarmed attack: 1 + Strength bonus
                strBonus := (attacker.Strength - 10) / 2
                unarmedDamage := 1 + strBonus
                if unarmedDamage &lt; 1 </span><span class="cov8" title="1">{
                        unarmedDamage = 1 // Minimum 1 damage
                }</span>

                <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                        "function":    "calculateWeaponDamage",
                        "baseDamage":  1,
                        "strBonus":    strBonus,
                        "totalDamage": unarmedDamage,
                }).Info("unarmed damage calculation completed")

                return unarmedDamage</span>
        }

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function":   "calculateWeaponDamage",
                "weaponID":   weapon.ID,
                "attackerID": attacker.GetID(),
        }).Debug("calculating weapon damage")

        baseDamage := parseDamageString(weapon.Damage)
        strBonus := (attacker.Strength - 10) / 2

        logrus.WithFields(logrus.Fields{
                "function":    "calculateWeaponDamage",
                "baseDamage":  baseDamage,
                "strBonus":    strBonus,
                "totalDamage": baseDamage + strBonus,
        }).Info("damage calculation completed")

        return baseDamage + strBonus</span>
}

// handleCharacterDeath processes a character's death, dropping inventory and emitting event.
//
// Parameters:
//   - character: The Character that died
func (s *RPCServer) handleCharacterDeath(character *game.Character) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function":    "handleCharacterDeath",
                "characterID": character.GetID(),
        }).Debug("handling character death")

        character.SetActive(false)
        dropPosition := character.GetPosition()

        logrus.WithFields(logrus.Fields{
                "function":     "handleCharacterDeath",
                "characterID":  character.GetID(),
                "dropPosition": dropPosition,
                "itemCount":    len(character.Inventory),
        }).Info("processing inventory drops")

        for _, item := range character.Inventory </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleCharacterDeath",
                        "itemID":   item.ID,
                }).Debug("dropping item")
                s.state.WorldState.AddObject(CreateItemDrop(item, character, dropPosition))
        }</span>
        <span class="cov0" title="0">character.Inventory = nil

        logrus.WithFields(logrus.Fields{
                "function":    "handleCharacterDeath",
                "characterID": character.GetID(),
        }).Info("emitting death event")

        s.eventSys.Emit(game.GameEvent{
                Type:     game.EventDeath,
                SourceID: character.GetID(),
                Data: map[string]interface{}{
                        "position": dropPosition,
                },
        })

        logrus.WithFields(logrus.Fields{
                "function": "handleCharacterDeath",
        }).Debug("character death handling complete")</span>
}

// CreateItemDrop creates a new item GameObject when an item is dropped from inventory.
// It handles the transition from inventory item to world object with proper positioning.
//
// Creation process:
// 1. Creates new GameObject wrapper around the item
// 2. Sets the drop position in the game world
// 3. Assigns unique identifier for world tracking
// 4. Configures item as interactive world object
//
// Parameters:
//   - item: The game.Item being dropped from inventory
//   - char: The character who is dropping the item
//   - dropPosition: World position where item should appear
//
// Returns:
//   - game.GameObject: New item object ready for world placement
//
// The returned object can be added to the world's object collection for player interaction.
func CreateItemDrop(item game.Item, char *game.Character, dropPosition game.Position) game.GameObject <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function":     "CreateItemDrop",
                "itemID":       item.ID,
                "characterID":  char.GetID(),
                "dropPosition": dropPosition,
        }).Debug("creating new item drop")

        droppedItem := &amp;game.Item{
                ID:         fmt.Sprintf("drop_%s_%s", item.ID, char.GetName()),
                Name:       item.Name,
                Type:       item.Type,
                Damage:     item.Damage,
                AC:         item.AC,
                Weight:     item.Weight,
                Value:      item.Value,
                Properties: item.Properties,
                Position:   dropPosition,
        }

        logrus.WithFields(logrus.Fields{
                "function":    "CreateItemDrop",
                "droppedID":   droppedItem.ID,
                "droppedName": droppedItem.Name,
        }).Info("item drop created")

        return droppedItem
}</span>

// processCombatAction handles weapon attacks during combat.
//
// Parameters:
//   - player: The attacking player
//   - targetID: ID of the attack target
//   - weaponID: ID of the weapon to use (optional)
//
// Returns:
//   - interface{}: Combat result containing success and damage
//   - error: Error if target is invalid or attack fails
func (s *RPCServer) processCombatAction(player *game.Player, targetID, weaponID string) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "processCombatAction",
                "playerID": player.GetID(),
                "targetID": targetID,
                "weaponID": weaponID,
        }).Debug("processing combat action")

        target, exists := s.state.WorldState.Objects[targetID]
        if !exists </span><span class="cov0" title="0">{
                err := fmt.Errorf("invalid target")
                logrus.WithFields(logrus.Fields{
                        "function": "processCombatAction",
                        "error":    err.Error(),
                }).Error("target not found")
                return nil, err
        }</span>

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function": "processCombatAction",
                "targetID": targetID,
        }).Debug("found valid target")

        var weapon *game.Item
        if weaponID != "" </span><span class="cov0" title="0">{
                weapon = findInventoryItem(player.Inventory, weaponID)
                if weapon == nil &amp;&amp; player.Equipment != nil </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "function": "processCombatAction",
                        }).Debug("checking equipped weapon")
                        w := player.Equipment[game.SlotHands]
                        weapon = &amp;w
                }</span>
        }

        <span class="cov8" title="1">damage := calculateWeaponDamage(weapon, player)
        logrus.WithFields(logrus.Fields{
                "function": "processCombatAction",
                "damage":   damage,
        }).Info("calculated weapon damage")

        if err := s.applyDamage(target, damage); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "processCombatAction",
                        "error":    err.Error(),
                }).Error("failed to apply damage")
                return nil, err
        }</span>

        <span class="cov8" title="1">result := map[string]interface{}{
                "success": true,
                "damage":  damage,
        }

        logrus.WithFields(logrus.Fields{
                "function": "processCombatAction",
                "damage":   damage,
        }).Debug("combat action completed successfully")

        return result, nil</span>
}

// QueueAction adds a delayed action to the turn manager's queue.
func (tm *TurnManager) QueueAction(action DelayedAction) error <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "QueueAction",
                "actorID":  action.ActorID,
        })

        if !tm.IsCurrentTurn(action.ActorID) </span><span class="cov0" title="0">{
                logger.Warn("attempt to queue action on wrong turn")
                return fmt.Errorf("not actor's turn")
        }</span>

        <span class="cov0" title="0">action.TriggerTime = game.GameTime{
                RealTime:  time.Now(),
                GameTicks: tm.getCurrentGameTicks(),
                TimeScale: 1.0,
        }

        logger.WithField("triggerTime", action.TriggerTime).Debug("queueing delayed action")
        tm.DelayedActions = append(tm.DelayedActions, action)
        return nil</span>
}

func (tm *TurnManager) moveToTopOfInitiative(entityID string) error <span class="cov0" title="0">{
        // Find group members
        group := append([]string{entityID}, tm.CombatGroups[entityID]...)

        // Create new initiative order
        newOrder := make([]string, 0, len(tm.Initiative))
        newOrder = append(newOrder, group...)

        for _, id := range tm.Initiative </span><span class="cov0" title="0">{
                inGroup := false
                for _, gid := range group </span><span class="cov0" title="0">{
                        if id == gid </span><span class="cov0" title="0">{
                                inGroup = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !inGroup </span><span class="cov0" title="0">{
                        newOrder = append(newOrder, id)
                }</span>
        }

        // Validate the new order before applying it
        <span class="cov0" title="0">if err := tm.validateInitiativeOrder(newOrder); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "moveToTopOfInitiative",
                        "entityID": entityID,
                        "error":    err.Error(),
                }).Error("failed to reorder initiative")
                return fmt.Errorf("initiative reorder failed: %w", err)
        }</span>

        <span class="cov0" title="0">tm.Initiative = newOrder
        tm.CurrentIndex = 0
        return nil</span>
}

func (tm *TurnManager) processDelayedActions() <span class="cov0" title="0">{
        currentTime := game.GameTime{
                RealTime:  time.Now(),
                GameTicks: tm.getCurrentGameTicks(),
        }

        remainingActions := make([]DelayedAction, 0)
        for _, action := range tm.DelayedActions </span><span class="cov0" title="0">{
                if currentTime.IsSameTurn(action.TriggerTime) </span><span class="cov0" title="0">{
                        logrus.WithField("action", action).Debug("processing delayed action")
                }</span> else<span class="cov0" title="0"> {
                        remainingActions = append(remainingActions, action)
                }</span>
        }
        <span class="cov0" title="0">tm.DelayedActions = remainingActions</span>
}

func (tm *TurnManager) getCurrentGameTicks() int64 <span class="cov0" title="0">{
        return int64(tm.CurrentRound*6+tm.CurrentIndex) * 10
}</span>

// EndCombat terminates the current combat encounter and cleans up timers.
func (tm *TurnManager) EndCombat() <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "EndCombat",
        }).Debug("ending combat via TurnManager")

        // Stop the turn timer if it's running
        if tm.turnTimer != nil </span><span class="cov8" title="1">{
                tm.turnTimer.Stop()
                tm.turnTimer = nil
        }</span>

        <span class="cov8" title="1">tm.IsInCombat = false
        tm.Initiative = nil
        tm.CurrentIndex = 0

        logrus.WithFields(logrus.Fields{
                "function": "EndCombat",
                "rounds":   tm.CurrentRound,
        }).Info("combat ended via TurnManager")</span>
}

// validateInitiativeOrder ensures the initiative slice contains valid entity IDs without duplicates.
//
// Parameters:
//   - initiative: The initiative order slice to validate
//
// Returns:
//   - error: Error if validation fails, nil if valid
func (tm *TurnManager) validateInitiativeOrder(initiative []string) error <span class="cov8" title="1">{
        if len(initiative) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("initiative order cannot be empty when starting combat")
        }</span>

        // Check for duplicate entity IDs
        <span class="cov8" title="1">seen := make(map[string]bool)
        for _, entityID := range initiative </span><span class="cov8" title="1">{
                if entityID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("initiative order contains empty entity ID")
                }</span>
                <span class="cov8" title="1">if seen[entityID] </span><span class="cov0" title="0">{
                        return fmt.Errorf("initiative order contains duplicate entity ID: %s", entityID)
                }</span>
                <span class="cov8" title="1">seen[entityID] = true</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package server

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "time"

        "goldbox-rpg/pkg/game"
        "goldbox-rpg/pkg/pcg"

        "github.com/google/uuid"
        "github.com/sirupsen/logrus"
)

// ErrInvalidSession is
var ErrInvalidSession = errors.New("invalid session")

// handleMove processes a player movement request in the game world.
//
// Parameters:
//   - params: json.RawMessage containing:
//   - session_id: string identifier for the player session
//   - direction: game.Direction enum indicating movement direction
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if move was successful
//   - position: Updated position coordinates
//   - error: Possible errors:
//   - "invalid movement parameters" if JSON unmarshaling fails
//   - "invalid session" if session ID not found
//   - Validation errors from WorldState.ValidateMove
//   - Position setting errors from Player.SetPosition
//
// Related:
//   - game.Direction
//   - game.GameEvent
//   - game.EventMovement
//   - RPCServer.sessions
//   - WorldState.ValidateMove
//   - Player.SetPosition
//   - Player.GetPosition
func (s *RPCServer) handleMove(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleMove",
        }).Debug("entering handleMove")

        req, err := s.parseMoveRequest(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">session, err := s.getSessionForMove(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer s.releaseSession(session)

        if err := s.validateCombatConstraints(session.Player); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">newPos, err := s.calculateAndValidateNewPosition(session.Player, req.Direction)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := s.consumeMovementActionPoints(session.Player); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := s.executePlayerMovement(session.Player, newPos); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function": "handleMove",
        }).Debug("exiting handleMove")

        return map[string]interface{}{
                "success":  true,
                "position": newPos,
        }, nil</span>
}

// parseMoveRequest extracts and validates movement request parameters from JSON.
func (s *RPCServer) parseMoveRequest(params json.RawMessage) (*struct {
        SessionID string         `json:"session_id"`
        Direction game.Direction `json:"direction"`
}, error) <span class="cov8" title="1">{
        var req struct {
                SessionID string         `json:"session_id"`
                Direction game.Direction `json:"direction"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "parseMoveRequest",
                        "error":    err.Error(),
                }).Error("failed to unmarshal movement parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid movement parameters", err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;req, nil</span>
}

// getSessionForMove retrieves and validates the player session for movement.
func (s *RPCServer) getSessionForMove(sessionID string) (*PlayerSession, error) <span class="cov8" title="1">{
        session, err := s.getSessionSafely(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":  "getSessionForMove",
                        "sessionID": sessionID,
                }).Warn("invalid session ID")
                return nil, fmt.Errorf("invalid session")
        }</span>
        <span class="cov8" title="1">return session, nil</span>
}

// validateCombatConstraints checks turn order and action point requirements during combat.
func (s *RPCServer) validateCombatConstraints(player *game.Player) error <span class="cov8" title="1">{
        if !s.state.TurnManager.IsInCombat </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">if !s.state.TurnManager.IsCurrentTurn(player.GetID()) </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "validateCombatConstraints",
                        "playerID": player.GetID(),
                }).Warn("player attempted to move when not their turn")
                return fmt.Errorf("not your turn")
        }</span>

        <span class="cov0" title="0">if player.GetActionPoints() &lt; game.ActionCostMove </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":   "validateCombatConstraints",
                        "playerID":   player.GetID(),
                        "currentAP":  player.GetActionPoints(),
                        "requiredAP": game.ActionCostMove,
                }).Warn("player attempted to move without enough action points")
                return fmt.Errorf("insufficient action points for movement (need %d, have %d)",
                        game.ActionCostMove, player.GetActionPoints())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// calculateAndValidateNewPosition computes the target position and validates the move.
func (s *RPCServer) calculateAndValidateNewPosition(player *game.Player, direction game.Direction) (game.Position, error) <span class="cov8" title="1">{
        currentPos := player.GetPosition()
        newPos := calculateNewPosition(currentPos, direction, s.state.WorldState.Width, s.state.WorldState.Height)

        logrus.WithFields(logrus.Fields{
                "function": "calculateAndValidateNewPosition",
                "playerID": player.GetID(),
                "from":     currentPos,
                "to":       newPos,
        }).Info("validating player move")

        if err := s.state.WorldState.ValidateMove(player, newPos); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "calculateAndValidateNewPosition",
                        "error":    err.Error(),
                }).Error("move validation failed")
                return game.Position{}, err
        }</span>

        <span class="cov8" title="1">return newPos, nil</span>
}

// consumeMovementActionPoints deducts action points for movement during combat.
func (s *RPCServer) consumeMovementActionPoints(player *game.Player) error <span class="cov8" title="1">{
        if !s.state.TurnManager.IsInCombat </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">if !player.ConsumeActionPoints(game.ActionCostMove) </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "consumeMovementActionPoints",
                        "playerID": player.GetID(),
                }).Error("failed to consume action points before movement")
                return fmt.Errorf("action point consumption failed")
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function":    "consumeMovementActionPoints",
                "playerID":    player.GetID(),
                "consumedAP":  game.ActionCostMove,
                "remainingAP": player.GetActionPoints(),
        }).Info("consumed action points for movement")

        return nil</span>
}

// executePlayerMovement updates player position and emits movement event.
func (s *RPCServer) executePlayerMovement(player *game.Player, newPos game.Position) error <span class="cov8" title="1">{
        currentPos := player.GetPosition()

        if err := player.SetPosition(newPos); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "executePlayerMovement",
                        "error":    err.Error(),
                }).Error("failed to set player position")
                return err
        }</span>

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function": "executePlayerMovement",
                "playerID": player.GetID(),
        }).Info("emitting movement event")

        s.eventSys.Emit(game.GameEvent{
                Type:     game.EventMovement,
                SourceID: player.GetID(),
                Data: map[string]interface{}{
                        "old_position": currentPos,
                        "new_position": newPos,
                },
        })

        return nil</span>
}

// handleAttack processes an attack action during combat in the RPG game.
//
// Parameters:
//   - params: json.RawMessage containing the attack request with:
//   - session_id: string identifier for the player session
//   - target_id: string identifier for the attack target
//   - weapon_id: string identifier for the weapon being used
//
// Returns:
//   - interface{}: The result of the combat action if successful
//   - error: Error if the attack is invalid due to:
//   - Invalid JSON parameters
//   - Invalid session
//   - Not being in combat
//   - Not being the player's turn
//   - Combat action processing errors
//
// Related:
//   - TurnManager.IsInCombat
//   - TurnManager.IsCurrentTurn
//   - processCombatAction
func (s *RPCServer) handleAttack(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleAttack",
        }).Debug("entering handleAttack")

        var req struct {
                SessionID string `json:"session_id"`
                TargetID  string `json:"target_id"`
                WeaponID  string `json:"weapon_id"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleAttack",
                        "error":    err.Error(),
                }).Error("failed to unmarshal attack parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid attack parameters", err.Error())
        }</span>

        <span class="cov8" title="1">session, err := s.getSessionSafely(req.SessionID)
        if err != nil </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function":  "handleAttack",
                        "sessionID": req.SessionID,
                }).Warn("invalid session ID")
                return nil, fmt.Errorf("invalid session")
        }</span>
        <span class="cov8" title="1">defer s.releaseSession(session) // Ensure session is released when handler completes

        if !s.state.TurnManager.IsInCombat </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleAttack",
                }).Warn("attempted attack while not in combat")
                return nil, fmt.Errorf("not in combat")
        }</span>

        <span class="cov8" title="1">if !s.state.TurnManager.IsCurrentTurn(session.Player.GetID()) </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleAttack",
                        "playerID": session.Player.GetID(),
                }).Warn("player attempted attack when not their turn")
                return nil, fmt.Errorf("not your turn")
        }</span>

        // Check if player has enough action points for attack
        <span class="cov8" title="1">if session.Player.GetActionPoints() &lt; game.ActionCostAttack </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function":   "handleAttack",
                        "playerID":   session.Player.GetID(),
                        "currentAP":  session.Player.GetActionPoints(),
                        "requiredAP": game.ActionCostAttack,
                }).Warn("player attempted to attack without enough action points")
                return nil, fmt.Errorf("insufficient action points for attack (need %d, have %d)",
                        game.ActionCostAttack, session.Player.GetActionPoints())
        }</span>

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function": "handleAttack",
                "playerID": session.Player.GetID(),
                "targetID": req.TargetID,
                "weaponID": req.WeaponID,
        }).Info("processing combat action")

        result, err := s.processCombatAction(session.Player, req.TargetID, req.WeaponID)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleAttack",
                        "error":    err.Error(),
                }).Error("combat action failed")
                return nil, err
        }</span>

        // Consume action points after successful attack
        <span class="cov8" title="1">if !session.Player.ConsumeActionPoints(game.ActionCostAttack) </span><span class="cov0" title="0">{
                // This should not happen due to earlier validation, but safety check
                logrus.WithFields(logrus.Fields{
                        "function": "handleAttack",
                        "playerID": session.Player.GetID(),
                }).Error("failed to consume action points after attack validation")
                return nil, fmt.Errorf("action point consumption failed")
        }</span>
        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function":    "handleAttack",
                "playerID":    session.Player.GetID(),
                "consumedAP":  game.ActionCostAttack,
                "remainingAP": session.Player.GetActionPoints(),
        }).Info("consumed action points for attack")

        logrus.WithFields(logrus.Fields{
                "function": "handleAttack",
        }).Debug("exiting handleAttack")

        return result, nil</span>
}

// handleCastSpell processes a spell casting request from a client.
// It validates the spell parameters, checks if the spell exists in player's known spells,
// and executes the spell casting logic.
//
// Parameters:
//   - params: Raw JSON message containing:
//   - session_id: Unique identifier for the player session
//   - spell_id: Identifier of the spell to cast
//   - target_id: ID of the target entity (if applicable)
//   - position: Target position for area spells (optional)
//
// Returns:
//   - interface{}: Result of the spell cast operation
//   - error: Error if:
//   - Invalid JSON parameters
//   - Invalid session ID
//   - Spell not found in player's known spells
//   - Spell casting fails (via processSpellCast)
//
// Related:
//   - processSpellCast: Handles the actual spell casting logic
//   - findSpell: Searches for a spell in player's known spells
func (s *RPCServer) handleCastSpell(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleCastSpell",
        }).Debug("entering handleCastSpell")

        req, err := s.parseCastSpellRequest(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">session, err := s.validateSpellCastSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer s.releaseSession(session)

        if err := s.validateCombatConstraintsForSpell(session.Player); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">spell, err := s.validatePlayerSpellKnowledge(session.Player, req.SpellID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result, err := s.executeSpellCast(session.Player, spell, req.TargetID, req.Position)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.consumeSpellCastActionPoints(session.Player); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "handleCastSpell",
        }).Debug("exiting handleCastSpell")

        return result, nil</span>
}

// parseCastSpellRequest extracts and validates spell casting parameters from JSON.
func (s *RPCServer) parseCastSpellRequest(params json.RawMessage) (*struct {
        SessionID string        `json:"session_id"`
        SpellID   string        `json:"spell_id"`
        TargetID  string        `json:"target_id"`
        Position  game.Position `json:"position,omitempty"`
}, error) <span class="cov8" title="1">{
        var req struct {
                SessionID string        `json:"session_id"`
                SpellID   string        `json:"spell_id"`
                TargetID  string        `json:"target_id"`
                Position  game.Position `json:"position,omitempty"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "parseCastSpellRequest",
                        "error":    err.Error(),
                }).Error("failed to unmarshal spell parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid spell parameters", err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;req, nil</span>
}

// validateSpellCastSession retrieves and validates the player session for spell casting.
func (s *RPCServer) validateSpellCastSession(sessionID string) (*PlayerSession, error) <span class="cov8" title="1">{
        session, err := s.getSessionSafely(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":  "validateSpellCastSession",
                        "sessionID": sessionID,
                }).Warn("invalid session ID")
                return nil, fmt.Errorf("invalid session")
        }</span>
        <span class="cov8" title="1">return session, nil</span>
}

// validateCombatConstraintsForSpell checks combat turn order and action points for spell casting.
func (s *RPCServer) validateCombatConstraintsForSpell(player *game.Player) error <span class="cov8" title="1">{
        // Check if currently in combat (spells can also be cast outside combat)
        if !s.state.TurnManager.IsInCombat </span><span class="cov0" title="0">{
                return nil // No combat constraints when not in combat
        }</span>

        // If in combat, validate turn order
        <span class="cov8" title="1">if !s.state.TurnManager.IsCurrentTurn(player.GetID()) </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function": "validateCombatConstraintsForSpell",
                        "playerID": player.GetID(),
                }).Warn("player attempted to cast spell when not their turn")
                return fmt.Errorf("not your turn")
        }</span>

        // Check if player has enough action points for spell casting
        <span class="cov8" title="1">if player.GetActionPoints() &lt; game.ActionCostSpell </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":   "validateCombatConstraintsForSpell",
                        "playerID":   player.GetID(),
                        "currentAP":  player.GetActionPoints(),
                        "requiredAP": game.ActionCostSpell,
                }).Warn("player attempted to cast spell without enough action points")
                return fmt.Errorf("insufficient action points for spell casting (need %d, have %d)",
                        game.ActionCostSpell, player.GetActionPoints())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validatePlayerSpellKnowledge checks if the player knows the requested spell.
func (s *RPCServer) validatePlayerSpellKnowledge(player *game.Player, spellID string) (*game.Spell, error) <span class="cov8" title="1">{
        spell, err := s.spellManager.GetSpell(spellID)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "validatePlayerSpellKnowledge",
                        "spellID":  spellID,
                        "playerID": player.GetID(),
                }).Warn("spell not found in spell database")
                return nil, fmt.Errorf("spell not found: %s", spellID)
        }</span>

        // Check if player knows this spell
        <span class="cov8" title="1">if !player.KnowsSpell(spellID) </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function": "validatePlayerSpellKnowledge",
                        "playerID": player.GetID(),
                        "spellID":  spellID,
                }).Warn("player does not know this spell")
                return nil, fmt.Errorf("you do not know this spell: %s", spell.Name)
        }</span>

        <span class="cov0" title="0">return spell, nil</span>
}

// executeSpellCast performs the actual spell casting operation.
func (s *RPCServer) executeSpellCast(player *game.Player, spell *game.Spell, targetID string, position game.Position) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "executeSpellCast",
                "spellID":  spell.ID,
                "targetID": targetID,
                "playerID": player.GetID(),
        }).Info("attempting to cast spell")

        result, err := s.processSpellCast(player, spell, targetID, position)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "executeSpellCast",
                        "error":    err.Error(),
                        "spellID":  spell.ID,
                }).Error("spell cast failed")
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// consumeSpellCastActionPoints deducts action points after successful spell casting.
func (s *RPCServer) consumeSpellCastActionPoints(player *game.Player) error <span class="cov0" title="0">{
        // Consume action points if in combat
        if !s.state.TurnManager.IsInCombat </span><span class="cov0" title="0">{
                return nil // No action point consumption when not in combat
        }</span>

        <span class="cov0" title="0">if !player.ConsumeActionPoints(game.ActionCostSpell) </span><span class="cov0" title="0">{
                // This should not happen due to earlier validation, but safety check
                logrus.WithFields(logrus.Fields{
                        "function": "consumeSpellCastActionPoints",
                        "playerID": player.GetID(),
                }).Error("failed to consume action points after spell validation")
                return fmt.Errorf("action point consumption failed")
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function":    "consumeSpellCastActionPoints",
                "playerID":    player.GetID(),
                "consumedAP":  game.ActionCostSpell,
                "remainingAP": player.GetActionPoints(),
        }).Info("consumed action points for spell casting")

        return nil</span>
}

// handleStartCombat initiates a new combat session with the specified participants.
//
// Parameters:
//   - params: Raw JSON message containing:
//   - session_id: Unique identifier for the game session
//   - participant_ids: Array of string IDs for the combat participants
//
// Returns:
//   - interface{}: Map containing:
//   - success: Boolean indicating successful combat start
//   - initiative: Ordered array of participant IDs based on initiative rolls
//   - first_turn: ID of the participant who goes first
//   - error: Error if:
//   - Invalid JSON parameters provided
//   - Combat is already in progress for this session
//
// Related:
//   - TurnManager.StartCombat(): Handles the actual combat state management
//   - rollInitiative(): Determines turn order for participants
func (s *RPCServer) handleStartCombat(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleStartCombat",
        }).Debug("entering handleStartCombat")

        var req struct {
                SessionID    string   `json:"session_id"`
                Participants []string `json:"participant_ids"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleStartCombat",
                        "error":    err.Error(),
                }).Error("failed to unmarshal combat parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid combat parameters", err.Error())
        }</span>

        <span class="cov0" title="0">if s.state.TurnManager.IsInCombat </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleStartCombat",
                }).Warn("attempted to start combat while already in combat")
                return nil, fmt.Errorf("combat already in progress")
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function":     "handleStartCombat",
                "participants": len(req.Participants),
        }).Info("rolling initiative for combat participants")

        initiative := s.rollInitiative(req.Participants)
        if err := s.state.TurnManager.StartCombat(initiative); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleStartCombat",
                        "error":    err.Error(),
                }).Error("failed to start combat")
                return nil, fmt.Errorf("failed to start combat: %w", err)
        }</span>

        // Initialize action points for all combat participants
        <span class="cov0" title="0">s.mu.RLock()
        for _, participantID := range initiative </span><span class="cov0" title="0">{
                for _, session := range s.sessions </span><span class="cov0" title="0">{
                        if session.Player.GetID() == participantID </span><span class="cov0" title="0">{
                                session.Player.RestoreActionPoints()
                                logrus.WithFields(logrus.Fields{
                                        "function":      "handleStartCombat",
                                        "participantID": participantID,
                                        "actionPoints":  session.Player.GetActionPoints(),
                                }).Info("initialized action points for combat participant")
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">s.mu.RUnlock()

        logrus.WithFields(logrus.Fields{
                "function":  "handleStartCombat",
                "firstTurn": initiative[0],
        }).Info("combat started successfully")

        logrus.WithFields(logrus.Fields{
                "function": "handleStartCombat",
        }).Debug("exiting handleStartCombat")

        return map[string]interface{}{
                "success":    true,
                "initiative": initiative,
                "first_turn": initiative[0],
        }, nil</span>
}

// handleEndTurn processes a request to end the current player's turn in combat.
//
// Params:
//   - params: json.RawMessage containing a session_id field
//
// Returns:
//   - interface{}: A map containing "success" (bool) and "next_turn" with the next player's ID
//   - error: If session is invalid, not in combat, not player's turn, or invalid parameters
//
// Errors:
//   - "invalid turn parameters": If params cannot be unmarshaled
//   - "invalid session": If session ID does not exist
//   - "not in combat": If TurnManager.IsInCombat is false
//   - "not your turn": If current turn does not belong to requesting player
//
// Related:
//   - TurnManager.AdvanceTurn()
//   - processEndTurnEffects()
//   - processEndRound()
func (s *RPCServer) handleEndTurn(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleEndTurn",
        }).Debug("entering handleEndTurn")

        var req struct {
                SessionID string `json:"session_id"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleEndTurn",
                        "error":    err.Error(),
                }).Error("failed to unmarshal request parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid turn parameters", err.Error())
        }</span>

        <span class="cov8" title="1">session, exists := s.getSession(req.SessionID)
        if !exists </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":  "handleEndTurn",
                        "sessionID": req.SessionID,
                }).Warn("invalid session ID")
                return nil, fmt.Errorf("invalid session")
        }</span>
        <span class="cov8" title="1">defer s.releaseSession(session) // Ensure session is released when handler completes

        if !s.state.TurnManager.IsInCombat </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleEndTurn",
                }).Warn("attempted to end turn while not in combat")
                return nil, fmt.Errorf("not in combat")
        }</span>

        <span class="cov8" title="1">if !s.state.TurnManager.IsCurrentTurn(session.Player.GetID()) </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleEndTurn",
                        "playerID": session.Player.GetID(),
                }).Warn("player attempted to end turn when not their turn")
                return nil, fmt.Errorf("not your turn")
        }</span>

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function": "handleEndTurn",
                "playerID": session.Player.GetID(),
        }).Info("processing end of turn effects")
        s.processEndTurnEffects(session.Player)

        nextTurn := s.state.TurnManager.AdvanceTurn()
        logrus.WithFields(logrus.Fields{
                "function": "handleEndTurn",
                "nextTurn": nextTurn,
        }).Info("advanced to next turn")

        // Restore action points for the next player
        if nextTurn != "" </span><span class="cov8" title="1">{
                s.mu.RLock()
                for _, nextSession := range s.sessions </span><span class="cov8" title="1">{
                        if nextSession.Player.GetID() == nextTurn </span><span class="cov8" title="1">{
                                nextSession.Player.RestoreActionPoints()
                                logrus.WithFields(logrus.Fields{
                                        "function":     "handleEndTurn",
                                        "nextPlayerID": nextTurn,
                                        "restoredAP":   nextSession.Player.GetActionPoints(),
                                }).Info("restored action points for next player")
                                break</span>
                        }
                }
                <span class="cov8" title="1">s.mu.RUnlock()</span>
        }

        <span class="cov8" title="1">if s.state.TurnManager.CurrentIndex == 0 </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleEndTurn",
                }).Info("processing end of round")
                s.processEndRound()
        }</span>

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function": "handleEndTurn",
        }).Debug("exiting handleEndTurn")

        return map[string]interface{}{
                "success":   true,
                "next_turn": nextTurn,
        }, nil</span>
}

// handleGetGameState processes a request to retrieve the current game state for a given session.
// The method returns a comprehensive snapshot of the player's state and visible world elements.
//
// Parameters:
//   - params: json.RawMessage containing the session_id parameter
//
// Returns:
//   - interface{}: A map containing two main sections:
//   - player: Contains position, stats, active effects, inventory, spells and experience
//   - world: Contains visible objects, current game time and combat state if any
//   - error: Returns error if:
//   - Session ID is invalid or not found
//   - Request parameters cannot be unmarshaled
//
// Related:
//   - Player.GetPosition()
//   - Player.GetStats()
//   - TimeManager.CurrentTime
//   - getVisibleObjects()
//   - getActiveEffects()
//   - getCombatStateIfActive()
/*func (s *RPCServer) handleGetGameState(params json.RawMessage) (interface{}, error) {
        logger := logrus.WithFields(logrus.Fields{
                "function": "handleGetGameState",
        })
        logger.Debug("entering handleGetGameState")

        // 1. Validate params
        var req struct {
                SessionID string `json:"session_id"`
        }
        if err := json.Unmarshal(params, &amp;req); err != nil {
                logger.WithError(err).Error("failed to unmarshal parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid parameters", err.Error())
        }

        // 2. Validate session
        if req.SessionID == "" {
                logger.Warn("invalid session ID")
                return nil, ErrInvalidSession
        }

        // 3. Validate server state
        if s.state == nil {
                logger.Error("game state not initialized")
                return nil, fmt.Errorf("server state not initialized")
        }

        // 4. Get and validate session
        session, exists := s.getSession(req.SessionID)

        if !exists {
                logger.WithField("sessionID", req.SessionID).Warn("session not found")
                return nil, ErrInvalidSession
        }

        // 5. Get game state
        session.LastActive = time.Now()
        state := s.state.GetState()

        // 6. Validate response
        if state == nil {
                logger.Error("failed to get game state")
                return nil, fmt.Errorf("internal server error")
        }

        logger.Debug("exiting handleGetGameState")
        return state, nil
}*/

func (s *RPCServer) handleGetGameState(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "handleGetGameState",
        })
        logger.Debug("entering handleGetGameState")

        // 1. Validate params
        var req struct {
                SessionID string `json:"session_id"`
        }
        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to unmarshal parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid parameters", err.Error())
        }</span>

        // 2. Check session safely
        <span class="cov0" title="0">session, err := s.getSessionSafely(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithField("sessionID", req.SessionID).Warn("session not found")
                return nil, ErrInvalidSession
        }</span>
        <span class="cov0" title="0">defer s.releaseSession(session) // Ensure session is released when handler completes

        // 3. Get game state (uses its own internal locking)
        state := s.state.GetState()
        if state == nil </span><span class="cov0" title="0">{
                logger.Error("failed to get game state")
                return nil, fmt.Errorf("internal server error")
        }</span>

        <span class="cov0" title="0">logger.Debug("exiting handleGetGameState")
        return state, nil</span>
}

// handleApplyEffect processes a request to apply an effect to a target entity in the game world.
//
// Parameters:
// - params: json.RawMessage containing the request parameters:
//   - session_id: string identifier for the player session
//   - effect_type: game.EffectType enum specifying the type of effect
//   - target_id: string identifier for the target entity
//   - magnitude: float64 indicating the strength/amount of the effect
//   - duration: game.Duration specifying how long the effect lasts
//
// Returns:
// - interface{}: A map containing:
//   - success: bool indicating if effect was applied
//   - effect_id: string identifier for the created effect
//
// - error: Error if request fails due to:
//   - Invalid JSON parameters
//   - Invalid session ID
//   - Invalid target ID
//   - Target not implementing EffectHolder interface
//   - Effect application failure
//
// Related types:
// - game.Effect
// - game.EffectHolder
// - game.EffectType
// - game.Duration
func (s *RPCServer) handleApplyEffect(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleApplyEffect",
        }).Debug("entering handleApplyEffect")

        var req struct {
                SessionID  string          `json:"session_id"`
                EffectType game.EffectType `json:"effect_type"`
                TargetID   string          `json:"target_id"`
                Magnitude  float64         `json:"magnitude"`
                Duration   game.Duration   `json:"duration"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleApplyEffect",
                        "error":    err.Error(),
                }).Error("failed to unmarshal effect parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid effect parameters", err.Error())
        }</span>

        <span class="cov0" title="0">session, exists := s.getSession(req.SessionID)
        if !exists </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":  "handleApplyEffect",
                        "sessionID": req.SessionID,
                }).Warn("invalid session ID")
                return nil, fmt.Errorf("invalid session")
        }</span>

        // Create and apply the effect
        <span class="cov0" title="0">effect := game.NewEffect(req.EffectType, req.Duration, req.Magnitude)
        effect.SourceID = session.Player.GetID()

        logrus.WithFields(logrus.Fields{
                "function":   "handleApplyEffect",
                "effectType": req.EffectType,
                "targetID":   req.TargetID,
        }).Info("creating new effect")

        target, exists := s.state.WorldState.Objects[req.TargetID]
        if !exists </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleApplyEffect",
                        "targetID": req.TargetID,
                }).Warn("invalid target ID")
                return nil, fmt.Errorf("invalid target")
        }</span>

        <span class="cov0" title="0">effectHolder, ok := target.(game.EffectHolder)
        if !ok </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleApplyEffect",
                        "targetID": req.TargetID,
                }).Warn("target cannot receive effects")
                return nil, fmt.Errorf("target cannot receive effects")
        }</span>

        <span class="cov0" title="0">if err := effectHolder.AddEffect(effect); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleApplyEffect",
                        "error":    err.Error(),
                }).Error("failed to add effect")
                return nil, err
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "handleApplyEffect",
                "effectID": effect.ID,
        }).Info("effect successfully applied")

        logrus.WithFields(logrus.Fields{
                "function": "handleApplyEffect",
        }).Debug("exiting handleApplyEffect")

        return map[string]interface{}{
                "success":   true,
                "effect_id": effect.ID,
        }, nil</span>
}

func (s *RPCServer) handleJoinGame(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleJoinGame",
        }).Debug("entering handleJoinGame")

        var req struct {
                PlayerName string `json:"player_name"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleJoinGame",
                        "error":    err.Error(),
                }).Error("failed to unmarshal join parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid join parameters", err.Error())
        }</span>

        <span class="cov0" title="0">if req.PlayerName == "" </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleJoinGame",
                }).Warn("empty player name")
                return nil, fmt.Errorf("player name is required")
        }</span>

        // Create new session
        <span class="cov0" title="0">s.mu.Lock()
        sessionID := uuid.New().String()
        session := &amp;PlayerSession{
                SessionID:   sessionID,
                CreatedAt:   time.Now(),
                LastActive:  time.Now(),
                MessageChan: make(chan []byte, MessageChanBufferSize),
        }
        s.sessions[sessionID] = session
        s.mu.Unlock()

        logrus.WithFields(logrus.Fields{
                "function":    "handleJoinGame",
                "sessionID":   sessionID,
                "player_name": req.PlayerName,
        }).Info("created new session for player")

        // Initialize player in session
        s.state.AddPlayer(session)

        logrus.WithFields(logrus.Fields{
                "function": "handleJoinGame",
        }).Debug("exiting handleJoinGame")

        return map[string]interface{}{
                "success":    true,
                "session_id": session.SessionID,
        }, nil</span>
}

// handleCreateCharacter processes a character creation request and creates a new character.
//
// Parameters:
//   - params: json.RawMessage containing:
//   - name: string - Character name
//   - class: string - Character class ("fighter", "mage", "cleric", "thief", "ranger", "paladin")
//   - attribute_method: string - Attribute generation method ("roll", "pointbuy", "standard", "custom")
//   - custom_attributes: map[string]int - Custom attribute values (optional)
//   - starting_equipment: bool - Whether to include starting equipment
//   - starting_gold: int - Starting gold amount (optional)
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if creation was successful
//   - character: Created character data
//   - player: Created player data
//   - session_id: Session ID for the new character
//   - errors: List of any error messages
//   - warnings: List of any warning messages
//
// Errors:
//   - "invalid character creation parameters" if JSON unmarshaling fails
//   - Character creation validation errors from CharacterCreator
//   - Session creation errors
func (s *RPCServer) handleCreateCharacter(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleCreateCharacter",
        }).Debug("entering handleCreateCharacter")

        req, err := s.parseCharacterCreationRequest(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">config, err := s.buildCharacterConfig(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := s.createNewCharacter(config)
        if !result.Success </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleCreateCharacter",
                        "errors":   result.Errors,
                }).Error("character creation failed")
                return map[string]interface{}{
                        "success":  false,
                        "errors":   result.Errors,
                        "warnings": result.Warnings,
                }, nil
        }</span>

        <span class="cov8" title="1">session := s.createAndRegisterSession(result.PlayerData)

        logrus.WithFields(logrus.Fields{
                "function":      "handleCreateCharacter",
                "sessionID":     session.SessionID,
                "characterName": req.Name,
                "class":         req.Class,
        }).Info("character created successfully")

        return map[string]interface{}{
                "success":         true,
                "character":       result.Character,
                "player":          result.PlayerData,
                "session_id":      session.SessionID,
                "errors":          result.Errors,
                "warnings":        result.Warnings,
                "creation_time":   result.CreationTime,
                "generated_stats": result.GeneratedStats,
                "starting_items":  result.StartingItems,
        }, nil</span>
}

// createCharacterRequest defines the structure for a character creation request.
type createCharacterRequest struct {
        Name              string         `json:"name"`
        Class             string         `json:"class"`
        AttributeMethod   string         `json:"attribute_method"`
        CustomAttributes  map[string]int `json:"custom_attributes,omitempty"`
        StartingEquipment bool           `json:"starting_equipment"`
        StartingGold      int            `json:"starting_gold"`
}

// parseCharacterCreationRequest unmarshals the raw JSON into a createCharacterRequest struct.
func (s *RPCServer) parseCharacterCreationRequest(params json.RawMessage) (*createCharacterRequest, error) <span class="cov8" title="1">{
        var req createCharacterRequest
        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "parseCharacterCreationRequest",
                        "error":    err.Error(),
                }).Error("failed to unmarshal character creation parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid character creation parameters", err.Error())
        }</span>
        <span class="cov8" title="1">return &amp;req, nil</span>
}

// buildCharacterConfig creates the character configuration from the request.
func (s *RPCServer) buildCharacterConfig(req *createCharacterRequest) (*game.CharacterCreationConfig, error) <span class="cov8" title="1">{
        classMap := map[string]game.CharacterClass{
                "fighter": game.ClassFighter,
                "mage":    game.ClassMage,
                "cleric":  game.ClassCleric,
                "thief":   game.ClassThief,
                "ranger":  game.ClassRanger,
                "paladin": game.ClassPaladin,
        }

        characterClass, exists := classMap[req.Class]
        if !exists </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "buildCharacterConfig",
                        "class":    req.Class,
                }).Error("invalid character class")
                return nil, fmt.Errorf("invalid character class: %s", req.Class)
        }</span>

        <span class="cov8" title="1">if req.StartingGold == 0 </span><span class="cov0" title="0">{
                defaultGold := map[game.CharacterClass]int{
                        game.ClassFighter: 100,
                        game.ClassMage:    50,
                        game.ClassCleric:  75,
                        game.ClassThief:   80,
                        game.ClassRanger:  90,
                        game.ClassPaladin: 120,
                }
                req.StartingGold = defaultGold[characterClass]
        }</span>

        <span class="cov8" title="1">return &amp;game.CharacterCreationConfig{
                Name:              req.Name,
                Class:             characterClass,
                AttributeMethod:   req.AttributeMethod,
                CustomAttributes:  req.CustomAttributes,
                StartingEquipment: req.StartingEquipment,
                StartingGold:      req.StartingGold,
        }, nil</span>
}

// createNewCharacter uses the CharacterCreator to create a new character based on the config.
func (s *RPCServer) createNewCharacter(config *game.CharacterCreationConfig) *game.CharacterCreationResult <span class="cov8" title="1">{
        creator := game.NewCharacterCreator()
        result := creator.CreateCharacter(*config)
        return &amp;result
}</span>

// createAndRegisterSession creates a new player session and registers it with the server.
func (s *RPCServer) createAndRegisterSession(playerData *game.Player) *PlayerSession <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        var sessionID string
        for </span><span class="cov8" title="1">{
                sessionID = game.NewUID()
                if _, exists := s.sessions[sessionID]; !exists </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                        "function":  "createAndRegisterSession",
                        "sessionID": sessionID,
                }).Warn("session ID collision detected, generating new ID")</span>
        }

        <span class="cov8" title="1">session := &amp;PlayerSession{
                SessionID:   sessionID,
                Player:      playerData,
                LastActive:  time.Now(),
                CreatedAt:   time.Now(),
                Connected:   false,
                MessageChan: make(chan []byte, MessageChanBufferSize),
        }

        s.sessions[sessionID] = session
        return session</span>
}

// Equipment management handlers
func (s *RPCServer) handleEquipItem(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleEquipItem",
        }).Debug("entering handleEquipItem")

        var req struct {
                SessionID string `json:"session_id"`
                ItemID    string `json:"item_id"`
                Slot      string `json:"slot"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleEquipItem",
                        "error":    err.Error(),
                }).Error("failed to unmarshal equip item parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid equip item parameters", err.Error())
        }</span>

        // Get player session
        <span class="cov8" title="1">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">player := session.Player

        // Parse slot name to EquipmentSlot
        slot, err := parseEquipmentSlot(req.Slot)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleEquipItem",
                        "slot":     req.Slot,
                }).Error("invalid equipment slot")
                return nil, fmt.Errorf("invalid equipment slot: %s", req.Slot)
        }</span>

        // Check if there's a previously equipped item
        <span class="cov8" title="1">var previousItem *game.Item
        if prevEquipped, exists := player.GetEquippedItem(slot); exists </span><span class="cov0" title="0">{
                previousItem = prevEquipped
        }</span>

        // Equip the item
        <span class="cov8" title="1">if err := player.EquipItem(req.ItemID, slot); err != nil </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleEquipItem",
                        "itemID":   req.ItemID,
                        "slot":     req.Slot,
                        "error":    err.Error(),
                }).Error("failed to equip item")
                return map[string]interface{}{
                        "success": false,
                        "message": err.Error(),
                }, nil
        }</span>

        // Get the newly equipped item
        <span class="cov8" title="1">equippedItem, _ := player.GetEquippedItem(slot)

        logrus.WithFields(logrus.Fields{
                "function":     "handleEquipItem",
                "sessionID":    req.SessionID,
                "itemID":       req.ItemID,
                "slot":         req.Slot,
                "equippedItem": equippedItem.Name,
        }).Info("item equipped successfully")

        response := map[string]interface{}{
                "success":       true,
                "message":       fmt.Sprintf("Successfully equipped %s", equippedItem.Name),
                "equipped_item": equippedItem,
        }

        if previousItem != nil </span><span class="cov0" title="0">{
                response["previous_item"] = previousItem
        }</span>

        <span class="cov8" title="1">return response, nil</span>
}

// handleUnequipItem removes an equipped item and returns it to the player's inventory.
//
// Parameters (JSON):
//   - session_id: string - Player session identifier
//   - slot: string - Name of the equipment slot to unequip
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if unequipping was successful
//   - message: string describing the result
//   - unequipped_item: object containing details of the unequipped item
//
// Errors:
//   - "invalid session" if session is not found or inactive
//   - "invalid slot" if slot name is not recognized
//   - "no item equipped" if the specified slot is empty
func (s *RPCServer) handleUnequipItem(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleUnequipItem",
        }).Debug("entering handleUnequipItem")

        var req struct {
                SessionID string `json:"session_id"`
                Slot      string `json:"slot"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleUnequipItem",
                        "error":    err.Error(),
                }).Error("failed to unmarshal unequip item parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid unequip item parameters", err.Error())
        }</span>

        // Get player session
        <span class="cov8" title="1">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">player := session.Player

        // Parse slot name to EquipmentSlot
        slot, err := parseEquipmentSlot(req.Slot)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleUnequipItem",
                        "slot":     req.Slot,
                }).Error("invalid equipment slot")
                return nil, fmt.Errorf("invalid equipment slot: %s", req.Slot)
        }</span>

        // Unequip the item
        <span class="cov8" title="1">unequippedItem, err := player.UnequipItem(slot)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleUnequipItem",
                        "slot":     req.Slot,
                        "error":    err.Error(),
                }).Error("failed to unequip item")
                return map[string]interface{}{
                        "success": false,
                        "message": err.Error(),
                }, nil
        }</span>

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function":       "handleUnequipItem",
                "sessionID":      req.SessionID,
                "slot":           req.Slot,
                "unequippedItem": unequippedItem.Name,
        }).Info("item unequipped successfully")

        return map[string]interface{}{
                "success":         true,
                "message":         fmt.Sprintf("Successfully unequipped %s", unequippedItem.Name),
                "unequipped_item": unequippedItem,
        }, nil</span>
}

// handleGetEquipment returns all currently equipped items for a player.
//
// Parameters (JSON):
//   - session_id: string - Player session identifier
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if retrieval was successful
//   - equipment: map of slot names to equipped item objects
//   - total_weight: int total weight of all equipped items
//   - equipment_bonuses: map of stat bonuses from equipment
//
// Errors:
//   - "invalid session" if session is not found or inactive
func (s *RPCServer) handleGetEquipment(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleGetEquipment",
        }).Debug("entering handleGetEquipment")

        var req struct {
                SessionID string `json:"session_id"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleGetEquipment",
                        "error":    err.Error(),
                }).Error("failed to unmarshal get equipment parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid get equipment parameters", err.Error())
        }</span>

        // Get player session
        <span class="cov8" title="1">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">player := session.Player

        // Get all equipped items
        equippedItems := player.GetAllEquippedItems()

        // Convert equipment slots to string keys for JSON response
        equipment := make(map[string]game.Item)
        totalWeight := 0
        for slot, item := range equippedItems </span><span class="cov8" title="1">{
                slotName := equipmentSlotToString(slot)
                equipment[slotName] = item
                totalWeight += item.Weight
        }</span>

        // Get equipment bonuses
        <span class="cov8" title="1">bonuses := player.CalculateEquipmentBonuses()

        logrus.WithFields(logrus.Fields{
                "function":    "handleGetEquipment",
                "sessionID":   req.SessionID,
                "numItems":    len(equipment),
                "totalWeight": totalWeight,
        }).Info("equipment retrieved successfully")

        return map[string]interface{}{
                "success":           true,
                "equipment":         equipment,
                "total_weight":      totalWeight,
                "equipment_bonuses": bonuses,
        }, nil</span>
}

// parseEquipmentSlot converts a string slot name to an EquipmentSlot enum value
func parseEquipmentSlot(slotName string) (game.EquipmentSlot, error) <span class="cov8" title="1">{
        slotMap := map[string]game.EquipmentSlot{
                "head":        game.SlotHead,
                "neck":        game.SlotNeck,
                "chest":       game.SlotChest,
                "hands":       game.SlotHands,
                "rings":       game.SlotRings,
                "legs":        game.SlotLegs,
                "feet":        game.SlotFeet,
                "weapon_main": game.SlotWeaponMain,
                "weapon_off":  game.SlotWeaponOff,
                "main_hand":   game.SlotWeaponMain, // Alternative naming
                "off_hand":    game.SlotWeaponOff,  // Alternative naming
        }

        if slot, exists := slotMap[slotName]; exists </span><span class="cov8" title="1">{
                return slot, nil
        }</span>

        <span class="cov8" title="1">return game.SlotHead, fmt.Errorf("unknown equipment slot: %s", slotName)</span>
}

// equipmentSlotToString converts an EquipmentSlot enum value to a string
func equipmentSlotToString(slot game.EquipmentSlot) string <span class="cov8" title="1">{
        slotNames := map[game.EquipmentSlot]string{
                game.SlotHead:       "head",
                game.SlotNeck:       "neck",
                game.SlotChest:      "chest",
                game.SlotHands:      "hands",
                game.SlotRings:      "rings",
                game.SlotLegs:       "legs",
                game.SlotFeet:       "feet",
                game.SlotWeaponMain: "weapon_main",
                game.SlotWeaponOff:  "weapon_off",
        }

        if name, exists := slotNames[slot]; exists </span><span class="cov8" title="1">{
                return name
        }</span>

        <span class="cov0" title="0">return "unknown"</span>
}

// getPlayerSession retrieves a player session by session ID with validation
func (s *RPCServer) getPlayerSession(sessionID string) (*PlayerSession, error) <span class="cov8" title="1">{
        s.mu.RLock()
        session, exists := s.sessions[sessionID]
        s.mu.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid session")
        }</span>

        <span class="cov8" title="1">if session.Player == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session has no associated player")
        }</span>

        <span class="cov8" title="1">return session, nil</span>
}

// handleStartQuest processes a request to start a new quest for a player.
// This handler validates the quest data and adds it to the player's quest log.
//
// Parameters:
//   - params: json.RawMessage containing the start quest request with:
//   - session_id: string - The session ID of the requesting player
//   - quest: Quest object - The quest data to start
//
// Returns:
//   - interface{}: Success response with quest ID if quest started successfully
//   - error: Error if request fails due to:
//   - Invalid request parameters
//   - Session not found or inactive
//   - Quest validation failures
//   - Quest already exists in player's quest log
func (s *RPCServer) handleStartQuest(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "handleStartQuest",
        })
        logger.Debug("entering handleStartQuest")

        var req struct {
                SessionID string     `json:"session_id"`
                Quest     game.Quest `json:"quest"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function": "handleStartQuest",
                }).Error("failed to unmarshal request parameters")
                return nil, fmt.Errorf("invalid request parameters: %w", err)
        }</span>

        // Get player session
        <span class="cov0" title="0">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function":   "handleStartQuest",
                        "session_id": req.SessionID,
                }).Error("failed to get player session")
                return nil, fmt.Errorf("session error: %w", err)
        }</span>

        // Start quest for player
        <span class="cov0" title="0">if err := session.Player.StartQuest(req.Quest); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function": "handleStartQuest",
                        "quest_id": req.Quest.ID,
                }).Error("failed to start quest")
                return nil, fmt.Errorf("failed to start quest: %w", err)
        }</span>

        <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                "function": "handleStartQuest",
                "quest_id": req.Quest.ID,
        }).Debug("exiting handleStartQuest")

        return map[string]interface{}{
                "success":  true,
                "quest_id": req.Quest.ID,
                "message":  "Quest started successfully",
        }, nil</span>
}

// handleCompleteQuest processes a request to complete a quest for a player.
// This handler validates quest completion criteria and processes rewards.
//
// Parameters:
//   - params: json.RawMessage containing the complete quest request with:
//   - session_id: string - The session ID of the requesting player
//   - quest_id: string - The ID of the quest to complete
//
// Returns:
//   - interface{}: Success response with rewards if quest completed successfully
//   - error: Error if request fails due to:
//   - Invalid request parameters
//   - Session not found or inactive
//   - Quest not found or not completable
//   - Quest objectives not fulfilled
func (s *RPCServer) handleCompleteQuest(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "handleCompleteQuest",
        })
        logger.Debug("entering handleCompleteQuest")

        req, err := s.parseCompleteQuestRequest(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithField("session_id", req.SessionID).Error("failed to get player session")
                return nil, fmt.Errorf("session error: %w", err)
        }</span>

        <span class="cov8" title="1">rewards, err := session.Player.CompleteQuest(req.QuestID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithField("quest_id", req.QuestID).Error("failed to complete quest")
                return nil, fmt.Errorf("failed to complete quest: %w", err)
        }</span>

        <span class="cov8" title="1">if err := s.applyQuestRewards(session.Player, req.QuestID, rewards); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">logger.WithFields(logrus.Fields{
                "quest_id":     req.QuestID,
                "reward_count": len(rewards),
        }).Info("quest completed and all rewards applied")

        logger.WithField("quest_id", req.QuestID).Debug("exiting handleCompleteQuest")

        return map[string]interface{}{
                "success":  true,
                "quest_id": req.QuestID,
                "rewards":  rewards,
                "message":  "Quest completed successfully",
        }, nil</span>
}

// completeQuestRequest defines the structure for a complete quest request.
type completeQuestRequest struct {
        SessionID string `json:"session_id"`
        QuestID   string `json:"quest_id"`
}

// parseCompleteQuestRequest parses the JSON request for completing a quest.
func (s *RPCServer) parseCompleteQuestRequest(params json.RawMessage) (*completeQuestRequest, error) <span class="cov8" title="1">{
        var req completeQuestRequest
        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).WithFields(logrus.Fields{
                        "function": "parseCompleteQuestRequest",
                }).Error("failed to unmarshal request parameters")
                return nil, fmt.Errorf("invalid request parameters: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;req, nil</span>
}

// applyQuestRewards processes and applies all rewards for a completed quest.
func (s *RPCServer) applyQuestRewards(player *game.Player, questID string, rewards []game.QuestReward) error <span class="cov8" title="1">{
        for _, reward := range rewards </span><span class="cov8" title="1">{
                var err error
                switch reward.Type </span>{
                case "exp":<span class="cov8" title="1">
                        err = s.applyExperienceReward(player, questID, reward)</span>
                case "gold":<span class="cov8" title="1">
                        s.applyGoldReward(player, questID, reward)</span>
                case "item":<span class="cov8" title="1">
                        err = s.applyItemReward(player, questID, reward)</span>
                default:<span class="cov0" title="0">
                        logrus.WithFields(logrus.Fields{
                                "function":    "applyQuestRewards",
                                "quest_id":    questID,
                                "reward_type": reward.Type,
                        }).Warn("unknown reward type, skipping")</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// applyExperienceReward applies an experience reward to the player.
func (s *RPCServer) applyExperienceReward(player *game.Player, questID string, reward game.QuestReward) error <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function":    "applyExperienceReward",
                "quest_id":    questID,
                "reward_type": "exp",
                "value":       reward.Value,
        })

        if err := player.AddExperience(int64(reward.Value)); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to apply experience reward")
                return fmt.Errorf("failed to apply experience reward: %w", err)
        }</span>
        <span class="cov8" title="1">logger.Info("applied experience reward")
        return nil</span>
}

// applyGoldReward applies a gold reward to the player.
func (s *RPCServer) applyGoldReward(player *game.Player, questID string, reward game.QuestReward) <span class="cov8" title="1">{
        previousGold := player.Character.Gold
        player.Character.Gold += reward.Value
        logrus.WithFields(logrus.Fields{
                "function":      "applyGoldReward",
                "quest_id":      questID,
                "gold_added":    reward.Value,
                "previous_gold": previousGold,
                "new_gold":      player.Character.Gold,
        }).Info("applied gold reward")
}</span>

// applyItemReward applies an item reward to the player.
func (s *RPCServer) applyItemReward(player *game.Player, questID string, reward game.QuestReward) error <span class="cov8" title="1">{
        if reward.ItemID == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">logger := logrus.WithFields(logrus.Fields{
                "function":    "applyItemReward",
                "quest_id":    questID,
                "reward_type": "item",
                "item_id":     reward.ItemID,
        })

        item := game.Item{
                ID:   reward.ItemID,
                Name: reward.ItemID, // Basic implementation - could be enhanced with item lookup
                Type: "quest_reward",
        }
        if err := player.Character.AddItemToInventory(item); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to apply item reward")
                return fmt.Errorf("failed to apply item reward: %w", err)
        }</span>
        <span class="cov8" title="1">logger.Info("applied item reward")
        return nil</span>
}

// handleUpdateObjective processes a request to update quest objective progress.
// This handler validates the objective update and tracks completion.
//
// Parameters:
//   - params: json.RawMessage containing the update objective request with:
//   - session_id: string - The session ID of the requesting player
//   - quest_id: string - The ID of the quest containing the objective
//   - objective_index: int - The index of the objective to update (0-based)
//   - progress: int - The new progress value for the objective
//
// Returns:
//   - interface{}: Success response with updated objective status
//   - error: Error if request fails due to:
//   - Invalid request parameters
//   - Session not found or inactive
//   - Quest not found or not active
//   - Invalid objective index
func (s *RPCServer) handleUpdateObjective(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "handleUpdateObjective",
        })
        logger.Debug("entering handleUpdateObjective")

        var req struct {
                SessionID      string `json:"session_id"`
                QuestID        string `json:"quest_id"`
                ObjectiveIndex int    `json:"objective_index"`
                Progress       int    `json:"progress"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function": "handleUpdateObjective",
                }).Error("failed to unmarshal request parameters")
                return nil, fmt.Errorf("invalid request parameters: %w", err)
        }</span>

        // Get player session
        <span class="cov0" title="0">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function":   "handleUpdateObjective",
                        "session_id": req.SessionID,
                }).Error("failed to get player session")
                return nil, fmt.Errorf("session error: %w", err)
        }</span>

        // Update quest objective for player
        <span class="cov0" title="0">if err := session.Player.UpdateQuestObjective(req.QuestID, req.ObjectiveIndex, req.Progress); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function":        "handleUpdateObjective",
                        "quest_id":        req.QuestID,
                        "objective_index": req.ObjectiveIndex,
                }).Error("failed to update quest objective")
                return nil, fmt.Errorf("failed to update quest objective: %w", err)
        }</span>

        <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                "function":        "handleUpdateObjective",
                "quest_id":        req.QuestID,
                "objective_index": req.ObjectiveIndex,
                "progress":        req.Progress,
        }).Debug("exiting handleUpdateObjective")

        return map[string]interface{}{
                "success":         true,
                "quest_id":        req.QuestID,
                "objective_index": req.ObjectiveIndex,
                "progress":        req.Progress,
                "message":         "Quest objective updated successfully",
        }, nil</span>
}

// handleFailQuest processes a request to fail a quest for a player.
// This handler marks the quest as failed, preventing completion.
//
// Parameters:
//   - params: json.RawMessage containing the fail quest request with:
//   - session_id: string - The session ID of the requesting player
//   - quest_id: string - The ID of the quest to fail
//
// Returns:
//   - interface{}: Success response confirming quest failure
//   - error: Error if request fails due to:
//   - Invalid request parameters
//   - Session not found or inactive
//   - Quest not found or already completed/failed
func (s *RPCServer) handleFailQuest(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "handleFailQuest",
        })
        logger.Debug("entering handleFailQuest")

        var req struct {
                SessionID string `json:"session_id"`
                QuestID   string `json:"quest_id"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function": "handleFailQuest",
                }).Error("failed to unmarshal request parameters")
                return nil, fmt.Errorf("invalid request parameters: %w", err)
        }</span>

        // Get player session
        <span class="cov0" title="0">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function":   "handleFailQuest",
                        "session_id": req.SessionID,
                }).Error("failed to get player session")
                return nil, fmt.Errorf("session error: %w", err)
        }</span>

        // Fail quest for player
        <span class="cov0" title="0">if err := session.Player.FailQuest(req.QuestID); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function": "handleFailQuest",
                        "quest_id": req.QuestID,
                }).Error("failed to fail quest")
                return nil, fmt.Errorf("failed to fail quest: %w", err)
        }</span>

        <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                "function": "handleFailQuest",
                "quest_id": req.QuestID,
        }).Debug("exiting handleFailQuest")

        return map[string]interface{}{
                "success":  true,
                "quest_id": req.QuestID,
                "message":  "Quest failed successfully",
        }, nil</span>
}

// handleGetQuest processes a request to retrieve a specific quest from a player's quest log.
// This handler returns quest details including objectives and current status.
//
// Parameters:
//   - params: json.RawMessage containing the get quest request with:
//   - session_id: string - The session ID of the requesting player
//   - quest_id: string - The ID of the quest to retrieve
//
// Returns:
//   - interface{}: Quest data with full details
//   - error: Error if request fails due to:
//   - Invalid request parameters
//   - Session not found or inactive
//   - Quest not found in player's quest log
func (s *RPCServer) handleGetQuest(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "handleGetQuest",
        })
        logger.Debug("entering handleGetQuest")

        var req struct {
                SessionID string `json:"session_id"`
                QuestID   string `json:"quest_id"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function": "handleGetQuest",
                }).Error("failed to unmarshal request parameters")
                return nil, fmt.Errorf("invalid request parameters: %w", err)
        }</span>

        // Get player session
        <span class="cov0" title="0">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function":   "handleGetQuest",
                        "session_id": req.SessionID,
                }).Error("failed to get player session")
                return nil, fmt.Errorf("session error: %w", err)
        }</span>

        // Get quest from player
        <span class="cov0" title="0">quest, err := session.Player.GetQuest(req.QuestID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function": "handleGetQuest",
                        "quest_id": req.QuestID,
                }).Error("failed to get quest")
                return nil, fmt.Errorf("failed to get quest: %w", err)
        }</span>

        <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                "function": "handleGetQuest",
                "quest_id": req.QuestID,
        }).Debug("exiting handleGetQuest")

        return map[string]interface{}{
                "success": true,
                "quest":   quest,
        }, nil</span>
}

// handleGetActiveQuests processes a request to retrieve all active quests for a player.
// This handler returns a list of quests that are currently in progress.
//
// Parameters:
//   - params: json.RawMessage containing the get active quests request with:
//   - session_id: string - The session ID of the requesting player
//
// Returns:
//   - interface{}: Array of active quest data
//   - error: Error if request fails due to:
//   - Invalid request parameters
//   - Session not found or inactive
func (s *RPCServer) handleGetActiveQuests(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "handleGetActiveQuests",
        })
        logger.Debug("entering handleGetActiveQuests")

        var req struct {
                SessionID string `json:"session_id"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function": "handleGetActiveQuests",
                }).Error("failed to unmarshal request parameters")
                return nil, fmt.Errorf("invalid request parameters: %w", err)
        }</span>

        // Get player session
        <span class="cov0" title="0">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function":   "handleGetActiveQuests",
                        "session_id": req.SessionID,
                }).Error("failed to get player session")
                return nil, fmt.Errorf("session error: %w", err)
        }</span>

        // Get active quests from player
        <span class="cov0" title="0">activeQuests := session.Player.GetActiveQuests()

        logger.WithFields(logrus.Fields{
                "function":    "handleGetActiveQuests",
                "quest_count": len(activeQuests),
        }).Debug("exiting handleGetActiveQuests")

        return map[string]interface{}{
                "success":       true,
                "active_quests": activeQuests,
                "count":         len(activeQuests),
        }, nil</span>
}

// handleGetCompletedQuests processes a request to retrieve all completed quests for a player.
// This handler returns a list of quests that have been successfully finished.
//
// Parameters:
//   - params: json.RawMessage containing the get completed quests request with:
//   - session_id: string - The session ID of the requesting player
//
// Returns:
//   - interface{}: Array of completed quest data
//   - error: Error if request fails due to:
//   - Invalid request parameters
//   - Session not found or inactive
func (s *RPCServer) handleGetCompletedQuests(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "handleGetCompletedQuests",
        })
        logger.Debug("entering handleGetCompletedQuests")

        var req struct {
                SessionID string `json:"session_id"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function": "handleGetCompletedQuests",
                }).Error("failed to unmarshal request parameters")
                return nil, fmt.Errorf("invalid request parameters: %w", err)
        }</span>

        // Get player session
        <span class="cov0" title="0">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function":   "handleGetCompletedQuests",
                        "session_id": req.SessionID,
                }).Error("failed to get player session")
                return nil, fmt.Errorf("session error: %w", err)
        }</span>

        // Get completed quests from player
        <span class="cov0" title="0">completedQuests := session.Player.GetCompletedQuests()

        logger.WithFields(logrus.Fields{
                "function":    "handleGetCompletedQuests",
                "quest_count": len(completedQuests),
        }).Debug("exiting handleGetCompletedQuests")

        return map[string]interface{}{
                "success":          true,
                "completed_quests": completedQuests,
                "count":            len(completedQuests),
        }, nil</span>
}

// handleGetQuestLog processes a request to retrieve the complete quest log for a player.
// This handler returns all quests regardless of status (active, completed, failed).
//
// Parameters:
//   - params: json.RawMessage containing the get quest log request with:
//   - session_id: string - The session ID of the requesting player
//
// Returns:
//   - interface{}: Complete quest log with all quest data
//   - error: Error if request fails due to:
//   - Invalid request parameters
//   - Session not found or inactive
func (s *RPCServer) handleGetQuestLog(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "handleGetQuestLog",
        })
        logger.Debug("entering handleGetQuestLog")

        var req struct {
                SessionID string `json:"session_id"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function": "handleGetQuestLog",
                }).Error("failed to unmarshal request parameters")
                return nil, fmt.Errorf("invalid request parameters: %w", err)
        }</span>

        // Get player session
        <span class="cov0" title="0">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).WithFields(logrus.Fields{
                        "function":   "handleGetQuestLog",
                        "session_id": req.SessionID,
                }).Error("failed to get player session")
                return nil, fmt.Errorf("session error: %w", err)
        }</span>

        // Get complete quest log from player
        <span class="cov0" title="0">questLog := session.Player.GetQuestLog()

        logger.WithFields(logrus.Fields{
                "function":    "handleGetQuestLog",
                "quest_count": len(questLog),
        }).Debug("exiting handleGetQuestLog")

        return map[string]interface{}{
                "success":   true,
                "quest_log": questLog,
                "count":     len(questLog),
        }, nil</span>
}

// Spell management handlers

// handleGetSpell retrieves a specific spell by ID from the spell database.
//
// Parameters (JSON):
//   - spell_id: string - The unique identifier of the spell to retrieve
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if retrieval was successful
//   - spell: object containing the spell data
//
// Errors:
//   - "invalid spell ID" if spell_id is empty or not provided
//   - "spell not found" if the spell doesn't exist in the database
func (s *RPCServer) handleGetSpell(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleGetSpell",
        }).Debug("entering handleGetSpell")

        var req struct {
                SpellID string `json:"spell_id"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleGetSpell",
                        "error":    err.Error(),
                }).Error("failed to unmarshal get spell parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid get spell parameters", err.Error())
        }</span>

        <span class="cov0" title="0">if req.SpellID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("spell ID cannot be empty")
        }</span>

        <span class="cov0" title="0">spell, err := s.spellManager.GetSpell(req.SpellID)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleGetSpell",
                        "spellID":  req.SpellID,
                        "error":    err.Error(),
                }).Error("spell not found")
                return nil, err
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "handleGetSpell",
                "spellID":  req.SpellID,
        }).Info("spell retrieved successfully")

        return map[string]interface{}{
                "success": true,
                "spell":   spell,
        }, nil</span>
}

// handleGetSpellsByLevel retrieves all spells of a specific level.
//
// Parameters (JSON):
//   - level: int - The spell level to filter by (0 for cantrips, 1+ for leveled spells)
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if retrieval was successful
//   - spells: array of spell objects
//   - count: int number of spells found
func (s *RPCServer) handleGetSpellsByLevel(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleGetSpellsByLevel",
        }).Debug("entering handleGetSpellsByLevel")

        var req struct {
                Level int `json:"level"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleGetSpellsByLevel",
                        "error":    err.Error(),
                }).Error("failed to unmarshal get spells by level parameters")
                return nil, fmt.Errorf("invalid get spells by level parameters")
        }</span>

        <span class="cov0" title="0">if req.Level &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("spell level cannot be negative")
        }</span>

        <span class="cov0" title="0">spells := s.spellManager.GetSpellsByLevel(req.Level)

        logrus.WithFields(logrus.Fields{
                "function": "handleGetSpellsByLevel",
                "level":    req.Level,
                "count":    len(spells),
        }).Info("spells retrieved by level")

        return map[string]interface{}{
                "success": true,
                "spells":  spells,
                "count":   len(spells),
                "level":   req.Level,
        }, nil</span>
}

// handleGetSpellsBySchool retrieves all spells of a specific magic school.
//
// Parameters (JSON):
//   - school: string - The magic school name (e.g., "Evocation", "Illusion")
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if retrieval was successful
//   - spells: array of spell objects
//   - count: int number of spells found
//   - school: string the school name searched

func (s *RPCServer) handleGetSpellsBySchool(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleGetSpellsBySchool",
        }).Debug("entering handleGetSpellsBySchool")

        var req struct {
                School string `json:"school"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleGetSpellsBySchool",
                        "error":    err.Error(),
                }).Error("failed to unmarshal get spells by school parameters")
                return nil, fmt.Errorf("invalid get spells by school parameters")
        }</span>

        <span class="cov0" title="0">if req.School == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("school cannot be empty")
        }</span>

        <span class="cov0" title="0">school := game.ParseSpellSchool(req.School)
        spells := s.spellManager.GetSpellsBySchool(school)

        logrus.WithFields(logrus.Fields{
                "function": "handleGetSpellsBySchool",
                "school":   req.School,
                "count":    len(spells),
        }).Info("spells retrieved by school")

        return map[string]interface{}{
                "success": true,
                "spells":  spells,
                "count":   len(spells),
                "school":  req.School,
        }, nil</span>
}

// handleGetAllSpells retrieves all spells in the spell database.
//
// Parameters: None required
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if retrieval was successful
//   - spells: array of all spell objects
//   - count: int total number of spells
//   - by_level: map of spell counts by level
func (s *RPCServer) handleGetAllSpells(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleGetAllSpells",
        }).Debug("entering handleGetAllSpells")

        spells := s.spellManager.GetAllSpells()
        countsByLevel := s.spellManager.GetSpellCountByLevel()

        logrus.WithFields(logrus.Fields{
                "function": "handleGetAllSpells",
                "count":    len(spells),
        }).Info("all spells retrieved")

        return map[string]interface{}{
                "success":  true,
                "spells":   spells,
                "count":    len(spells),
                "by_level": countsByLevel,
        }, nil
}</span>

// handleSearchSpells searches for spells by name, description, or keywords.
//
// Parameters (JSON):
//   - query: string - The search query to match against spell names, descriptions, and keywords
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if search was successful
//   - spells: array of matching spell objects
//   - count: int number of spells found
//   - query: string the search query used
func (s *RPCServer) handleSearchSpells(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleSearchSpells",
        }).Debug("entering handleSearchSpells")

        var req struct {
                Query string `json:"query"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleSearchSpells",
                        "error":    err.Error(),
                }).Error("failed to unmarshal search spells parameters")
                return nil, fmt.Errorf("invalid search spells parameters")
        }</span>

        <span class="cov0" title="0">if req.Query == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("search query cannot be empty")
        }</span>

        <span class="cov0" title="0">spells := s.spellManager.SearchSpells(req.Query)

        logrus.WithFields(logrus.Fields{
                "function": "handleSearchSpells",
                "query":    req.Query,
                "count":    len(spells),
        }).Info("spell search completed")

        return map[string]interface{}{
                "success": true,
                "spells":  spells,
                "count":   len(spells),
                "query":   req.Query,
        }, nil</span>
}

// handleGetObjectsInRange processes a spatial query request for objects within a rectangular area.
//
// Parameters:
//   - params: json.RawMessage containing:
//   - session_id: string identifier for the player session
//   - min_x: int minimum X coordinate of query rectangle
//   - min_y: int minimum Y coordinate of query rectangle
//   - max_x: int maximum X coordinate of query rectangle
//   - max_y: int maximum Y coordinate of query rectangle
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if query was successful
//   - objects: Array of game objects within the specified range
//   - count: Number of objects found
//   - error: Possible errors:
//   - "invalid range query parameters" if JSON unmarshaling fails
//   - "invalid session" if session ID not found
func (s *RPCServer) handleGetObjectsInRange(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleGetObjectsInRange",
        }).Debug("entering range query handler")

        var req struct {
                SessionID string `json:"session_id"`
                MinX      int    `json:"min_x"`
                MinY      int    `json:"min_y"`
                MaxX      int    `json:"max_x"`
                MaxY      int    `json:"max_y"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("failed to unmarshal range query parameters")
                return map[string]interface{}{
                        "success": false,
                        "error":   "invalid range query parameters",
                }, nil
        }</span>

        <span class="cov8" title="1">session, exists := s.getSession(req.SessionID)
        if !exists </span><span class="cov8" title="1">{
                logrus.WithField("sessionID", req.SessionID).Warn("range query attempted with invalid session")
                return map[string]interface{}{
                        "success": false,
                        "error":   "invalid session",
                }, nil
        }</span>

        <span class="cov8" title="1">logger := logrus.WithFields(logrus.Fields{
                "sessionID": req.SessionID,
                "playerID":  session.Player.GetID(),
                "minX":      req.MinX,
                "minY":      req.MinY,
                "maxX":      req.MaxX,
                "maxY":      req.MaxY,
        })

        rect := game.Rectangle{
                MinX: req.MinX,
                MinY: req.MinY,
                MaxX: req.MaxX,
                MaxY: req.MaxY,
        }

        objects := s.state.WorldState.GetObjectsInRange(rect)
        logger.WithField("objectCount", len(objects)).Info("range query completed")

        return map[string]interface{}{
                "success": true,
                "objects": objects,
                "count":   len(objects),
        }, nil</span>
}

// handleGetObjectsInRadius processes a spatial query request for objects within a circular area.
//
// Parameters:
//   - params: json.RawMessage containing:
//   - session_id: string identifier for the player session
//   - center_x: int X coordinate of circle center
//   - center_y: int Y coordinate of query center
//   - radius: float64 radius of the search circle
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if query was successful
//   - objects: Array of game objects within the specified radius
//   - count: Number of objects found
//   - error: Possible errors:
//   - "invalid radius query parameters" if JSON unmarshaling fails
//   - "invalid session" if session ID not found
func (s *RPCServer) handleGetObjectsInRadius(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleGetObjectsInRadius",
        }).Debug("entering radius query handler")

        var req struct {
                SessionID string  `json:"session_id"`
                CenterX   int     `json:"center_x"`
                CenterY   int     `json:"center_y"`
                Radius    float64 `json:"radius"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("failed to unmarshal radius query parameters")
                return map[string]interface{}{
                        "success": false,
                        "error":   "invalid radius query parameters",
                }, nil
        }</span>

        <span class="cov8" title="1">session, exists := s.getSession(req.SessionID)
        if !exists </span><span class="cov0" title="0">{
                logrus.WithField("sessionID", req.SessionID).Warn("radius query attempted with invalid session")
                return map[string]interface{}{
                        "success": false,
                        "error":   "invalid session",
                }, nil
        }</span>

        <span class="cov8" title="1">logger := logrus.WithFields(logrus.Fields{
                "sessionID": req.SessionID,
                "playerID":  session.Player.GetID(),
                "centerX":   req.CenterX,
                "centerY":   req.CenterY,
                "radius":    req.Radius,
        })

        center := game.Position{X: req.CenterX, Y: req.CenterY}
        objects := s.state.WorldState.GetObjectsInRadius(center, req.Radius)
        logger.WithField("objectCount", len(objects)).Info("radius query completed")

        return map[string]interface{}{
                "success": true,
                "objects": objects,
                "count":   len(objects),
        }, nil</span>
}

// handleGetNearestObjects processes a spatial query request for the k nearest objects to a position.
//
// Parameters:
//   - params: json.RawMessage containing:
//   - session_id: string identifier for the player session
//   - center_x: int X coordinate of query center
//   - center_y: int Y coordinate of query center
//   - k: int maximum number of nearest objects to return
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if query was successful
//   - objects: Array of k nearest game objects
//   - count: Number of objects found (may be less than k)
//   - error: Possible errors:
//   - "invalid nearest query parameters" if JSON unmarshaling fails
//   - "invalid session" if session ID not found
func (s *RPCServer) handleGetNearestObjects(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleGetNearestObjects",
        }).Debug("entering nearest objects query handler")

        var req struct {
                SessionID string `json:"session_id"`
                CenterX   int    `json:"center_x"`
                CenterY   int    `json:"center_y"`
                K         int    `json:"k"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("failed to unmarshal nearest query parameters")
                return map[string]interface{}{
                        "success": false,
                        "error":   "invalid nearest query parameters",
                }, nil
        }</span>

        <span class="cov8" title="1">session, exists := s.getSession(req.SessionID)
        if !exists </span><span class="cov0" title="0">{
                logrus.WithField("sessionID", req.SessionID).Warn("nearest query attempted with invalid session")
                return map[string]interface{}{
                        "success": false,
                        "error":   "invalid session",
                }, nil
        }</span>

        <span class="cov8" title="1">logger := logrus.WithFields(logrus.Fields{
                "sessionID": req.SessionID,
                "playerID":  session.Player.GetID(),
                "centerX":   req.CenterX,
                "centerY":   req.CenterY,
                "k":         req.K,
        })

        center := game.Position{X: req.CenterX, Y: req.CenterY}
        objects := s.state.WorldState.GetNearestObjects(center, req.K)
        logger.WithField("objectCount", len(objects)).Info("nearest objects query completed")

        return map[string]interface{}{
                "success": true,
                "objects": objects,
                "count":   len(objects),
        }, nil</span>
}

// useItemRequest defines the structure for a use item request.
type useItemRequest struct {
        SessionID string `json:"session_id"`
        ItemID    string `json:"item_id"`
        TargetID  string `json:"target_id"`
}

// parseAndValidateUseItemRequest parses and validates the use item request.
func (s *RPCServer) parseAndValidateUseItemRequest(params json.RawMessage) (*useItemRequest, error) <span class="cov8" title="1">{
        var req useItemRequest
        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "parseAndValidateUseItemRequest",
                        "error":    err.Error(),
                }).Error("failed to unmarshal use item parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid use item parameters", err.Error())
        }</span>

        <span class="cov8" title="1">if req.SessionID == "" </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "parseAndValidateUseItemRequest",
                }).Warn("empty session ID")
                return nil, ErrInvalidSession
        }</span>

        <span class="cov8" title="1">if req.ItemID == "" </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function": "parseAndValidateUseItemRequest",
                }).Warn("empty item ID")
                return nil, fmt.Errorf("item ID is required")
        }</span>

        <span class="cov8" title="1">return &amp;req, nil</span>
}

// validateCombatTurnForItemUse checks if the player can use an item during combat.
func (s *RPCServer) validateCombatTurnForItemUse(player *game.Player) error <span class="cov8" title="1">{
        if s.state.TurnManager.IsInCombat </span><span class="cov8" title="1">{
                if !s.state.TurnManager.IsCurrentTurn(player.GetID()) </span><span class="cov8" title="1">{
                        logrus.WithFields(logrus.Fields{
                                "function": "validateCombatTurnForItemUse",
                                "playerID": player.GetID(),
                        }).Warn("player attempted to use item when not their turn")
                        return fmt.Errorf("not your turn")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// executeItemUsage contains the core logic for using an item.
func (s *RPCServer) executeItemUsage(player *game.Player, itemID, targetID string) (string, error) <span class="cov8" title="1">{
        item := findInventoryItem(player.Character.Inventory, itemID)
        if item == nil </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function": "executeItemUsage",
                        "itemID":   itemID,
                }).Error("failed to find item in inventory")
                return "", fmt.Errorf("item %s not found in inventory", itemID)
        }</span>

        <span class="cov8" title="1">effect := fmt.Sprintf("Used %s", item.Name)
        if targetID != "" </span><span class="cov8" title="1">{
                effect = fmt.Sprintf("Used %s on %s", item.Name, targetID)
        }</span>

        <span class="cov8" title="1">if item.Type == "consumable" </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function": "executeItemUsage",
                        "itemID":   itemID,
                }).Info("removing consumable item from inventory")
                // This is a simplified implementation. In a full implementation,
                // you would handle item quantities and removal properly.
        }</span>

        <span class="cov8" title="1">return effect, nil</span>
}

// handleUseItem processes a request to use an item from the player's inventory.
//
// Parameters:
//   - params: json.RawMessage containing:
//   - session_id: string identifier for the player session
//   - item_id: string identifier for the item to use
//   - target_id: string identifier for the target (player, NPC, etc.)
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if item use was successful
//   - effect: string describing the effect of using the item
//   - error: Possible errors:
//   - "invalid use item parameters" if JSON unmarshaling fails
//   - "invalid session" if session ID not found
//   - Item-specific validation errors
//
// Related:
//   - game.Item
//   - game.Inventory
//   - PlayerSession
func (s *RPCServer) handleUseItem(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleUseItem",
        }).Debug("entering handleUseItem")

        req, err := s.parseAndValidateUseItemRequest(params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := s.validateCombatTurnForItemUse(session.Player); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function":  "handleUseItem",
                "sessionID": req.SessionID,
                "itemID":    req.ItemID,
                "targetID":  req.TargetID,
        }).Info("using item from inventory")

        result, err := s.executeItemUsage(session.Player, req.ItemID, req.TargetID)
        if err != nil </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleUseItem",
                        "error":    err,
                }).Error("failed to use item")
                return nil, err
        }</span>

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function": "handleUseItem",
                "effect":   result,
        }).Info("item used successfully")
        return map[string]interface{}{"success": true, "effect": result}, nil</span>
}

// findInventoryItem searches for an item in the player's inventory by its ID.
func (s *RPCServer) findInventoryItem(player *game.Player, itemID string) (*game.Item, bool) <span class="cov0" title="0">{
        for _, item := range player.Character.Inventory </span><span class="cov0" title="0">{
                if item.ID == itemID </span><span class="cov0" title="0">{
                        return &amp;item, true
                }</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// handleLeaveGame processes a request to leave the game and end the session.
//
// Parameters:
//   - params: json.RawMessage containing:
//   - session_id: string identifier for the player session to end
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if leave operation was successful
//   - error: Possible errors:
//   - "invalid leave game parameters" if JSON unmarshaling fails
//   - "invalid session" if session ID not found
//
// Related:
//   - PlayerSession
//   - RPCServer.sessions
func (s *RPCServer) handleLeaveGame(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleLeaveGame",
        }).Debug("entering handleLeaveGame")

        var req struct {
                SessionID string `json:"session_id"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleLeaveGame",
                        "error":    err.Error(),
                }).Error("failed to unmarshal leave game parameters")
                return nil, fmt.Errorf("invalid leave game parameters")
        }</span>

        <span class="cov8" title="1">if req.SessionID == "" </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleLeaveGame",
                }).Warn("empty session ID")
                return nil, ErrInvalidSession
        }</span>

        <span class="cov8" title="1">s.mu.Lock()
        session, exists := s.sessions[req.SessionID]
        if exists </span><span class="cov8" title="1">{
                // Close WebSocket connection if it exists
                if session.WSConn != nil </span><span class="cov0" title="0">{
                        if err := session.WSConn.Close(); err != nil </span><span class="cov0" title="0">{
                                logrus.WithFields(logrus.Fields{
                                        "function":  "handleLeaveGame",
                                        "sessionID": req.SessionID,
                                        "error":     err.Error(),
                                }).Warn("failed to close WebSocket connection")
                        }</span>
                }

                // Close message channel
                <span class="cov8" title="1">if session.MessageChan != nil </span><span class="cov8" title="1">{
                        close(session.MessageChan)
                }</span>

                // Remove player from game state
                <span class="cov8" title="1">if session.Player != nil </span><span class="cov8" title="1">{
                        // Remove player from world state objects
                        if s.state.WorldState != nil &amp;&amp; s.state.WorldState.Objects != nil </span><span class="cov8" title="1">{
                                delete(s.state.WorldState.Objects, session.Player.GetID())
                        }</span>
                }

                // Remove session from sessions map
                <span class="cov8" title="1">delete(s.sessions, req.SessionID)

                logrus.WithFields(logrus.Fields{
                        "function":  "handleLeaveGame",
                        "sessionID": req.SessionID,
                }).Info("player left game and session removed")</span>
        }
        <span class="cov8" title="1">s.mu.Unlock()

        if !exists </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function":  "handleLeaveGame",
                        "sessionID": req.SessionID,
                }).Warn("session not found")
                return nil, ErrInvalidSession
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "success": true,
        }, nil</span>
}

// PCG (Procedural Content Generation) handlers

// handleGenerateContent generates procedural content on demand
func (s *RPCServer) handleGenerateContent(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleGenerateContent",
        }).Debug("entering handleGenerateContent")

        req, err := s.parseContentGenerationRequest(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">session, err := s.validateContentGenerationSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_ = session // Suppress unused variable warning

        if err := s.validateContentGenerationParameters(req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">s.applyContentGenerationDefaults(req)

        content, err := s.executeContentGeneration(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logContentGenerationSuccess(req)

        return s.buildContentGenerationResponse(req, content), nil</span>
}

// parseContentGenerationRequest extracts and validates content generation parameters from JSON.
func (s *RPCServer) parseContentGenerationRequest(params json.RawMessage) (*struct {
        SessionID   string                 `json:"session_id"`
        ContentType string                 `json:"content_type"`
        LocationID  string                 `json:"location_id"`
        Difficulty  int                    `json:"difficulty"`
        Constraints map[string]interface{} `json:"constraints"`
}, error) <span class="cov8" title="1">{
        var req struct {
                SessionID   string                 `json:"session_id"`
                ContentType string                 `json:"content_type"`
                LocationID  string                 `json:"location_id"`
                Difficulty  int                    `json:"difficulty"`
                Constraints map[string]interface{} `json:"constraints"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "parseContentGenerationRequest",
                        "error":    err.Error(),
                }).Error("failed to unmarshal content generation parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid content generation parameters", err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;req, nil</span>
}

// validateContentGenerationSession retrieves and validates the player session for content generation.
func (s *RPCServer) validateContentGenerationSession(sessionID string) (*PlayerSession, error) <span class="cov8" title="1">{
        session, err := s.getPlayerSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return session, nil</span>
}

// validateContentGenerationParameters checks that required content generation parameters are present.
func (s *RPCServer) validateContentGenerationParameters(req *struct {
        SessionID   string                 `json:"session_id"`
        ContentType string                 `json:"content_type"`
        LocationID  string                 `json:"location_id"`
        Difficulty  int                    `json:"difficulty"`
        Constraints map[string]interface{} `json:"constraints"`
}) error <span class="cov8" title="1">{
        if req.ContentType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("content_type parameter required")
        }</span>

        <span class="cov8" title="1">if req.LocationID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("location_id parameter required")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// applyContentGenerationDefaults sets default values for optional content generation parameters.
func (s *RPCServer) applyContentGenerationDefaults(req *struct {
        SessionID   string                 `json:"session_id"`
        ContentType string                 `json:"content_type"`
        LocationID  string                 `json:"location_id"`
        Difficulty  int                    `json:"difficulty"`
        Constraints map[string]interface{} `json:"constraints"`
}) <span class="cov8" title="1">{
        if req.Difficulty == 0 </span><span class="cov0" title="0">{
                req.Difficulty = 5 // Default difficulty
        }</span>
}

// executeContentGeneration performs the actual content generation based on content type.
func (s *RPCServer) executeContentGeneration(req *struct {
        SessionID   string                 `json:"session_id"`
        ContentType string                 `json:"content_type"`
        LocationID  string                 `json:"location_id"`
        Difficulty  int                    `json:"difficulty"`
        Constraints map[string]interface{} `json:"constraints"`
}) (interface{}, error) <span class="cov8" title="1">{
        ctx := context.Background()
        var content interface{}
        var err error

        switch pcg.ContentType(req.ContentType) </span>{
        case pcg.ContentTypeTerrain:<span class="cov0" title="0">
                content, err = s.pcgManager.GenerateTerrainForLevel(ctx, req.LocationID, 50, 50, pcg.BiomeDungeon, req.Difficulty)</span>
        case pcg.ContentTypeItems:<span class="cov0" title="0">
                content, err = s.pcgManager.GenerateItemsForLocation(ctx, req.LocationID, 3, pcg.RarityCommon, pcg.RarityRare, req.Difficulty)</span>
        case pcg.ContentTypeLevels:<span class="cov0" title="0">
                content, err = s.pcgManager.GenerateDungeonLevel(ctx, req.LocationID, 5, 15, pcg.ThemeClassic, req.Difficulty)</span>
        case pcg.ContentTypeQuests:<span class="cov8" title="1">
                content, err = s.pcgManager.GenerateQuestForArea(ctx, req.LocationID, pcg.QuestTypeFetch, req.Difficulty)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported content type: %s", req.ContentType)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return content, nil</span>
}

// logContentGenerationSuccess logs successful content generation with relevant details.
func (s *RPCServer) logContentGenerationSuccess(req *struct {
        SessionID   string                 `json:"session_id"`
        ContentType string                 `json:"content_type"`
        LocationID  string                 `json:"location_id"`
        Difficulty  int                    `json:"difficulty"`
        Constraints map[string]interface{} `json:"constraints"`
}) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function":    "executeContentGeneration",
                "sessionID":   req.SessionID,
                "contentType": req.ContentType,
                "locationID":  req.LocationID,
                "difficulty":  req.Difficulty,
        }).Info("content generated successfully")
}</span>

// buildContentGenerationResponse constructs the response map for successful content generation.
func (s *RPCServer) buildContentGenerationResponse(req *struct {
        SessionID   string                 `json:"session_id"`
        ContentType string                 `json:"content_type"`
        LocationID  string                 `json:"location_id"`
        Difficulty  int                    `json:"difficulty"`
        Constraints map[string]interface{} `json:"constraints"`
}, content interface{}) map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "success":      true,
                "content_type": req.ContentType,
                "location_id":  req.LocationID,
                "content":      content,
                "difficulty":   req.Difficulty,
        }
}</span>

// terrainRegenerationRequest defines the structure for terrain regeneration requests.
type terrainRegenerationRequest struct {
        SessionID    string  `json:"session_id"`
        LocationID   string  `json:"location_id"`
        Width        int     `json:"width"`
        Height       int     `json:"height"`
        BiomeType    string  `json:"biome_type"`
        Density      float64 `json:"density"`
        WaterLevel   float64 `json:"water_level"`
        Connectivity string  `json:"connectivity"`
}

// parseTerrainRegenerationRequest extracts and validates terrain regeneration parameters from JSON.
func (s *RPCServer) parseTerrainRegenerationRequest(params json.RawMessage) (*terrainRegenerationRequest, error) <span class="cov0" title="0">{
        var req terrainRegenerationRequest

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "parseTerrainRegenerationRequest",
                        "error":    err.Error(),
                }).Error("failed to unmarshal terrain regeneration parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid terrain parameters", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;req, nil</span>
}

// validateTerrainRegenerationRequest validates required parameters and session.
func (s *RPCServer) validateTerrainRegenerationRequest(req *terrainRegenerationRequest) error <span class="cov0" title="0">{
        session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_ = session // Suppress unused variable warning

        if req.LocationID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("location_id parameter required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// applyTerrainRegenerationDefaults sets default values for empty request fields.
func (s *RPCServer) applyTerrainRegenerationDefaults(req *terrainRegenerationRequest) <span class="cov0" title="0">{
        if req.Width == 0 </span><span class="cov0" title="0">{
                req.Width = 50
        }</span>
        <span class="cov0" title="0">if req.Height == 0 </span><span class="cov0" title="0">{
                req.Height = 50
        }</span>
        <span class="cov0" title="0">if req.BiomeType == "" </span><span class="cov0" title="0">{
                req.BiomeType = "forest"
        }</span>
        <span class="cov0" title="0">if req.Density == 0 </span><span class="cov0" title="0">{
                req.Density = 0.5
        }</span>
        <span class="cov0" title="0">if req.WaterLevel == 0 </span><span class="cov0" title="0">{
                req.WaterLevel = 0.3
        }</span>
        <span class="cov0" title="0">if req.Connectivity == "" </span><span class="cov0" title="0">{
                req.Connectivity = "moderate"
        }</span>
}

// executeTerrainGeneration performs the actual terrain generation using the PCG manager.
func (s *RPCServer) executeTerrainGeneration(req *terrainRegenerationRequest) (interface{}, error) <span class="cov0" title="0">{
        ctx := context.Background()
        biomeType := pcg.BiomeType(req.BiomeType)

        gameMap, err := s.pcgManager.GenerateTerrainForLevel(ctx, req.LocationID, req.Width, req.Height, biomeType, 5)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("terrain generation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return gameMap, nil</span>
}

// logTerrainRegenerationSuccess logs successful terrain generation with relevant details.
func (s *RPCServer) logTerrainRegenerationSuccess(req *terrainRegenerationRequest) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function":   "executeTerrainGeneration",
                "sessionID":  req.SessionID,
                "locationID": req.LocationID,
                "width":      req.Width,
                "height":     req.Height,
                "biomeType":  req.BiomeType,
        }).Info("terrain regenerated successfully")
}</span>

// buildTerrainRegenerationResponse constructs the response map for successful terrain generation.
func (s *RPCServer) buildTerrainRegenerationResponse(req *terrainRegenerationRequest, terrain interface{}) map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "success":     true,
                "location_id": req.LocationID,
                "terrain":     terrain,
                "width":       req.Width,
                "height":      req.Height,
                "biome_type":  req.BiomeType,
        }
}</span>

// handleRegenerateTerrain regenerates terrain for a specific area
func (s *RPCServer) handleRegenerateTerrain(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleRegenerateTerrain",
        }).Debug("entering handleRegenerateTerrain")

        req, err := s.parseTerrainRegenerationRequest(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.validateTerrainRegenerationRequest(req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">s.applyTerrainRegenerationDefaults(req)

        terrain, err := s.executeTerrainGeneration(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logTerrainRegenerationSuccess(req)

        return s.buildTerrainRegenerationResponse(req, terrain), nil</span>
}

// handleGenerateItems generates items for a location
func (s *RPCServer) handleGenerateItems(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleGenerateItems",
        }).Debug("entering handleGenerateItems")

        var req struct {
                SessionID   string   `json:"session_id"`
                LocationID  string   `json:"location_id"`
                Count       int      `json:"count"`
                MinRarity   string   `json:"min_rarity"`
                MaxRarity   string   `json:"max_rarity"`
                PlayerLevel int      `json:"player_level"`
                ItemTypes   []string `json:"item_types"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleGenerateItems",
                        "error":    err.Error(),
                }).Error("failed to unmarshal item generation parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid item generation parameters", err.Error())
        }</span>
        <span class="cov8" title="1">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_ = session // Suppress unused variable warning

        if req.LocationID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("location_id parameter required")
        }</span>

        // Set defaults
        <span class="cov8" title="1">if req.Count == 0 </span><span class="cov0" title="0">{
                req.Count = 3
        }</span>
        <span class="cov8" title="1">if req.MinRarity == "" </span><span class="cov0" title="0">{
                req.MinRarity = "common"
        }</span>
        <span class="cov8" title="1">if req.MaxRarity == "" </span><span class="cov0" title="0">{
                req.MaxRarity = "rare"
        }</span>
        <span class="cov8" title="1">if req.PlayerLevel == 0 </span><span class="cov0" title="0">{
                req.PlayerLevel = 5
        }</span>

        <span class="cov8" title="1">ctx := context.Background()

        // Convert rarity strings to PCG RarityTier
        minRarity := pcg.RarityTier(req.MinRarity)
        maxRarity := pcg.RarityTier(req.MaxRarity)

        items, err := s.pcgManager.GenerateItemsForLocation(ctx, req.LocationID, req.Count, minRarity, maxRarity, req.PlayerLevel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("item generation failed: %w", err)
        }</span>

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function":       "handleGenerateItems",
                "sessionID":      req.SessionID,
                "locationID":     req.LocationID,
                "count":          req.Count,
                "playerLevel":    req.PlayerLevel,
                "itemsGenerated": len(items),
        }).Info("items generated successfully")

        return map[string]interface{}{
                "success":     true,
                "location_id": req.LocationID,
                "items":       items,
                "count":       len(items),
        }, nil</span>
}

// handleGenerateLevel generates a complete level/dungeon
func (s *RPCServer) handleGenerateLevel(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleGenerateLevel",
        }).Debug("entering handleGenerateLevel")

        var req struct {
                SessionID     string `json:"session_id"`
                Width         int    `json:"width"`
                Height        int    `json:"height"`
                RoomCount     int    `json:"room_count"`
                Theme         string `json:"theme"`
                Difficulty    int    `json:"difficulty"`
                CorridorStyle string `json:"corridor_style"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleGenerateLevel",
                        "error":    err.Error(),
                }).Error("failed to unmarshal level generation parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid level generation parameters", err.Error())
        }</span>
        <span class="cov0" title="0">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_ = session // Suppress unused variable warning

        // Set defaults
        if req.Width == 0 </span><span class="cov0" title="0">{
                req.Width = 50
        }</span>
        <span class="cov0" title="0">if req.Height == 0 </span><span class="cov0" title="0">{
                req.Height = 50
        }</span>
        <span class="cov0" title="0">if req.RoomCount == 0 </span><span class="cov0" title="0">{
                req.RoomCount = 8
        }</span>
        <span class="cov0" title="0">if req.Theme == "" </span><span class="cov0" title="0">{
                req.Theme = "classic"
        }</span>
        <span class="cov0" title="0">if req.Difficulty == 0 </span><span class="cov0" title="0">{
                req.Difficulty = 5
        }</span>
        <span class="cov0" title="0">if req.CorridorStyle == "" </span><span class="cov0" title="0">{
                req.CorridorStyle = "straight"
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // Convert theme string to PCG LevelTheme
        theme := pcg.LevelTheme(req.Theme)

        level, err := s.pcgManager.GenerateDungeonLevel(ctx, "generated_level", 5, req.RoomCount, theme, req.Difficulty)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("level generation failed: %w", err)
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function":   "handleGenerateLevel",
                "sessionID":  req.SessionID,
                "width":      req.Width,
                "height":     req.Height,
                "roomCount":  req.RoomCount,
                "theme":      req.Theme,
                "difficulty": req.Difficulty,
        }).Info("level generated successfully")

        return map[string]interface{}{
                "success":        true,
                "level":          level,
                "width":          req.Width,
                "height":         req.Height,
                "room_count":     req.RoomCount,
                "theme":          req.Theme,
                "difficulty":     req.Difficulty,
                "corridor_style": req.CorridorStyle,
        }, nil</span>
}

// generateQuestRequest represents the request structure for quest generation.
type generateQuestRequest struct {
        SessionID     string `json:"session_id"`
        QuestType     string `json:"quest_type"`
        Difficulty    int    `json:"difficulty"`
        MinObjectives int    `json:"min_objectives"`
        MaxObjectives int    `json:"max_objectives"`
        RewardTier    string `json:"reward_tier"`
        NarrativeType string `json:"narrative_type"`
}

// handleGenerateQuest generates a procedural quest
func (s *RPCServer) handleGenerateQuest(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleGenerateQuest",
        }).Debug("entering handleGenerateQuest")

        req, err := s.parseQuestGenerationRequest(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.validateQuestGenerationSession(req.SessionID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">s.applyQuestGenerationDefaults(req)

        quest, err := s.executeQuestGeneration(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logQuestGenerationSuccess(req, quest)

        return s.buildQuestGenerationResponse(req, quest), nil</span>
}

// parseQuestGenerationRequest parses and validates the JSON request parameters.
func (s *RPCServer) parseQuestGenerationRequest(params json.RawMessage) (*generateQuestRequest, error) <span class="cov0" title="0">{
        var req generateQuestRequest

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "parseQuestGenerationRequest",
                        "error":    err.Error(),
                }).Error("failed to unmarshal quest generation parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid quest generation parameters", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;req, nil</span>
}

// validateQuestGenerationSession validates the session ID and retrieves the session.
func (s *RPCServer) validateQuestGenerationSession(sessionID string) error <span class="cov0" title="0">{
        session, err := s.getPlayerSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_ = session // Session is valid but not used in current implementation
        return nil</span>
}

// applyQuestGenerationDefaults sets default values for empty request fields.
func (s *RPCServer) applyQuestGenerationDefaults(req *generateQuestRequest) <span class="cov0" title="0">{
        if req.QuestType == "" </span><span class="cov0" title="0">{
                req.QuestType = "fetch"
        }</span>
        <span class="cov0" title="0">if req.Difficulty == 0 </span><span class="cov0" title="0">{
                req.Difficulty = 5
        }</span>
        <span class="cov0" title="0">if req.MinObjectives == 0 </span><span class="cov0" title="0">{
                req.MinObjectives = 1
        }</span>
        <span class="cov0" title="0">if req.MaxObjectives == 0 </span><span class="cov0" title="0">{
                req.MaxObjectives = 3
        }</span>
        <span class="cov0" title="0">if req.RewardTier == "" </span><span class="cov0" title="0">{
                req.RewardTier = "common"
        }</span>
        <span class="cov0" title="0">if req.NarrativeType == "" </span><span class="cov0" title="0">{
                req.NarrativeType = "linear"
        }</span>
}

// executeQuestGeneration performs the actual quest generation using the PCG manager.
func (s *RPCServer) executeQuestGeneration(req *generateQuestRequest) (*game.Quest, error) <span class="cov0" title="0">{
        ctx := context.Background()
        questType := pcg.QuestType(req.QuestType)

        quest, err := s.pcgManager.GenerateQuestForArea(ctx, "generated_quest_area", questType, req.Difficulty)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("quest generation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return quest, nil</span>
}

// logQuestGenerationSuccess logs successful quest generation with relevant details.
func (s *RPCServer) logQuestGenerationSuccess(req *generateQuestRequest, quest *game.Quest) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function":       "executeQuestGeneration",
                "sessionID":      req.SessionID,
                "questType":      req.QuestType,
                "difficulty":     req.Difficulty,
                "objectiveCount": len(quest.Objectives),
        }).Info("quest generated successfully")
}</span>

// buildQuestGenerationResponse constructs the response map for successful quest generation.
func (s *RPCServer) buildQuestGenerationResponse(req *generateQuestRequest, quest *game.Quest) map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "success":        true,
                "quest":          quest,
                "quest_type":     req.QuestType,
                "difficulty":     req.Difficulty,
                "min_objectives": req.MinObjectives,
                "max_objectives": req.MaxObjectives,
                "reward_tier":    req.RewardTier,
                "narrative_type": req.NarrativeType,
        }
}</span>

// handleGetPCGStats returns statistics about the PCG system
func (s *RPCServer) handleGetPCGStats(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleGetPCGStats",
        }).Debug("entering handleGetPCGStats")

        var req struct {
                SessionID string `json:"session_id"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleGetPCGStats",
                        "error":    err.Error(),
                }).Error("failed to unmarshal PCG stats parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid PCG stats parameters", err.Error())
        }</span>

        <span class="cov8" title="1">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_ = session // Suppress unused variable warning

        // Get PCG statistics
        stats := s.pcgManager.GetGenerationStatistics()

        logrus.WithFields(logrus.Fields{
                "function":  "handleGetPCGStats",
                "sessionID": req.SessionID,
        }).Info("PCG stats retrieved successfully")

        return map[string]interface{}{
                "success": true,
                "stats":   stats,
        }, nil</span>
}

// handleValidateContent validates generated content
func (s *RPCServer) handleValidateContent(params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "handleValidateContent",
        }).Debug("entering handleValidateContent")

        var req struct {
                SessionID   string      `json:"session_id"`
                ContentType string      `json:"content_type"`
                Content     interface{} `json:"content"`
                Strict      bool        `json:"strict"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleValidateContent",
                        "error":    err.Error(),
                }).Error("failed to unmarshal content validation parameters")
                return nil, NewJSONRPCError(JSONRPCInvalidParams, "Invalid content validation parameters", err.Error())
        }</span>

        <span class="cov8" title="1">session, err := s.getPlayerSession(req.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_ = session // Suppress unused variable warning

        if req.ContentType == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("content_type parameter required")
        }</span>

        <span class="cov8" title="1">if req.Content == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("content parameter required")
        }</span>

        // Validate content using PCG validator with type information
        <span class="cov8" title="1">validationResult, err := s.pcgManager.ValidateGeneratedContentWithType(req.Content, req.ContentType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("content validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function":         "handleValidateContent",
                "sessionID":        req.SessionID,
                "contentType":      req.ContentType,
                "validationResult": validationResult.IsValid(),
        }).Info("content validated successfully")

        return map[string]interface{}{
                "success":      true,
                "valid":        validationResult.IsValid(),
                "errors":       validationResult.Errors,
                "warnings":     validationResult.Warnings,
                "content_type": req.ContentType,
                "strict":       req.Strict,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package server

import (
        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// ADDED: calculateNewPosition computes a new position from current position and movement direction.
// It enforces world boundary constraints to prevent invalid coordinates.
//
// Movement rules:
// - Coordinates are clamped to world bounds [0, worldWidth) x [0, worldHeight)
// - Invalid movements (out of bounds) are ignored, returning current position
// - Direction mapping: North=-Y, South=+Y, East=+X, West=-X (screen coordinates)
//
// Parameters:
//   - current: Current position with X, Y coordinates
//   - direction: Movement direction (North, South, East, West)
//   - worldWidth: Maximum X coordinate (exclusive upper bound)
//   - worldHeight: Maximum Y coordinate (exclusive upper bound)
//
// Returns:
//   - game.Position: New position with boundary-constrained coordinates
//
// Boundary enforcement prevents characters from moving outside the game world.
func calculateNewPosition(current game.Position, direction game.Direction, worldWidth, worldHeight int) game.Position <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function":    "calculateNewPosition",
                "current":     current,
                "direction":   direction,
                "worldWidth":  worldWidth,
                "worldHeight": worldHeight,
        }).Debug("entering calculateNewPosition")

        newPos := current

        logrus.WithFields(logrus.Fields{
                "function": "calculateNewPosition",
        }).Info("calculating new position with bounds checking")

        switch direction </span>{
        case game.North:<span class="cov8" title="1">
                if newPos.Y-1 &gt;= 0 </span><span class="cov8" title="1">{
                        newPos.Y--
                }</span>
        case game.South:<span class="cov8" title="1">
                if newPos.Y+1 &lt; worldHeight </span><span class="cov8" title="1">{
                        newPos.Y++
                }</span>
        case game.East:<span class="cov8" title="1">
                if newPos.X+1 &lt; worldWidth </span><span class="cov8" title="1">{
                        newPos.X++
                }</span>
        case game.West:<span class="cov8" title="1">
                if newPos.X-1 &gt;= 0 </span><span class="cov8" title="1">{
                        newPos.X--
                }</span>
        }

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function": "calculateNewPosition",
                "newPos":   newPos,
        }).Debug("exiting calculateNewPosition")

        return newPos</span>
}

// calculateNewPositionUnchecked calculates a new position without bounds checking.
// This function is preserved for testing purposes and backward compatibility.
// Production code should use calculateNewPosition with proper bounds.
func calculateNewPositionUnchecked(current game.Position, direction game.Direction) game.Position <span class="cov8" title="1">{
        newPos := current

        switch direction </span>{
        case game.North:<span class="cov8" title="1">
                newPos.Y--</span>
        case game.South:<span class="cov8" title="1">
                newPos.Y++</span>
        case game.East:<span class="cov8" title="1">
                newPos.X++</span>
        case game.West:<span class="cov8" title="1">
                newPos.X--</span>
        }

        <span class="cov8" title="1">return newPos</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package server

import (
        "fmt"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// processEffectTick handles the execution of a single effect tick in the game state.
// It routes effect processing to appropriate handlers based on effect type.
//
// This function manages effect processing for:
// - Damage over time effects (poison, burning, bleeding)
// - Healing over time effects (regeneration)
// - Stat modification effects (buffs, debuffs)
//
// Parameters:
//   - effect: The effect to process (must not be nil)
//
// Returns:
//   - error: nil on success, error if effect is nil or type unsupported
//
// Processing flow:
// 1. Validates effect is not nil
// 2. Determines effect type
// 3. Routes to specific effect handler
// 4. Logs processing results
func (gs *GameState) processEffectTick(effect *game.Effect) error <span class="cov0" title="0">{
        if err := gs.validateEffectNotNil(effect); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch effect.Type </span>{
        case game.EffectDamageOverTime:<span class="cov0" title="0">
                return gs.handleDamageOverTimeEffect(effect)</span>
        case game.EffectHealOverTime:<span class="cov0" title="0">
                return gs.handleHealingOverTimeEffect(effect)</span>
        case game.EffectStatBoost, game.EffectStatPenalty:<span class="cov0" title="0">
                return gs.handleStatModificationEffect(effect)</span>
        default:<span class="cov0" title="0">
                logrus.WithFields(logrus.Fields{
                        "function": "processEffectTick",
                        "effectID": effect.ID,
                        "type":     effect.Type,
                }).Warn("unsupported effect type")
                return fmt.Errorf("unsupported effect type: %v", effect.Type)</span>
        }
}

// validateEffectNotNil checks that the provided effect is not nil.
func (gs *GameState) validateEffectNotNil(effect *game.Effect) error <span class="cov0" title="0">{
        if effect == nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "processEffectTick",
                }).Error("nil effect provided")
                return fmt.Errorf("effect is nil")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// handleDamageOverTimeEffect processes a damage over time effect.
func (gs *GameState) handleDamageOverTimeEffect(effect *game.Effect) error <span class="cov0" title="0">{
        err := gs.processDamageEffect(effect)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "processEffectTick",
                        "effectID": effect.ID,
                        "type":     effect.Type,
                        "error":    err,
                }).Error("failed to process damage effect")
        }</span>
        <span class="cov0" title="0">return err</span>
}

// handleHealingOverTimeEffect processes a healing over time effect.
func (gs *GameState) handleHealingOverTimeEffect(effect *game.Effect) error <span class="cov0" title="0">{
        err := gs.processHealEffect(effect)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "processEffectTick",
                        "effectID": effect.ID,
                        "type":     effect.Type,
                        "error":    err,
                }).Error("failed to process healing effect")
        }</span>
        <span class="cov0" title="0">return err</span>
}

// handleStatModificationEffect processes a stat boost or penalty effect.
func (gs *GameState) handleStatModificationEffect(effect *game.Effect) error <span class="cov0" title="0">{
        err := gs.processStatEffect(effect)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "processEffectTick",
                        "effectID": effect.ID,
                        "type":     effect.Type,
                        "error":    err,
                }).Error("failed to process stat modification effect")
        }</span>
        <span class="cov0" title="0">return err</span>
}

// ADDED: processDamageEffect applies damage over time effects to target characters.
// It handles HP reduction and ensures characters don't go below 0 HP.
//
// Processing steps:
// 1. Validates target exists in world state
// 2. Ensures target is a Character type
// 3. Applies damage based on effect magnitude
// 4. Clamps HP to minimum value of 0
// 5. Logs damage application results
//
// Parameters:
//   - effect: Damage effect containing target ID and magnitude
//
// Returns:
//   - error: nil on success, error if target invalid or not found
//
// Effect handling: Only processes Character objects, ignores other entity types
func (gs *GameState) processDamageEffect(effect *game.Effect) error <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "processDamageEffect",
        })
        logger.Debug("processing damage effect")

        target, exists := gs.WorldState.Objects[effect.TargetID]
        if !exists </span><span class="cov0" title="0">{
                logger.WithField("targetID", effect.TargetID).Error("invalid effect target")
                return fmt.Errorf("invalid effect target")
        }</span>

        <span class="cov0" title="0">if char, ok := target.(*game.Character); ok </span><span class="cov0" title="0">{
                damage := int(effect.Magnitude)
                char.HP -= damage
                if char.HP &lt; 0 </span><span class="cov0" title="0">{
                        char.HP = 0
                        logger.WithFields(logrus.Fields{
                                "targetID": effect.TargetID,
                                "damage":   damage,
                        }).Warn("character HP reduced to 0")
                }</span> else<span class="cov0" title="0"> {
                        logger.WithFields(logrus.Fields{
                                "targetID":    effect.TargetID,
                                "damage":      damage,
                                "remainingHP": char.HP,
                        }).Info("applied damage to character")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">logger.WithField("targetID", effect.TargetID).Error("target cannot receive damage")
        return fmt.Errorf("target cannot receive damage")</span>
}

// processHealEffect applies a healing effect to a target character in the game world.
// It increases the target's HP by the effect magnitude, up to their max HP.
//
// Parameters:
//   - effect: *game.Effect - The healing effect to process, must contain:
//   - TargetID: ID of the character to heal
//   - Magnitude: Amount of HP to heal
//
// Returns:
//   - error: Returns nil on success, or an error if:
//   - Target does not exist in world state
//   - Target is not a Character type
//
// Related:
//   - game.Character
//   - game.Effect
//   - GameState.WorldState
//
// ADDED: processHealEffect applies healing over time effects to target characters.
// It restores HP while respecting maximum HP limits and logs healing results.
//
// Processing steps:
// 1. Validates target exists in world state
// 2. Ensures target is a Character type
// 3. Applies healing based on effect magnitude
// 4. Clamps HP to character's maximum HP value
// 5. Logs healing amount and HP changes
//
// Parameters:
//   - effect: Healing effect containing target ID and magnitude
//
// Returns:
//   - error: nil on success, error if target invalid or not found
//
// Healing mechanics: Only affects Character objects, respects MaxHP boundaries
func (gs *GameState) processHealEffect(effect *game.Effect) error <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "processHealEffect",
        })
        logger.Debug("processing heal effect")

        target, exists := gs.WorldState.Objects[effect.TargetID]
        if !exists </span><span class="cov0" title="0">{
                logger.WithField("targetID", effect.TargetID).Error("invalid effect target")
                return fmt.Errorf("invalid effect target")
        }</span>

        <span class="cov0" title="0">if char, ok := target.(*game.Character); ok </span><span class="cov0" title="0">{
                healAmount := int(effect.Magnitude)
                oldHP := char.HP
                char.HP = min(char.HP+healAmount, char.MaxHP)
                logger.WithFields(logrus.Fields{
                        "targetID":   effect.TargetID,
                        "healAmount": healAmount,
                        "oldHP":      oldHP,
                        "newHP":      char.HP,
                }).Info("healed character")
                return nil
        }</span>

        <span class="cov0" title="0">logger.WithField("targetID", effect.TargetID).Error("target cannot be healed")
        return fmt.Errorf("target cannot be healed")</span>
}

// ProcessStatEffect applies a stat modification effect to a character target.
//
// Parameters:
//   - effect: *game.Effect - Contains the target ID, stat to modify, and magnitude
//     of the modification. Must have valid StatAffected and Magnitude fields.
//
// Returns:
//
//        error - Returns nil if successful, or an error if:
//        - Target ID doesn't exist in WorldState
//        - Target is not a Character type
//        - StatAffected is not a valid stat name
//
// StatAffected must be one of: strength, dexterity, constitution, intelligence,
// wisdom, charisma
//
// Related types:
//   - game.Effect
//   - game.Character
//
// ADDED: processStatEffect applies stat modification effects to target characters.
// It handles both stat boosts and penalties by modifying character attributes.
//
// Supported stats: strength, dexterity, constitution, intelligence, wisdom, charisma
// Effect types: EffectStatBoost (positive) and EffectStatPenalty (negative)
//
// Processing steps:
// 1. Validates target exists and is a Character
// 2. Determines effect sign (boost vs penalty)
// 3. Applies magnitude to specified stat
// 4. Logs stat modification results
//
// Note: Stat modifications are applied directly to Character fields
func (gs *GameState) processStatEffect(effect *game.Effect) error <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "processStatEffect",
        })
        logger.Debug("processing stat effect")

        target, exists := gs.WorldState.Objects[effect.TargetID]
        if !exists </span><span class="cov0" title="0">{
                logger.WithField("targetID", effect.TargetID).Error("invalid effect target")
                return fmt.Errorf("invalid effect target")
        }</span>

        <span class="cov0" title="0">if char, ok := target.(*game.Character); ok </span><span class="cov0" title="0">{
                magnitude := int(effect.Magnitude)
                logger.WithFields(logrus.Fields{
                        "function":  "processStatEffect",
                        "targetID":  effect.TargetID,
                        "stat":      effect.StatAffected,
                        "magnitude": magnitude,
                }).Info("applying stat modification")

                switch effect.StatAffected </span>{
                case "strength":<span class="cov0" title="0">
                        char.Strength += magnitude</span>
                case "dexterity":<span class="cov0" title="0">
                        char.Dexterity += magnitude</span>
                case "constitution":<span class="cov0" title="0">
                        char.Constitution += magnitude</span>
                case "intelligence":<span class="cov0" title="0">
                        char.Intelligence += magnitude</span>
                case "wisdom":<span class="cov0" title="0">
                        char.Wisdom += magnitude</span>
                case "charisma":<span class="cov0" title="0">
                        char.Charisma += magnitude</span>
                default:<span class="cov0" title="0">
                        logger.WithField("stat", effect.StatAffected).Error("unknown stat type")
                        return fmt.Errorf("unknown stat type: %s", effect.StatAffected)</span>
                }
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">logger.WithField("targetID", effect.TargetID).Error("target cannot receive stat effects")
        return fmt.Errorf("target cannot receive stat effects")</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package server

import (
        "context"
        "encoding/json"
        "fmt"
        "net"
        "net/http"
        "os"
        "sync"
        "time"

        "github.com/sirupsen/logrus"

        "goldbox-rpg/pkg/game"
        "goldbox-rpg/pkg/pcg"
        "goldbox-rpg/pkg/pcg/items"
        "goldbox-rpg/pkg/pcg/quests"
)

// JSON-RPC 2.0 error codes
const (
        // Standard JSON-RPC 2.0 error codes
        JSONRPCParseError     = -32700 // Invalid JSON was received by the server
        JSONRPCInvalidRequest = -32600 // The JSON sent is not a valid Request object
        JSONRPCMethodNotFound = -32601 // The method does not exist / is not available
        JSONRPCInvalidParams  = -32602 // Invalid method parameter(s)
        JSONRPCInternalError  = -32603 // Internal JSON-RPC error
)

// Custom error types for JSON-RPC error handling
type JSONRPCError struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
}

func (e *JSONRPCError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// NewJSONRPCError creates a new JSON-RPC error with the specified code and message
func NewJSONRPCError(code int, message string, data interface{}) *JSONRPCError <span class="cov0" title="0">{
        return &amp;JSONRPCError{
                Code:    code,
                Message: message,
                Data:    data,
        }
}</span>

// Session configuration constants are defined in constants.go

// RPCServer represents the main RPC server instance that handles game state and player sessions.
// It provides functionality for managing game state, player sessions, and event handling.
//
// Fields:
//   - state: Pointer to GameState that maintains the current game state
//   - eventSys: Pointer to game.EventSystem for handling game events
//   - mu: RWMutex for thread-safe access to server resources
//   - timekeeper: Pointer to TimeManager for managing game time and scheduling
//   - sessions: Map of player session IDs to PlayerSession objects
//
// Related types:
//   - GameState
//   - game.EventSystem
//   - TimeManager
//   - PlayerSession
/*type RPCServer struct {
        webDir     string
        fileServer http.Handler
        state      *GameState
        eventSys   *game.EventSystem
        mu         sync.RWMutex
        timekeeper *TimeManager
        sessions   map[string]*PlayerSession
}*/

// RPCServer handles RPC requests and maintains game state.
type RPCServer struct {
        webDir       string
        fileServer   http.Handler
        state        *GameState
        eventSys     *game.EventSystem
        mu           sync.RWMutex
        timekeeper   *TimeManager
        sessions     map[string]*PlayerSession
        done         chan struct{}
        spellManager *game.SpellManager
        pcgManager   *pcg.PCGManager       // Procedural content generation manager
        Addr         net.Addr              // Address the server is listening on
        broadcaster  *WebSocketBroadcaster // WebSocket event broadcaster
}

// NewRPCServer creates and initializes a new RPCServer instance with default configuration.
// It sets up the core game systems including:
//   - World state management
//   - Turn-based gameplay handling
//   - Time tracking and management
//   - Player session tracking
//
// Returns:
//   - *RPCServer: A fully initialized server instance ready to handle RPC requests
//
// Related types:
//   - GameState: Contains the core game state
//   - TurnManager: Manages turn order and progression
//   - TimeManager: Handles in-game time tracking
//   - PlayerSession: Tracks individual player connections
//   - EventSystem: Handles game event dispatching
func NewRPCServer(webDir string) (*RPCServer, error) <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "NewRPCServer",
                "webDir":   webDir,
        })
        logger.Debug("entering NewRPCServer")

        // Initialize spell manager - find spells directory relative to project root
        wd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to get working directory")
                return nil, fmt.Errorf("failed to get working directory: %w", err)
        }</span>

        // Look for data/spells from current directory or walk up to find project root
        <span class="cov8" title="1">spellsDir := "data/spells"
        if _, err := os.Stat(spellsDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                // Try relative to project root (for tests running from pkg/server)
                spellsDir = "../../data/spells"
                if _, err := os.Stat(spellsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        logger.WithFields(logrus.Fields{
                                "workingDir": wd,
                                "attempted1": "data/spells",
                                "attempted2": "../../data/spells",
                        }).Error("could not find spells directory")
                        return nil, fmt.Errorf("spells directory not found from working directory: %s", wd)
                }</span>
        }

        <span class="cov8" title="1">spellManager := game.NewSpellManager(spellsDir)

        // Load spells from YAML files
        if err := spellManager.LoadSpells(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to load spells - server cannot start without spell data")
                return nil, err
        }</span>
        <span class="cov8" title="1">logger.WithField("spellCount", spellManager.GetSpellCount()).Info("loaded spells from YAML files")
        // Initialize PCG manager
        pcgManager := pcg.NewPCGManager(game.CreateDefaultWorld(), logrus.StandardLogger())
        pcgManager.InitializeWithSeed(time.Now().UnixNano()) // Use current time as seed

        // Register available generators
        questGen := quests.NewObjectiveBasedGenerator()
        if err := pcgManager.GetRegistry().RegisterGenerator("objective_based", questGen); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to register quest generator")
                return nil, fmt.Errorf("failed to register quest generator: %w", err)
        }</span>

        <span class="cov8" title="1">itemGen := items.NewTemplateBasedGenerator()
        if err := pcgManager.GetRegistry().RegisterGenerator("template_based", itemGen); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to register item generator")
                return nil, fmt.Errorf("failed to register item generator: %w", err)
        }</span>

        // Call RegisterDefaultGenerators to complete initialization
        <span class="cov8" title="1">if err := pcgManager.RegisterDefaultGenerators(); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to register default generators")
                return nil, fmt.Errorf("failed to register default generators: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Info("initialized PCG manager with default generators")

        // Create server with default world
        server := &amp;RPCServer{
                webDir:     webDir,
                fileServer: http.FileServer(http.Dir(webDir)),
                state: &amp;GameState{
                        WorldState:  game.CreateDefaultWorld(), // Use default world
                        TurnManager: NewTurnManager(),
                        TimeManager: NewTimeManager(),
                        Sessions:    make(map[string]*PlayerSession),
                        Version:     1,
                },
                eventSys:     game.NewEventSystem(),
                sessions:     make(map[string]*PlayerSession),
                timekeeper:   NewTimeManager(),
                done:         make(chan struct{}),
                spellManager: spellManager,
                pcgManager:   pcgManager,
        }

        // Initialize and start WebSocket broadcaster
        server.broadcaster = NewWebSocketBroadcaster(server)
        server.broadcaster.Start()

        server.startSessionCleanup()

        logger.WithField("server", server).Info("initialized new RPC server")
        logger.Debug("exiting NewRPCServer")
        return server, nil</span>
}

// ServeHTTP handles incoming JSON-RPC requests over HTTP, implementing the http.Handler interface.
// It processes POST requests only and expects a JSON-RPC 2.0 formatted request body.
//
// Parameters:
//   - w http.ResponseWriter: The response writer for sending the HTTP response
//   - r *http.Request: The incoming HTTP request containing the JSON-RPC payload
//
// The request body should contain a JSON object with:
//   - jsonrpc: String specifying the JSON-RPC version (must be "2.0")
//   - method: The RPC method name to invoke
//   - params: The parameters for the method (as raw JSON)
//   - id: Request identifier that will be echoed back in the response
//
// Error handling:
//   - Returns 405 Method Not Allowed if request is not POST
//   - Returns JSON-RPC error code -32700 for invalid JSON
//   - Returns JSON-RPC error code -32603 for internal errors during method execution
//
// Related:
//   - handleMethod: Processes the individual RPC method calls
//   - writeResponse: Formats and sends successful responses
//   - writeError: Formats and sends error responses
//
// ADDED: ServeHTTP implements the http.Handler interface for processing HTTP requests.
// It handles both static file serving and JSON-RPC method calls with session management.
//
// Request routing:
// - WebSocket upgrade requests: Routed to HandleWebSocket
// - Static file requests: Served from configured web directory
// - JSON-RPC requests: Parsed and routed to appropriate method handlers
//
// Session management: Automatically creates or retrieves player sessions
// Error handling: Returns proper JSON-RPC error codes for various failure scenarios
func (s *RPCServer) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "ServeHTTP",
                "method":   r.Method,
                "url":      r.URL.String(),
        })
        logger.Debug("entering ServeHTTP")

        // Handle health check endpoint first
        if r.URL.Path == "/health" &amp;&amp; r.Method == http.MethodGet </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                response := map[string]interface{}{
                        "status": "healthy",
                        "service": "goldbox-rpg-api",
                        "timestamp": time.Now().UTC().Format(time.RFC3339),
                }
                if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to encode health response")
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">session, err := s.getOrCreateSession(w, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("session creation failed")
                writeError(w, JSONRPCInternalError, "Internal error", nil)
                return
        }</span>
        <span class="cov0" title="0">defer s.releaseSession(session)

        ctx := context.WithValue(r.Context(), sessionKey, session)
        r = r.WithContext(ctx)

        if r.Header.Get("Upgrade") == "websocket" </span><span class="cov0" title="0">{
                s.HandleWebSocket(w, r)
                return
        }</span>

        <span class="cov0" title="0">if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                logger.Info("serving static file")
                s.fileServer.ServeHTTP(w, r)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                JSONRPC string          `json:"jsonrpc"`
                Method  RPCMethod       `json:"method"`
                Params  json.RawMessage `json:"params"`
                ID      interface{}     `json:"id"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to decode request body")
                writeError(w, JSONRPCParseError, "Parse error", nil)
                return
        }</span>

        // Validate JSON-RPC request structure
        <span class="cov0" title="0">if req.JSONRPC != "2.0" </span><span class="cov0" title="0">{
                logger.Error("invalid JSON-RPC version")
                writeError(w, JSONRPCInvalidRequest, "Invalid Request", "JSON-RPC version must be 2.0")
                return
        }</span>

        <span class="cov0" title="0">if req.Method == "" </span><span class="cov0" title="0">{
                logger.Error("missing method in request")
                writeError(w, JSONRPCInvalidRequest, "Invalid Request", "Method field is required")
                return
        }</span>

        <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                "rpcMethod": req.Method,
                "requestId": req.ID,
        }).Info("handling RPC method")

        // Handle the RPC method
        result, err := s.handleMethod(req.Method, req.Params)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("method handler failed")

                // Check if it's a custom JSON-RPC error
                if jsonRPCErr, ok := err.(*JSONRPCError); ok </span><span class="cov0" title="0">{
                        writeError(w, jsonRPCErr.Code, jsonRPCErr.Message, jsonRPCErr.Data)
                }</span> else<span class="cov0" title="0"> {
                        // Default to internal error for other errors
                        writeError(w, JSONRPCInternalError, err.Error(), nil)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Write successful response
        <span class="cov0" title="0">writeResponse(w, result, req.ID)
        logger.Debug("exiting ServeHTTP")</span>
}

// handleMethod processes an RPC method call with the given parameters and returns the appropriate response.
// It uses a mutex to ensure thread-safe access to shared resources.
//
// Parameters:
//   - method: RPCMethod - The RPC method to be executed (e.g. MethodMove, MethodAttack, etc)
//   - params: json.RawMessage - The raw JSON parameters for the method call
//
// Returns:
//   - interface{} - The result of the method execution
//   - error - Any error that occurred during execution
//
// Error cases:
//   - Returns error if the method is not recognized
//
// Related methods:
//   - handleMove
//   - handleAttack
//   - handleCastSpell
//   - handleApplyEffect
//   - handleStartCombat
//   - handleEndTurn
//   - handleGetGameState
//
// ADDED: handleMethod routes RPC method calls to their appropriate handler functions.
// It serves as the central dispatcher for all game-related RPC operations.
//
// Supported method categories:
// - Character actions: move, attack, castSpell, useItem
// - Combat management: startCombat, endTurn
// - Equipment: equipItem, unequipItem, getEquipment
// - Quest system: startQuest, completeQuest, failQuest, etc.
// - Spell queries: getSpell, getSpellsByLevel, etc.
// - Spatial queries: getObjectsInRange, getNearestObjects
// - Game state: getGameState, joinGame, leaveGame
//
// All handlers receive JSON-encoded parameters and return serializable results.
func (s *RPCServer) handleMethod(method RPCMethod, params json.RawMessage) (interface{}, error) <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "handleMethod",
                "method":   method,
        })
        logger.Debug("entering handleMethod")

        var result interface{}
        var err error

        switch method </span>{
        case MethodJoinGame:<span class="cov0" title="0">
                logger.Info("handling join game method")
                result, err = s.handleJoinGame(params)</span>
        case MethodCreateCharacter:<span class="cov0" title="0">
                logger.Info("handling create character method")
                result, err = s.handleCreateCharacter(params)</span>
        case MethodMove:<span class="cov0" title="0">
                logger.Info("handling move method")
                result, err = s.handleMove(params)</span>
        case MethodAttack:<span class="cov0" title="0">
                logger.Info("handling attack method")
                result, err = s.handleAttack(params)</span>
        case MethodCastSpell:<span class="cov0" title="0">
                logger.Info("handling cast spell method")
                result, err = s.handleCastSpell(params)</span>
        case MethodApplyEffect:<span class="cov0" title="0">
                logger.Info("handling apply effect method")
                result, err = s.handleApplyEffect(params)</span>
        case MethodStartCombat:<span class="cov0" title="0">
                logger.Info("handling start combat method")
                result, err = s.handleStartCombat(params)</span>
        case MethodEndTurn:<span class="cov0" title="0">
                logger.Info("handling end turn method")
                result, err = s.handleEndTurn(params)</span>
        case MethodGetGameState:<span class="cov0" title="0">
                logger.Info("handling get game state method")
                result, err = s.handleGetGameState(params)</span>
        case MethodEquipItem:<span class="cov0" title="0">
                logger.Info("handling equip item method")
                result, err = s.handleEquipItem(params)</span>
        case MethodUnequipItem:<span class="cov0" title="0">
                logger.Info("handling unequip item method")
                result, err = s.handleUnequipItem(params)</span>
        case MethodGetEquipment:<span class="cov0" title="0">
                logger.Info("handling get equipment method")
                result, err = s.handleGetEquipment(params)</span>
        case MethodStartQuest:<span class="cov0" title="0">
                logger.Info("handling start quest method")
                result, err = s.handleStartQuest(params)</span>
        case MethodCompleteQuest:<span class="cov0" title="0">
                logger.Info("handling complete quest method")
                result, err = s.handleCompleteQuest(params)</span>
        case MethodUpdateObjective:<span class="cov0" title="0">
                logger.Info("handling update objective method")
                result, err = s.handleUpdateObjective(params)</span>
        case MethodFailQuest:<span class="cov0" title="0">
                logger.Info("handling fail quest method")
                result, err = s.handleFailQuest(params)</span>
        case MethodGetQuest:<span class="cov0" title="0">
                logger.Info("handling get quest method")
                result, err = s.handleGetQuest(params)</span>
        case MethodGetActiveQuests:<span class="cov0" title="0">
                logger.Info("handling get active quests method")
                result, err = s.handleGetActiveQuests(params)</span>
        case MethodGetCompletedQuests:<span class="cov0" title="0">
                logger.Info("handling get completed quests method")
                result, err = s.handleGetCompletedQuests(params)</span>
        case MethodGetQuestLog:<span class="cov0" title="0">
                logger.Info("handling get quest log method")
                result, err = s.handleGetQuestLog(params)</span>
        case MethodGetSpell:<span class="cov0" title="0">
                logger.Info("handling get spell method")
                result, err = s.handleGetSpell(params)</span>
        case MethodGetSpellsByLevel:<span class="cov0" title="0">
                logger.Info("handling get spells by level method")
                result, err = s.handleGetSpellsByLevel(params)</span>
        case MethodGetSpellsBySchool:<span class="cov0" title="0">
                logger.Info("handling get spells by school method")
                result, err = s.handleGetSpellsBySchool(params)</span>
        case MethodGetAllSpells:<span class="cov0" title="0">
                logger.Info("handling get all spells method")
                result, err = s.handleGetAllSpells(params)</span>
        case MethodSearchSpells:<span class="cov0" title="0">
                logger.Info("handling search spells method")
                result, err = s.handleSearchSpells(params)</span>
        case MethodGetObjectsInRange:<span class="cov0" title="0">
                logger.Info("handling get objects in range method")
                result, err = s.handleGetObjectsInRange(params)</span>
        case MethodGetObjectsInRadius:<span class="cov0" title="0">
                logger.Info("handling get objects in radius method")
                result, err = s.handleGetObjectsInRadius(params)</span>
        case MethodGetNearestObjects:<span class="cov0" title="0">
                logger.Info("handling get nearest objects method")
                result, err = s.handleGetNearestObjects(params)</span>
        case MethodUseItem:<span class="cov8" title="1">
                logger.Info("handling use item method")
                result, err = s.handleUseItem(params)</span>
        case MethodLeaveGame:<span class="cov8" title="1">
                logger.Info("handling leave game method")
                result, err = s.handleLeaveGame(params)</span>
        case MethodGenerateContent:<span class="cov0" title="0">
                logger.Info("handling generate content method")
                result, err = s.handleGenerateContent(params)</span>
        case MethodRegenerateTerrain:<span class="cov0" title="0">
                logger.Info("handling regenerate terrain method")
                result, err = s.handleRegenerateTerrain(params)</span>
        case MethodGenerateItems:<span class="cov0" title="0">
                logger.Info("handling generate items method")
                result, err = s.handleGenerateItems(params)</span>
        case MethodGenerateLevel:<span class="cov0" title="0">
                logger.Info("handling generate level method")
                result, err = s.handleGenerateLevel(params)</span>
        case MethodGenerateQuest:<span class="cov0" title="0">
                logger.Info("handling generate quest method")
                result, err = s.handleGenerateQuest(params)</span>
        case MethodGetPCGStats:<span class="cov0" title="0">
                logger.Info("handling get PCG stats method")
                result, err = s.handleGetPCGStats(params)</span>
        case MethodValidateContent:<span class="cov0" title="0">
                logger.Info("handling validate content method")
                result, err = s.handleValidateContent(params)</span>
        default:<span class="cov0" title="0">
                err = NewJSONRPCError(JSONRPCMethodNotFound, fmt.Sprintf("Method not found: %s", method), nil)
                logger.WithError(err).Error("unknown method")
                return nil, err</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("method handler failed")
                return nil, err
        }</span>

        <span class="cov8" title="1">logger.WithField("result", result).Debug("exiting handleMethod")
        return result, nil</span>
}

// writeResponse writes a JSON-RPC 2.0 compliant response to the http.ResponseWriter
//
// Parameters:
//   - w http.ResponseWriter: The response writer to write the JSON response to
//   - result interface{}: The result payload to include in the response
//   - id interface{}: The JSON-RPC request ID to correlate the response
//
// The function sets the Content-Type header to application/json and writes a JSON object
// containing the JSON-RPC version (2.0), the result, and the request ID.
//
// No error handling is currently implemented - errors from json.Encode are silently ignored.
// Consider adding error handling in production code.
//
// Related:
// - JSON-RPC 2.0 Specification: https://www.jsonrpc.org/specification
func writeResponse(w http.ResponseWriter, result, id interface{}) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "writeResponse",
        })
        logger.Debug("entering writeResponse")

        response := struct {
                JSONRPC string      `json:"jsonrpc"`
                Result  interface{} `json:"result"`
                ID      interface{} `json:"id"`
        }{
                JSONRPC: "2.0",
                Result:  result,
                ID:      id,
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to encode response")
                return
        }</span>

        <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                "response": response,
        }).Info("wrote response")
        logger.Debug("exiting writeResponse")</span>
}

// writeError writes a JSON-RPC 2.0 error response to the provided http.ResponseWriter
//
// Parameters:
//   - w http.ResponseWriter: The response writer to write the error to
//   - code int: The error code to include in the response
//   - message string: The error message to include in the response
//   - data interface{}: Optional additional error data (will be omitted if nil)
//
// The function writes the error as a JSON object with the following structure:
//
//        {
//          "jsonrpc": "2.0",
//          "error": {
//            "code": &lt;code&gt;,
//            "message": &lt;message&gt;,
//            "data": &lt;data&gt;  // Optional
//          },
//          "id": null
//        }
//
// The Content-Type header is set to application/json
func writeError(w http.ResponseWriter, code int, message string, data interface{}) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "writeError",
                "code":     code,
                "message":  message,
        })
        logger.Debug("entering writeError")

        response := struct {
                JSONRPC string `json:"jsonrpc"`
                Error   struct {
                        Code    int         `json:"code"`
                        Message string      `json:"message"`
                        Data    interface{} `json:"data,omitempty"`
                } `json:"error"`
                ID interface{} `json:"id"`
        }{
                JSONRPC: "2.0",
                Error: struct {
                        Code    int         `json:"code"`
                        Message string      `json:"message"`
                        Data    interface{} `json:"data,omitempty"`
                }{
                        Code:    code,
                        Message: message,
                        Data:    data,
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to encode error response")
                return
        }</span>

        <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                "response": response,
        }).Info("wrote error response")
        logger.Debug("exiting writeError")</span>
}

// Stop gracefully shuts down the RPC server by closing the done channel.
// This signals background goroutines and services to terminate cleanly.
//
// The done channel is used for coordinating shutdown across:
// - Session cleanup routines
// - Background processing tasks
// - Event system cleanup
//
// This method should be called before process termination to ensure clean shutdown.
func (s *RPCServer) Stop() <span class="cov8" title="1">{
        close(s.done)
}</span>

// Serve starts the HTTP server on the provided listener and begins handling requests.
// It configures the HTTP server and starts listening for incoming connections.
//
// Parameters:
//   - listener: Network listener to accept connections on (e.g., TCP, Unix socket)
//
// Returns:
//   - error: nil on clean shutdown, error if server fails to start or encounters issues
//
// Server lifecycle:
// 1. Sets the server address from the listener
// 2. Creates HTTP server with RPCServer as handler
// 3. Starts serving requests until Stop() is called or error occurs
// 4. Handles graceful shutdown scenarios
//
// The server will continue running until Stop() is called or a fatal error occurs.
func (s *RPCServer) Serve(listener net.Listener) error <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "Serve",
                "address":  listener.Addr().String(),
        })
        s.Addr = listener.Addr()
        logger.Info("starting RPC server")

        srv := &amp;http.Server{
                Handler: s,
        }

        if err := srv.Serve(listener); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                logger.WithError(err).Error("server failed")
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("RPC server stopped")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package server

import (
        "net/http"
        "time"

        "github.com/google/uuid"
        "github.com/sirupsen/logrus"
)

// Session configuration constants are defined in constants.go

// safeSendMessage attempts to send a message to a session's MessageChan without blocking.
// If the channel is full, it logs a warning and drops the message to prevent resource exhaustion.
//
// Parameters:
//   - session: The player session to send the message to
//   - message: The message bytes to send
//
// Returns:
//   - bool: true if message was sent successfully, false if dropped due to full channel
func safeSendMessage(session *PlayerSession, message []byte) bool <span class="cov8" title="1">{
        if session == nil || session.MessageChan == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">select </span>{
        case session.MessageChan &lt;- message:<span class="cov8" title="1">
                return true</span>
        case &lt;-time.After(MessageSendTimeout):<span class="cov8" title="1">
                logrus.WithFields(logrus.Fields{
                        "sessionID": session.SessionID,
                        "function":  "safeSendMessage",
                }).Warn("Message dropped: channel full or timeout reached")
                return false</span>
        }
}

// getOrCreateSession handles session management for HTTP requests by either retrieving an existing
// session or creating a new one. It maintains user sessions through cookies and ensures thread-safe
// access to the sessions map.
//
// Parameters:
//   - w http.ResponseWriter: The response writer to set session cookies
//   - r *http.Request: The incoming HTTP request containing potential session cookies
//
// Returns:
//   - *PlayerSession: A pointer to either the existing or newly created session
//   - error: Error if session handling fails
//
// The function performs the following:
// 1. Checks for existing session cookie
// 2. If found and valid, returns the existing session
// 3. If not found or invalid, creates new session with UUID
// 4. Sets session cookie in response
// 5. Updates LastActive timestamp
//
// Thread-safety is ensured via mutex locking of the sessions map.
// Sessions expire after 30 minutes as set in cookie MaxAge and sessionTimeout constant.
//
// Related types:
//   - PlayerSession struct
//   - RPCServer struct
func (s *RPCServer) getOrCreateSession(w http.ResponseWriter, r *http.Request) (*PlayerSession, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "func": "getOrCreateSession",
                "path": r.URL.Path,
        }).Debug("Starting session handling")

        s.mu.Lock()
        defer s.mu.Unlock()

        cookie, err := r.Cookie("session_id")
        if err == nil </span><span class="cov8" title="1">{
                if session, exists := s.sessions[cookie.Value]; exists </span><span class="cov8" title="1">{
                        session.LastActive = time.Now()
                        session.addRef() // Increment reference count to prevent cleanup
                        logrus.WithFields(logrus.Fields{
                                "func":      "getOrCreateSession",
                                "sessionID": cookie.Value,
                        }).Debug("Existing session found and updated")
                        return session, nil
                }</span>
                <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                        "func":      "getOrCreateSession",
                        "sessionID": cookie.Value,
                }).Warn("Cookie exists but session not found")</span>
        }

        <span class="cov8" title="1">sessionID := uuid.New().String()
        session := &amp;PlayerSession{
                SessionID:   sessionID,
                CreatedAt:   time.Now(),
                LastActive:  time.Now(),
                MessageChan: make(chan []byte, MessageChanBufferSize),
        }
        session.addRef() // Increment reference count for new session
        s.sessions[sessionID] = session

        // Determine if connection is secure for proper cookie settings
        isSecure := r.TLS != nil || r.Header.Get("X-Forwarded-Proto") == "https"

        http.SetCookie(w, &amp;http.Cookie{
                Name:     "session_id",
                Value:    sessionID,
                Path:     "/",
                HttpOnly: true,
                MaxAge:   int(sessionTimeout.Seconds()), // Use consistent session timeout
                SameSite: http.SameSiteStrictMode,
                Secure:   isSecure,
        })

        logrus.WithFields(logrus.Fields{
                "func":      "getOrCreateSession",
                "sessionID": sessionID,
        }).Info("New session created")

        return session, nil</span>
}

// startSessionCleanup starts a background goroutine that periodically cleans up expired sessions.
// It runs every 5 minutes and removes sessions that have been inactive for more than 30 minutes.
//
// The cleanup process:
// 1. Iterates through all sessions under a mutex lock
// 2. Checks each session's LastActive timestamp
// 3. For expired sessions:
//   - Closes the websocket connection if present
//   - Closes the message channel
//   - Removes the session from the sessions map
//
// The function logs:
// - Debug messages when starting and during each cleanup cycle
// - Info messages for removed sessions and cleanup completion
// - Error messages if websocket connections fail to close
//
// Related types:
// - RPCServer - The server instance this runs on
// - Session - The session objects being cleaned up
//
// Note: This is a non-blocking function as it launches the cleanup routine in a separate goroutine
/*func (s *RPCServer) startSessionCleanup() {
        logrus.WithFields(logrus.Fields{
                "func": "startSessionCleanup",
        }).Debug("Starting session cleanup routine")

        go func() {
                ticker := time.NewTicker(5 * time.Minute)
                defer ticker.Stop()

                for range ticker.C {
                        logrus.WithFields(logrus.Fields{
                                "func": "startSessionCleanup",
                        }).Debug("Running cleanup cycle")

                        s.mu.Lock()
                        expiredCount := 0
                        for id, session := range s.sessions {
                                if time.Since(session.LastActive) &gt; 30*time.Minute {
                                        logrus.WithFields(logrus.Fields{
                                                "func":      "startSessionCleanup",
                                                "sessionID": id,
                                                "inactive":  time.Since(session.LastActive),
                                        }).Info("Removing expired session")

                                        if session.WSConn != nil {
                                                if err := session.WSConn.Close(); err != nil {
                                                        logrus.WithFields(logrus.Fields{
                                                                "func":      "startSessionCleanup",
                                                                "sessionID": id,
                                                                "error":     err,
                                                        }).Error("Failed to close websocket connection")
                                                }
                                        }
                                        close(session.MessageChan)
                                        delete(s.sessions, id)
                                        expiredCount++
                                }
                        }
                        s.mu.Unlock()

                        logrus.WithFields(logrus.Fields{
                                "func":         "startSessionCleanup",
                                "expiredCount": expiredCount,
                                "totalActive":  len(s.sessions),
                        }).Info("Cleanup cycle completed")
                }
        }()
}
*/
func (s *RPCServer) startSessionCleanup() <span class="cov8" title="1">{
        ticker := time.NewTicker(sessionCleanupInterval)
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                s.cleanupExpiredSessions()</span>
                        case &lt;-s.done:<span class="cov8" title="1">
                                ticker.Stop()
                                return</span>
                        }
                }
        }()
}

func (s *RPCServer) cleanupExpiredSessions() <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        now := time.Now()
        for id, session := range s.sessions </span><span class="cov8" title="1">{
                if now.Sub(session.LastActive) &gt; sessionTimeout </span><span class="cov8" title="1">{
                        // Check if session is currently in use by a handler
                        if session.isInUse() </span><span class="cov8" title="1">{
                                // Skip cleanup for now, will be retried in next cycle
                                continue</span>
                        }

                        <span class="cov8" title="1">if session.WSConn != nil </span><span class="cov0" title="0">{
                                session.WSConn.Close()
                        }</span>
                        <span class="cov8" title="1">delete(s.sessions, id)</span>
                }
        }
}

// getSession safely retrieves a session by ID with proper mutex protection and reference counting
func (s *RPCServer) getSession(sessionID string) (*PlayerSession, bool) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        session, exists := s.sessions[sessionID]
        if exists </span><span class="cov8" title="1">{
                session.addRef() // Increment reference count to prevent cleanup
        }</span>
        <span class="cov8" title="1">return session, exists</span>
}

// setSession safely sets a session with proper mutex protection
func (s *RPCServer) setSession(sessionID string, session *PlayerSession) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.sessions[sessionID] = session
}</span>

// releaseSession decrements the reference count for a session after handler use
func (s *RPCServer) releaseSession(session *PlayerSession) <span class="cov8" title="1">{
        if session != nil </span><span class="cov8" title="1">{
                session.release()
        }</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package server

import (
        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// processSpellCast handles the execution of a spell cast by a player.
// It validates the spell requirements and processes the effects based on the spell school.
//
// Parameters:
//   - caster: *game.Player - The player casting the spell
//   - spell: *game.Spell - The spell being cast
//   - targetID: string - ID of the target (player/monster/object)
//   - pos: game.Position - Position for location-based spells
//
// Returns:
//   - interface{} - The result of the spell cast, specific to each spell type
//   - error - Any validation or processing errors that occurred
//
// Errors:
//   - Returns validation errors from validateSpellCast
//   - May return errors from individual spell processing functions
//
// Related:
//   - validateSpellCast
//   - processEvocationSpell
//   - processEnchantmentSpell
//   - processIllusionSpell
//   - processGenericSpell
func (s *RPCServer) processSpellCast(caster *game.Player, spell *game.Spell, targetID string, pos game.Position) (interface{}, error) <span class="cov8" title="1">{
        s.logSpellCastStart(caster, spell, targetID)

        if err := s.validateSpellCastForCast(caster, spell); err != nil </span><span class="cov8" title="1">{
                s.logSpellValidationError(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">s.logSpellSchoolProcessing(spell)

        result, err := s.dispatchSpellBySchool(spell, caster, targetID, pos)
        if err != nil </span><span class="cov0" title="0">{
                s.logSpellProcessingError(err)
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

// logSpellCastStart logs the start of a spell cast attempt.
func (s *RPCServer) logSpellCastStart(caster *game.Player, spell *game.Spell, targetID string) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "processSpellCast",
                "caster":   caster.ID,
                "spell":    spell.Name,
                "targetID": targetID,
        }).Debug("processing spell cast")
}</span>

// validateSpellCastForCast validates the spell requirements for casting.
func (s *RPCServer) validateSpellCastForCast(caster *game.Player, spell *game.Spell) error <span class="cov8" title="1">{
        return s.validateSpellCast(caster, spell)
}</span>

// logSpellValidationError logs a spell validation error.
func (s *RPCServer) logSpellValidationError(err error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "processSpellCast",
                "error":    err.Error(),
        }).Error("spell validation failed")
}</span>

// logSpellSchoolProcessing logs the spell school being processed.
func (s *RPCServer) logSpellSchoolProcessing(spell *game.Spell) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function":    "processSpellCast",
                "spellSchool": spell.School,
        }).Info("processing spell by school")
}</span>

// dispatchSpellBySchool routes spell processing to the correct handler based on school.
func (s *RPCServer) dispatchSpellBySchool(spell *game.Spell, caster *game.Player, targetID string, pos game.Position) (interface{}, error) <span class="cov8" title="1">{
        switch spell.School </span>{
        case game.SchoolEvocation:<span class="cov8" title="1">
                return s.processEvocationSpell(spell, caster, targetID)</span>
        case game.SchoolEnchantment:<span class="cov8" title="1">
                return s.processEnchantmentSpell(spell, caster, targetID)</span>
        case game.SchoolIllusion:<span class="cov8" title="1">
                return s.processIllusionSpell(spell, caster, pos)</span>
        default:<span class="cov8" title="1">
                logrus.WithFields(logrus.Fields{
                        "function":    "processSpellCast",
                        "spellSchool": spell.School,
                }).Warn("unknown spell school, using generic processing")
                return s.processGenericSpell(spell, caster, targetID)</span>
        }
}

// logSpellProcessingError logs an error that occurred during spell processing.
func (s *RPCServer) logSpellProcessingError(err error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "processSpellCast",
                "error":    err.Error(),
        }).Error("spell processing failed")
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package server

import (
        "fmt"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

func (s *RPCServer) hasSpellComponent(caster *game.Player, component game.SpellComponent) bool <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function":  "hasSpellComponent",
                "caster_id": caster.ID,
                "component": component,
        }).Debug("checking spell component")

        switch component </span>{
        case game.ComponentVerbal:<span class="cov8" title="1">
                // Check if character can speak (not silenced or stunned)
                if caster.HasEffect(game.EffectStun) </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "function": "hasSpellComponent",
                                "reason":   "character is stunned",
                        }).Debug("verbal component unavailable")
                        return false
                }</span>
                <span class="cov8" title="1">return true</span>

        case game.ComponentSomatic:<span class="cov8" title="1">
                // Check if character can use hands (not paralyzed or hands bound)
                if caster.HasEffect(game.EffectStun) </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "function": "hasSpellComponent",
                                "reason":   "character is stunned",
                        }).Debug("somatic component unavailable")
                        return false
                }</span>
                <span class="cov8" title="1">return true</span>

        case game.ComponentMaterial:<span class="cov8" title="1">
                // Check if the caster has the required material component in their inventory
                for _, item := range caster.Inventory </span><span class="cov8" title="1">{
                        if item.Type == "SpellComponent" </span><span class="cov8" title="1">{
                                logrus.WithFields(logrus.Fields{
                                        "function": "hasSpellComponent",
                                }).Debug("found required spell component")
                                return true
                        }</span>
                }
                <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                        "function":  "hasSpellComponent",
                        "component": component,
                }).Warn("spell component not found in inventory")
                return false</span>

        default:<span class="cov0" title="0">
                logrus.WithFields(logrus.Fields{
                        "function":  "hasSpellComponent",
                        "component": component,
                }).Warn("unknown spell component type")
                return false</span>
        }
}

func (s *RPCServer) validateSpellCast(caster *game.Player, spell *game.Spell) error <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function":  "validateSpellCast",
                "caster_id": caster.ID,
                "spell_id":  spell.ID,
        }).Debug("validating spell cast")

        // Check level requirements
        if caster.Level &lt; spell.Level </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "function":       "validateSpellCast",
                        "caster_level":   caster.Level,
                        "required_level": spell.Level,
                }).Warn("insufficient level to cast spell")
                return fmt.Errorf("insufficient level to cast spell")
        }</span>

        // Check components
        <span class="cov8" title="1">for _, component := range spell.Components </span><span class="cov8" title="1">{
                if !s.hasSpellComponent(caster, component) </span><span class="cov8" title="1">{
                        logrus.WithFields(logrus.Fields{
                                "function":  "validateSpellCast",
                                "component": component,
                        }).Warn("missing required spell component")
                        return fmt.Errorf("missing required spell component: %v", component)
                }</span>
        }

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function": "validateSpellCast",
        }).Debug("spell cast validation successful")
        return nil</span>
}

// processEvocationSpell handles the effects of an evocation spell, including damage, healing, and result construction.
func (s *RPCServer) processEvocationSpell(spell *game.Spell, caster *game.Player, targetID string) (interface{}, error) <span class="cov8" title="1">{
        s.logEvocationSpellStart(spell, caster, targetID)

        spellPower := calculateSpellPower(caster, spell)

        // Refactored: delegate to helper functions for damage, healing, and result construction
        damage, damageRoll, hitTargets, err := s.processEvocationDamage(spell, targetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("damage processing failed: %w", err)
        }</span>

        <span class="cov8" title="1">healing, healingRoll, healedTargets, err := s.processEvocationHealing(spell, targetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("healing processing failed: %w", err)
        }</span>

        // Fallback if no dice specified
        <span class="cov8" title="1">if damage == 0 &amp;&amp; healing == 0 </span><span class="cov8" title="1">{
                damage, hitTargets, err = s.processEvocationFallback(spell, spellPower, targetID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("fallback damage failed: %w", err)
                }</span>
        }

        <span class="cov8" title="1">result := s.buildEvocationResult(
                spell,
                spellPower,
                damage,
                healing,
                append(hitTargets, healedTargets...),
                damageRoll,
                healingRoll,
        )

        s.logEvocationSpellSuccess(spell, damage, healing, spellPower)
        return result, nil</span>
}

// logEvocationSpellStart logs the start of an evocation spell processing.
func (s *RPCServer) logEvocationSpellStart(spell *game.Spell, caster *game.Player, targetID string) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "logEvocationSpellStart",
                "spell":    spell.Name,
                "caster":   caster.ID,
                "targetID": targetID,
        }).Info("Starting evocation spell processing")
}</span>

// processEvocationDamage rolls damage dice, applies damage, and returns results.
func (s *RPCServer) processEvocationDamage(spell *game.Spell, targetID string) (int, *game.DiceRoll, []string, error) <span class="cov8" title="1">{
        roll, err := game.GlobalDiceRoller.Roll(spell.DamageDice)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("failed to roll damage dice")
                return 0, nil, nil, fmt.Errorf("failed to roll damage dice: %w", err)
        }</span>
        <span class="cov8" title="1">damage := roll.Final
        hitTargets := []string{targetID}
        damageType := spell.DamageType
        if damageType == "" </span><span class="cov8" title="1">{
                damageType = "magical"
        }</span>
        <span class="cov8" title="1">if err := s.applySpellDamage(targetID, damage, damageType); err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("failed to apply spell damage")
                return 0, nil, nil, fmt.Errorf("failed to apply spell damage: %w", err)
        }</span>
        <span class="cov8" title="1">return damage, roll, hitTargets, nil</span>
}

// processEvocationHealing rolls healing dice, applies healing, and returns results.
func (s *RPCServer) processEvocationHealing(spell *game.Spell, targetID string) (int, *game.DiceRoll, []string, error) <span class="cov8" title="1">{
        roll, err := game.GlobalDiceRoller.Roll(spell.HealingDice)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("failed to roll healing dice")
                return 0, nil, nil, fmt.Errorf("failed to roll healing dice: %w", err)
        }</span>
        <span class="cov8" title="1">healing := roll.Final
        hitTargets := []string{targetID}
        if err := s.applySpellHealing(targetID, healing); err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("failed to apply spell healing")
                return 0, nil, nil, fmt.Errorf("failed to apply spell healing: %w", err)
        }</span>
        <span class="cov8" title="1">return healing, roll, hitTargets, nil</span>
}

// processEvocationFallback applies fallback damage if no dice are specified.
func (s *RPCServer) processEvocationFallback(spell *game.Spell, spellPower int, targetID string) (int, []string, error) <span class="cov8" title="1">{
        damage := spellPower * spell.Level
        hitTargets := []string{targetID}
        if err := s.applySpellDamage(targetID, damage, "magical"); err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("failed to apply generic spell damage")
                return 0, nil, fmt.Errorf("failed to apply spell damage: %w", err)
        }</span>
        <span class="cov8" title="1">return damage, hitTargets, nil</span>
}

// buildEvocationResult constructs the result map for an evocation spell.
func (s *RPCServer) buildEvocationResult(
        spell *game.Spell,
        spellPower, damage, healing int,
        hitTargets []string,
        damageRoll, healingRoll *game.DiceRoll,
) map[string]interface{} <span class="cov8" title="1">{
        result := map[string]interface{}{
                "success":     true,
                "spell_id":    spell.ID,
                "spell_name":  spell.Name,
                "spell_power": spellPower,
                "damage":      damage,
                "healing":     healing,
                "hit_targets": hitTargets,
                "effect_type": "evocation",
                "damage_type": spell.DamageType,
                "area_effect": spell.AreaEffect,
                "save_type":   spell.SaveType,
                "keywords":    spell.EffectKeywords,
        }
        if damageRoll != nil </span><span class="cov8" title="1">{
                result["damage_roll"] = damageRoll.String()
        }</span>
        <span class="cov8" title="1">if healingRoll != nil </span><span class="cov8" title="1">{
                result["healing_roll"] = healingRoll.String()
        }</span>
        <span class="cov8" title="1">return result</span>
}

// logEvocationSpellSuccess logs the successful processing of an evocation spell.
func (s *RPCServer) logEvocationSpellSuccess(spell *game.Spell, damage, healing, spellPower int) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function":   "logEvocationSpellSuccess",
                "spell":      spell.Name,
                "damage":     damage,
                "healing":    healing,
                "spellPower": spellPower,
        }).Info("Evocation spell processed successfully")
}</span>

func (s *RPCServer) processEnchantmentSpell(spell *game.Spell, caster *game.Player, targetID string) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "processEnchantmentSpell",
                "spell_id": spell.ID,
                "caster":   caster.ID,
                "target":   targetID,
        }).Debug("processing enchantment spell")

        // Implement buff/debuff spells
        result := map[string]interface{}{
                "success":  true,
                "spell_id": spell.ID,
        }

        logrus.WithFields(logrus.Fields{
                "function": "processEnchantmentSpell",
                "spell_id": spell.ID,
        }).Debug("enchantment spell processed")

        return result, nil
}</span>

func (s *RPCServer) processIllusionSpell(spell *game.Spell, caster *game.Player, pos game.Position) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "processIllusionSpell",
                "spell_id": spell.ID,
                "caster":   caster.ID,
                "position": pos,
        }).Debug("processing illusion spell")

        // Implement area effect spells
        result := map[string]interface{}{
                "success":  true,
                "spell_id": spell.ID,
        }

        logrus.WithFields(logrus.Fields{
                "function": "processIllusionSpell",
                "spell_id": spell.ID,
        }).Debug("illusion spell processed")

        return result, nil
}</span>

func (s *RPCServer) processGenericSpell(spell *game.Spell, caster *game.Player, targetID string) (interface{}, error) <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "processGenericSpell",
                "spell_id": spell.ID,
                "caster":   caster.ID,
                "target":   targetID,
        }).Debug("processing generic spell")

        // Default spell processing
        result := map[string]interface{}{
                "success":  true,
                "spell_id": spell.ID,
        }

        logrus.WithFields(logrus.Fields{
                "function": "processGenericSpell",
                "spell_id": spell.ID,
        }).Debug("generic spell processed")

        return result, nil
}</span>

// calculateSpellPower computes the effective power of a spell based on caster attributes
func calculateSpellPower(caster *game.Player, spell *game.Spell) int <span class="cov8" title="1">{
        // Base power from spell level
        basePower := spell.Level * 5

        // Intelligence modifier for spell power
        intModifier := (caster.Intelligence - 10) / 2
        if intModifier &lt; 0 </span><span class="cov8" title="1">{
                intModifier = 0
        }</span>

        // Caster level bonus
        <span class="cov8" title="1">levelBonus := caster.Level / 2

        return basePower + intModifier + levelBonus</span>
}

// calculateDamage determines damage amount for offensive spells
func calculateDamage(spell *game.Spell, spellPower int) int <span class="cov0" title="0">{
        switch spell.ID </span>{
        case "fireball":<span class="cov0" title="0">
                // 8d6 base damage + spell power
                return rollDice(8, 6) + spellPower</span>
        case "lightning_bolt":<span class="cov0" title="0">
                // 6d8 base damage + spell power
                return rollDice(6, 8) + spellPower</span>
        case "magic_missile":<span class="cov0" title="0">
                // 3d4+3 base damage + spell power
                return rollDice(3, 4) + 3 + spellPower</span>
        default:<span class="cov0" title="0">
                // Generic damage: 1d6 per spell level + spell power
                return rollDice(spell.Level, 6) + spellPower</span>
        }
}

// calculateHealing determines healing amount for restorative spells
func calculateHealing(spell *game.Spell, spellPower int) int <span class="cov0" title="0">{
        switch spell.ID </span>{
        case "heal":<span class="cov0" title="0">
                // Major healing: 4d8 + spell power
                return rollDice(4, 8) + spellPower</span>
        case "cure_wounds":<span class="cov0" title="0">
                // Moderate healing: 2d8 + spell power
                return rollDice(2, 8) + spellPower</span>
        case "healing_word":<span class="cov0" title="0">
                // Minor healing: 1d4 + spell power
                return rollDice(1, 4) + spellPower</span>
        default:<span class="cov0" title="0">
                // Generic healing: 1d4 per spell level + spell power
                return rollDice(spell.Level, 4) + spellPower</span>
        }
}

// rollDice simulates dice rolling for damage/healing calculations
func rollDice(numDice, dieSize int) int <span class="cov0" title="0">{
        if numDice &lt;= 0 || dieSize &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">total := 0
        for i := 0; i &lt; numDice; i++ </span><span class="cov0" title="0">{
                total += (total % dieSize) + 1 // Simple pseudo-random for deterministic testing
        }</span>
        <span class="cov0" title="0">return total</span>
}

// applySpellDamage applies spell damage to a target
func (s *RPCServer) applySpellDamage(targetID string, damage int, damageType string) error <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function":    "applySpellDamage",
                "target_id":   targetID,
                "damage":      damage,
                "damage_type": damageType,
        }).Debug("applying spell damage")

        // Find target in sessions (if it's a player)
        s.mu.RLock()
        for _, session := range s.sessions </span><span class="cov0" title="0">{
                if session.Player.GetID() == targetID </span><span class="cov0" title="0">{
                        s.mu.RUnlock()

                        // Apply damage to player
                        currentHP := session.Player.GetHP()
                        newHP := currentHP - damage
                        if newHP &lt; 0 </span><span class="cov0" title="0">{
                                newHP = 0
                        }</span>

                        <span class="cov0" title="0">session.Player.SetHP(newHP)

                        logrus.WithFields(logrus.Fields{
                                "function":  "applySpellDamage",
                                "target_id": targetID,
                                "damage":    damage,
                                "old_hp":    currentHP,
                                "new_hp":    newHP,
                        }).Info("spell damage applied to player")

                        return nil</span>
                }
        }
        <span class="cov8" title="1">s.mu.RUnlock()

        // If not a player, assume it's an NPC/monster
        logrus.WithFields(logrus.Fields{
                "function":  "applySpellDamage",
                "target_id": targetID,
                "damage":    damage,
        }).Info("spell damage applied to NPC (simulated)")

        return nil</span>
}

// applySpellHealing applies spell healing to a target
func (s *RPCServer) applySpellHealing(targetID string, healing int) error <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function":  "applySpellHealing",
                "target_id": targetID,
                "healing":   healing,
        }).Debug("applying spell healing")

        // Find target in sessions (if it's a player)
        s.mu.RLock()
        for _, session := range s.sessions </span><span class="cov0" title="0">{
                if session.Player.GetID() == targetID </span><span class="cov0" title="0">{
                        s.mu.RUnlock()

                        // Apply healing to player
                        currentHP := session.Player.GetHP()
                        maxHP := session.Player.GetMaxHP()
                        newHP := currentHP + healing
                        if newHP &gt; maxHP </span><span class="cov0" title="0">{
                                newHP = maxHP
                        }</span>

                        <span class="cov0" title="0">session.Player.SetHP(newHP)

                        logrus.WithFields(logrus.Fields{
                                "function":  "applySpellHealing",
                                "target_id": targetID,
                                "healing":   healing,
                                "old_hp":    currentHP,
                                "new_hp":    newHP,
                                "max_hp":    maxHP,
                        }).Info("spell healing applied to player")

                        return nil</span>
                }
        }
        <span class="cov8" title="1">s.mu.RUnlock()

        // If not a player, assume it's an NPC/monster
        logrus.WithFields(logrus.Fields{
                "function":  "applySpellHealing",
                "target_id": targetID,
                "healing":   healing,
        }).Info("spell healing applied to NPC (simulated)")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package server

import (
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// GameState represents the core game state container managing all dynamic game elements.
// It provides thread-safe access to the world state, turn sequencing, time tracking,
// and player session management.
//
// Fields:
//   - WorldState: Holds the current state of the game world including entities, items, etc
//   - TurnManager: Manages turn order and action resolution for game entities
//   - TimeManager: Tracks game time progression and scheduling
//   - Sessions: Maps session IDs to active PlayerSession objects
//   - mu: Provides thread-safe access to state
//   - updates: Channel for broadcasting state changes to listeners
//
// Thread Safety:
// All public methods are protected by mutex to ensure thread-safe concurrent access.
// The updates channel allows for non-blocking notifications of state changes.
//
// Related Types:
//   - game.World
//   - TurnManager
//   - TimeManager
//   - PlayerSession
type GameState struct {
        WorldState  *game.World               `yaml:"state_world"`
        TurnManager *TurnManager              `yaml:"state_turns"`
        TimeManager *TimeManager              `yaml:"state_time"`
        Sessions    map[string]*PlayerSession `yaml:"state_sessions"`
        Version     int                       `yaml:"state_version"`

        // Locking implementation
        stateMu   sync.RWMutex `yaml:"-"` // Primary state mutex
        worldMu   sync.RWMutex `yaml:"-"` // World state mutex
        sessionMu sync.RWMutex `yaml:"-"` // Session mutex
        turnMu    sync.RWMutex `yaml:"-"` // Turn manager mutex

        // State caching
        cachedState  atomic.Value `yaml:"-"` // Cached state data
        cacheVersion int32        `yaml:"-"` // Atomic cache version

        updates chan StateUpdate `yaml:"-"` // Update channel
}

// AddPlayer initializes a new player in the game state
func (gs *GameState) AddPlayer(session *PlayerSession) <span class="cov0" title="0">{
        if session == nil || session.Player == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">gs.worldMu.Lock()
        defer gs.worldMu.Unlock()

        // Initialize WorldState if nil
        if gs.WorldState == nil </span><span class="cov0" title="0">{
                gs.WorldState = &amp;game.World{}
        }</span>

        // Initialize Objects map if nil
        <span class="cov0" title="0">if gs.WorldState.Objects == nil </span><span class="cov0" title="0">{
                gs.WorldState.Objects = make(map[string]game.GameObject)
        }</span>

        // Add player to world state
        <span class="cov0" title="0">gs.WorldState.Objects[session.Player.GetID()] = session.Player</span>
}

// GetState returns the current game state as a map.
func (gs *GameState) GetState() map[string]interface{} <span class="cov0" title="0">{
        // Try to get cached state first
        if cached := gs.cachedState.Load(); cached != nil </span><span class="cov0" title="0">{
                if state, ok := cached.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if atomic.LoadInt32(&amp;gs.cacheVersion) == int32(gs.Version) </span><span class="cov0" title="0">{
                                return state
                        }</span>
                }
        }

        // Cache miss - generate new state with minimal locking
        <span class="cov0" title="0">gs.stateMu.RLock()
        version := gs.Version
        gs.stateMu.RUnlock()

        state := make(map[string]interface{})

        // Get world state with separate lock
        gs.worldMu.RLock()
        state["world"] = gs.WorldState.Serialize()
        gs.worldMu.RUnlock()

        // Get time state
        state["time"] = gs.TimeManager.Serialize()

        // Get turn state with separate lock
        gs.turnMu.RLock()
        state["turns"] = gs.TurnManager.Serialize()
        gs.turnMu.RUnlock()

        // Get session data with separate lock
        gs.sessionMu.RLock()
        sessions := make(map[string]interface{})
        for id, session := range gs.Sessions </span><span class="cov0" title="0">{
                sessions[id] = session.PublicData()
        }</span>
        <span class="cov0" title="0">gs.sessionMu.RUnlock()
        state["sessions"] = sessions

        state["version"] = version

        // Update cache
        gs.cachedState.Store(state)
        atomic.StoreInt32(&amp;gs.cacheVersion, int32(version))

        return state</span>
}

func (gs *GameState) validate() error <span class="cov0" title="0">{
        if gs.WorldState == nil ||
                gs.TimeManager == nil ||
                gs.TurnManager == nil ||
                gs.Sessions == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("missing required state components")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdateState applies updates to the game state.
func (gs *GameState) UpdateState(updates map[string]interface{}) error <span class="cov0" title="0">{
        // Create snapshot for rollback under read lock
        gs.stateMu.RLock()
        snapshot := gs.createSnapshot()
        version := gs.Version
        gs.stateMu.RUnlock()

        // Acquire locks in consistent order to prevent deadlocks
        gs.worldMu.Lock()
        gs.sessionMu.Lock()
        gs.turnMu.Lock()
        gs.stateMu.Lock()
        defer func() </span><span class="cov0" title="0">{
                gs.stateMu.Unlock()
                gs.turnMu.Unlock()
                gs.sessionMu.Unlock()
                gs.worldMu.Unlock()
        }</span>()

        // Verify version hasn't changed
        <span class="cov0" title="0">if gs.Version != version </span><span class="cov0" title="0">{
                return fmt.Errorf("state version changed during update")
        }</span>

        // Apply updates with timeout
        <span class="cov0" title="0">done := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                done &lt;- gs.applyUpdates(updates)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-done:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        gs.rollback(snapshot)
                        return err
                }</span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                gs.rollback(snapshot)
                return fmt.Errorf("update timed out")</span>
        }

        <span class="cov0" title="0">gs.Version++
        // Invalidate cache
        atomic.StoreInt32(&amp;gs.cacheVersion, -1)

        return nil</span>
}

func (gs *GameState) rollback(snapshot any) <span class="cov0" title="0">{
        if snapshotState, ok := snapshot.(*GameState); ok </span><span class="cov0" title="0">{
                // Restore all state components from snapshot
                gs.WorldState = snapshotState.WorldState
                gs.TimeManager = snapshotState.TimeManager
                gs.TurnManager = snapshotState.TurnManager
                gs.Sessions = snapshotState.Sessions
                gs.Version = snapshotState.Version

                logrus.WithField("version", gs.Version).Info("rolled back game state to previous snapshot")
        }</span> else<span class="cov0" title="0"> {
                logrus.Error("invalid snapshot type for rollback")
        }</span>
}

func (gs *GameState) applyUpdates(updates map[string]interface{}) error <span class="cov0" title="0">{
        // Handle world state updates
        if worldUpdates, ok := updates["world"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if err := gs.WorldState.Update(worldUpdates); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("world update failed: %w", err)
                }</span>
        }

        // Handle time manager updates
        <span class="cov0" title="0">if timeUpdates, ok := updates["time"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if currentTime, ok := timeUpdates["current_time"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if scale, ok := currentTime["time_scale"].(float64); ok </span><span class="cov0" title="0">{
                                gs.TimeManager.TimeScale = scale
                        }</span>
                }
        }

        // Handle turn manager updates
        <span class="cov0" title="0">if turnUpdates, ok := updates["turns"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if err := gs.TurnManager.Update(turnUpdates); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("turn update failed: %v", err)
                }</span>
        }

        // Handle session updates
        <span class="cov0" title="0">if sessionUpdates, ok := updates["sessions"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for id, update := range sessionUpdates </span><span class="cov0" title="0">{
                        if session, exists := gs.Sessions[id]; exists </span><span class="cov0" title="0">{
                                if updateMap, ok := update.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if err := session.Update(updateMap); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("session update failed for %s: %v", id, err)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (gs *GameState) createSnapshot() any <span class="cov0" title="0">{
        // Create a deep copy of the game state for rollback purposes
        snapshot := &amp;GameState{
                WorldState: gs.WorldState.Clone(), // Assuming World has a Clone method
                TimeManager: &amp;TimeManager{
                        CurrentTime:     gs.TimeManager.CurrentTime,
                        TimeScale:       gs.TimeManager.TimeScale,
                        LastTick:        gs.TimeManager.LastTick,
                        ScheduledEvents: make([]ScheduledEvent, len(gs.TimeManager.ScheduledEvents)),
                },
                TurnManager: gs.TurnManager.Clone(), // Assuming TurnManager has a Clone method
                Sessions:    make(map[string]*PlayerSession),
        }

        // Copy scheduled events
        copy(snapshot.TimeManager.ScheduledEvents, gs.TimeManager.ScheduledEvents)

        // Copy sessions
        for id, session := range gs.Sessions </span><span class="cov0" title="0">{
                snapshot.Sessions[id] = session.Clone() // Assuming PlayerSession has a Clone method
        }</span>

        <span class="cov0" title="0">return snapshot</span>
}

// TimeManager handles game time progression and scheduled event management.
// It maintains the current game time, controls time progression speed,
// and manages a queue of scheduled future events.
//
// Fields:
//   - CurrentTime: The current in-game time represented as a GameTime struct
//   - TimeScale: Multiplier that controls how fast game time progresses relative to real time (e.g. 2.0 = twice as fast)
//   - LastTick: Real-world timestamp of the most recent time update
//   - ScheduledEvents: Slice of pending events to be triggered at specific game times
//
// Related types:
//   - game.GameTime - Represents a point in game time
//   - ScheduledEvent - Defines a future event to occur at a specific game time
type TimeManager struct {
        CurrentTime     game.GameTime    `yaml:"time_current"`          // Current game time
        TimeScale       float64          `yaml:"time_scale"`            // Time progression rate
        LastTick        time.Time        `yaml:"time_last_tick"`        // Last update time
        ScheduledEvents []ScheduledEvent `yaml:"time_scheduled_events"` // Pending events
}

// Serialize returns a map representation of the TimeManager state
func (t *TimeManager) Serialize() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "current_time": map[string]interface{}{
                        "real_time":  t.CurrentTime.RealTime,
                        "game_ticks": t.CurrentTime.GameTicks,
                        "time_scale": t.CurrentTime.TimeScale,
                },
                "time_scale": t.TimeScale,
                "last_tick":  t.LastTick,
                "events": func() []map[string]interface{} </span><span class="cov0" title="0">{
                        events := make([]map[string]interface{}, len(t.ScheduledEvents))
                        for i, event := range t.ScheduledEvents </span><span class="cov0" title="0">{
                                events[i] = map[string]interface{}{
                                        "id":           event.EventID,
                                        "type":         event.EventType,
                                        "trigger_time": event.TriggerTime,
                                        "parameters":   event.Parameters,
                                        "repeating":    event.Repeating,
                                }
                        }</span>
                        <span class="cov0" title="0">return events</span>
                }(),
        }
}

// ScheduledEvent represents a future event that will be triggered at a specific game time.
// It is used to schedule in-game events like monster spawns, weather changes, or quest updates.
//
// Fields:
//   - EventID: Unique string identifier for the event
//   - EventType: Category/type of the event (e.g. "spawn", "weather", etc)
//   - TriggerTime: The game.GameTime when this event should execute
//   - Parameters: Additional string data needed for the event execution
//   - Repeating: If true, the event will reschedule itself after triggering
//
// Related types:
//   - game.GameTime: Represents the in-game time when event triggers
type ScheduledEvent struct {
        EventID     string        `yaml:"event_id"`           // Event identifier
        EventType   string        `yaml:"event_type"`         // Type of event
        TriggerTime game.GameTime `yaml:"event_trigger_time"` // When to trigger
        Parameters  []string      `yaml:"event_parameters"`   // Event data
        Repeating   bool          `yaml:"event_is_repeating"` // Whether it repeats
}

// ScriptContext represents the execution state and variables of a running script in the game.
// It maintains context between script executions including variables and timing.
//
// Fields:
//   - ScriptID: Unique identifier string for the script
//   - Variables: Map storing script state variables and their values
//   - LastExecuted: Timestamp of when the script was last run
//   - IsActive: Boolean flag indicating if script is currently executing
//
// Related types:
//   - Server.Scripts (map[string]*ScriptContext)
//   - ScriptEngine interface
//
// Thread-safety: This struct should be protected by a mutex when accessed concurrently
type ScriptContext struct {
        ScriptID     string                 `yaml:"script_id"`            // Script identifier
        Variables    map[string]interface{} `yaml:"script_variables"`     // Script state
        LastExecuted time.Time              `yaml:"script_last_executed"` // Last run timestamp
        IsActive     bool                   `yaml:"script_is_active"`     // Execution state
}

// NewTimeManager creates and initializes a new TimeManager instance.
//
// The TimeManager handles game time tracking, time scaling, and scheduled event management.
// It maintains the current game time, real time mapping, and a list of scheduled events.
//
// Returns:
//   - *TimeManager: A new TimeManager instance initialized with:
//   - Current time set to now
//   - Game ticks starting at 0
//   - Default time scale of 1.0
//   - Empty scheduled events list
//
// Related types:
//   - game.GameTime
//   - ScheduledEvent
func NewTimeManager() *TimeManager <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function": "NewTimeManager",
        }).Debug("creating new time manager")

        tm := &amp;TimeManager{
                CurrentTime: game.GameTime{
                        RealTime:  time.Now(),
                        GameTicks: 0,
                        TimeScale: 1.0,
                },
                TimeScale:       1.0,
                LastTick:        time.Now(),
                ScheduledEvents: make([]ScheduledEvent, 0),
        }

        logrus.WithFields(logrus.Fields{
                "function":  "NewTimeManager",
                "timeScale": tm.TimeScale,
                "lastTick":  tm.LastTick,
        }).Info("time manager initialized")

        return tm
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package server

import (
        "fmt"
        "sync/atomic"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/gorilla/websocket"
)

// RPCMethod represents a unique identifier for RPC methods in the system.
// It is a string type alias used to strongly type RPC method names and
// prevent errors from mistyped method strings.
type RPCMethod string

// MethodMove represents an RPC method for handling player movement actions in the game.
// This method allows a player character to change their position on the game map.
// Related methods: MethodEndTurn, MethodGetGameState
//
// Expected payload parameters:
// - position: Vec2D - Target destination coordinates
// - characterID: string - ID of the character being moved
//
// Returns:
// - error if movement is invalid or character cannot move
//
// Edge cases:
// - Movement blocked by obstacles/terrain
// RPCMethod constants are defined in constants.go
// - Character has insufficient movement points
// - Position is outside map bounds

// EventCombat constants are defined in constants.go
// EventCombatStart represents when combat begins in the game. This event is triggered
// when characters initiate or are forced into combat.
// Event number: 100 (base combat event number + iota)
// Related events: EventCombatEnd, EventTurnStart, EventTurnEnd

// StateUpdate represents an atomic change to the game state.
// It captures what changed, which entity was affected, and when the change occurred.
//
// Fields:
//   - UpdateType: String identifying the type of update (e.g. "MOVE", "DAMAGE")
//   - EntityID: Unique identifier for the affected game entity
//   - ChangeData: Map containing the specific changes/updates to apply.
//     Values can be of any type due to interface{}
//   - Timestamp: When this state update occurred
//
// StateUpdate is used by the game engine to track and apply changes to entities.
// Updates are processed in chronological order based on Timestamp.
//
// Related types:
//   - Entity: The game object being modified
//   - Game: Top level game state manager
type StateUpdate struct {
        UpdateType string                 `yaml:"update_type"`      // Type of update
        EntityID   string                 `yaml:"update_entity_id"` // Affected entity
        ChangeData map[string]interface{} `yaml:"update_data"`      // Update details
        Timestamp  time.Time              `yaml:"update_timestamp"` // When it occurred
}

// PlayerSession represents an active game session for a player, managing their connection state
// and activity tracking. It maintains the link between a player and their current game session.
//
// Fields:
//   - SessionID: A unique string identifier for this specific session
//   - Player: Pointer to the associated game.Player instance containing player data
//   - LastActive: Timestamp of the most recent player activity in this session
//   - Connected: Boolean flag indicating if the player is currently connected
//
// Related types:
//   - game.Player: The player entity associated with this session
type PlayerSession struct {
        SessionID   string          `yaml:"session_id"`  // Unique session identifier
        Player      *game.Player    `yaml:"player"`      // Associated player
        LastActive  time.Time       `yaml:"last_active"` // Last activity timestamp
        CreatedAt   time.Time       `yaml:"created_at"`  // Session creation timestamp
        Connected   bool            `yaml:"connected"`   // Connection status
        MessageChan chan []byte     `yaml:"-"`           // Channel for sending messages
        WSConn      *websocket.Conn `yaml:"-"`           // WebSocket connection
        inUse       int32           `yaml:"-"`           // Atomic counter for active usage (prevents cleanup)
}

// Update modifies the player session with the provided updates.
func (p *PlayerSession) Update(updateMap map[string]interface{}) error <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot update nil PlayerSession")
        }</span>

        <span class="cov8" title="1">for key, value := range updateMap </span><span class="cov8" title="1">{
                switch key </span>{
                case "player":<span class="cov8" title="1">
                        if playerData, ok := value.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                p.Player.Update(playerData)
                        }</span>
                case "connected":<span class="cov8" title="1">
                        if connected, ok := value.(bool); ok </span><span class="cov8" title="1">{
                                p.Connected = connected
                        }</span>
                case "lastActive":<span class="cov8" title="1">
                        if timestamp, ok := value.(time.Time); ok </span><span class="cov8" title="1">{
                                p.LastActive = timestamp
                        }</span>
                case "sessionId":<span class="cov8" title="1">
                        if sessionID, ok := value.(string); ok </span><span class="cov8" title="1">{
                                p.SessionID = sessionID
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// Clone creates a deep copy of the PlayerSession.
func (p *PlayerSession) Clone() *PlayerSession <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">clone := &amp;PlayerSession{
                SessionID:   p.SessionID,
                Player:      p.Player.Clone(), // Assuming Player has a Clone method
                LastActive:  p.LastActive,
                CreatedAt:   p.CreatedAt,
                Connected:   p.Connected,
                MessageChan: make(chan []byte, 500), // Use consistent buffer size
                WSConn:      p.WSConn,               // Keep same connection
                inUse:       0,                      // Reset usage counter for clone
        }
        return clone</span>
}

// PublicData returns a sanitized version of the PlayerSession for client consumption.
func (p *PlayerSession) PublicData() interface{} <span class="cov8" title="1">{
        return struct {
                SessionID  string      `json:"sessionId"`
                PlayerData interface{} `json:"player"`
                Connected  bool        `json:"connected"`
                LastActive time.Time   `json:"lastActive"`
        }{
                SessionID:  p.SessionID,
                PlayerData: p.Player.PublicData(),
                Connected:  p.Connected,
                LastActive: p.LastActive,
        }
}</span>

// addRef atomically increments the usage counter to prevent cleanup
func (p *PlayerSession) addRef() <span class="cov8" title="1">{
        atomic.AddInt32(&amp;p.inUse, 1)
}</span>

// release atomically decrements the usage counter
func (p *PlayerSession) release() <span class="cov8" title="1">{
        atomic.AddInt32(&amp;p.inUse, -1)
}</span>

// isInUse atomically checks if the session is currently being used
func (p *PlayerSession) isInUse() bool <span class="cov8" title="1">{
        return atomic.LoadInt32(&amp;p.inUse) &gt; 0
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package server

import (
        "path/filepath"
        "regexp"
        "sort"
        "strconv"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
        "golang.org/x/exp/rand"
)

// ADDED: rollInitiative determines combat turn order by rolling initiative for all participants.
// It calculates initiative scores and returns participants sorted by highest roll first.
//
// Initiative calculation:
// - Characters: d20 + DEX modifier ((Dexterity-10)/2)
// - Other entities: d20 only
//
// Parameters:
//   - participants: Slice of entity IDs representing the combatants
//
// Returns:
//   - []string: Entity IDs sorted by initiative roll (highest to lowest)
//
// Notes:
// - Characters must exist in WorldState.Objects to apply DEX bonus
// - Non-existent entities are skipped from results
// - Uses golang.org/x/exp/rand for random number generation
func (s *RPCServer) rollInitiative(participants []string) []string <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function":        "rollInitiative",
                "numParticipants": len(participants),
        })
        logger.Debug("rolling initiative")

        type initiativeRoll struct {
                entityID string
                roll     int
        }

        rolls := make([]initiativeRoll, len(participants))
        for i, id := range participants </span><span class="cov0" title="0">{
                logger := logger.WithField("entityID", id)
                if obj, exists := s.state.WorldState.Objects[id]; exists </span><span class="cov0" title="0">{
                        if char, ok := obj.(*game.Character); ok </span><span class="cov0" title="0">{
                                roll := rand.Intn(20) + 1
                                modifier := (char.Dexterity - 10) / 2
                                rolls[i] = initiativeRoll{
                                        entityID: id,
                                        roll:     roll + modifier,
                                }
                                logger.WithFields(logrus.Fields{
                                        "baseRoll": roll,
                                        "modifier": modifier,
                                        "total":    rolls[i].roll,
                                }).Info("rolled initiative for character")
                        }</span> else<span class="cov0" title="0"> {
                                roll := rand.Intn(20) + 1
                                rolls[i] = initiativeRoll{
                                        entityID: id,
                                        roll:     roll,
                                }
                                logger.WithField("roll", roll).Info("rolled initiative for entity")
                        }</span>
                } else<span class="cov0" title="0"> {
                        logger.Warn("entity not found in world state")
                }</span>
        }

        <span class="cov0" title="0">sort.Slice(rolls, func(i, j int) bool </span><span class="cov0" title="0">{
                return rolls[i].roll &gt; rolls[j].roll
        }</span>)

        <span class="cov0" title="0">result := make([]string, len(rolls))
        for i, roll := range rolls </span><span class="cov0" title="0">{
                result[i] = roll.entityID
        }</span>

        <span class="cov0" title="0">logger.WithField("order", result).Info("initiative order determined")
        return result</span>
}

// getVisibleObjects returns all game objects that are within the player's visible range.
// The visibility is determined by the isPositionVisible method which checks if the object's
// position is within line of sight and range of the player.
//
// Parameters:
//   - player: *game.Player - The player whose visibility range is being checked
//
// Returns:
//   - []game.GameObject - Slice containing all visible game objects from the world state
//
// Related:
//   - isPositionVisible() - Used to check if a position is visible from player's position
//   - game.GameObject - Interface implemented by all game objects
//   - game.Player - Player entity struct
func (s *RPCServer) getVisibleObjects(player *game.Player) []game.GameObject <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "getVisibleObjects",
                "playerID": player.GetID(),
        })
        logger.Debug("getting visible objects for player")

        playerPos := player.GetPosition()
        logger.WithField("position", playerPos).Debug("got player position")

        visibleObjects := make([]game.GameObject, 0)

        for _, obj := range s.state.WorldState.Objects </span><span class="cov0" title="0">{
                objPos := obj.GetPosition()
                if s.isPositionVisible(playerPos, objPos) </span><span class="cov0" title="0">{
                        logger.WithFields(logrus.Fields{
                                "objectID": obj.GetID(),
                                "position": objPos,
                        }).Debug("object is visible")
                        visibleObjects = append(visibleObjects, obj)
                }</span>
        }

        <span class="cov0" title="0">logger.WithField("visibleCount", len(visibleObjects)).Info("finished getting visible objects")
        return visibleObjects</span>
}

// getActiveEffects retrieves all active effects currently applied to a player
//
// Parameters:
//   - player *game.Player: The player object to check for effects. Must not be nil.
//
// Returns:
//   - []*game.Effect: Slice of active effects on the player. Returns nil if player
//     does not implement game.EffectHolder interface.
//
// Related types:
//   - game.Effect
//   - game.EffectHolder
//   - game.Player
//
// Note: Uses type assertion to check if player implements EffectHolder interface.
func (s *RPCServer) getActiveEffects(player *game.Player) []*game.Effect <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "getActiveEffects",
                "playerID": player.GetID(),
        })
        logger.Debug("getting active effects for player")

        if holder, ok := interface{}(player).(game.EffectHolder); ok </span><span class="cov0" title="0">{
                effects := holder.GetEffects()
                logger.WithField("numEffects", len(effects)).Info("retrieved active effects")
                return effects
        }</span>
        <span class="cov0" title="0">logger.Warn("player does not implement EffectHolder interface")
        return nil</span>
}

// getCombatStateIfActive retrieves the current combat state for an active combat session.
// If there is no active combat, it returns nil.
//
// Parameters:
//   - player: *game.Player - The player for whom to get the combat state
//
// Returns:
//   - *CombatState - Contains combat information including:
//   - Active combatants in initiative order
//   - Current round count
//   - Combat zone position
//   - Active status effects
//     Returns nil if no combat is active
//
// Related:
//   - TurnManager.IsInCombat
//   - CombatState struct
func (s *RPCServer) getCombatStateIfActive(player *game.Player) *CombatState <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "getCombatStateIfActive",
                "playerID": player.GetID(),
        })
        logger.Debug("checking combat state")

        if !s.state.TurnManager.IsInCombat </span><span class="cov0" title="0">{
                logger.Info("no active combat")
                return nil
        }</span>

        <span class="cov0" title="0">state := &amp;CombatState{
                ActiveCombatants: s.state.TurnManager.Initiative,
                RoundCount:       s.state.TurnManager.CurrentRound,
                CombatZone:       player.GetPosition(),
                StatusEffects:    s.getCombatEffects(),
        }

        logger.WithFields(logrus.Fields{
                "combatants": len(state.ActiveCombatants),
                "round":      state.RoundCount,
                "position":   state.CombatZone,
        }).Info("retrieved active combat state")

        return state</span>
}

// getCombatEffects returns a map of active effects for all objects in the current combat initiative order.
//
// The function iterates through all objects in the TurnManager's initiative order and collects
// any active effects on objects that implement the EffectHolder interface.
//
// Returns:
//   - map[string][]game.Effect: A map where keys are object IDs and values are slices of active effects
//
// Related types:
//   - game.Effect: The effect type being collected
//   - game.EffectHolder: Interface for objects that can have effects
//
// Note: Objects that don't exist in WorldState or don't implement EffectHolder are skipped.
// Only objects with active effects will have entries in the returned map.
func (s *RPCServer) getCombatEffects() map[string][]game.Effect <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "getCombatEffects",
        })
        logger.Debug("collecting combat effects")

        effects := make(map[string][]game.Effect)

        for _, id := range s.state.TurnManager.Initiative </span><span class="cov0" title="0">{
                logger := logger.WithField("entityID", id)
                if obj, exists := s.state.WorldState.Objects[id]; exists </span><span class="cov0" title="0">{
                        if holder, ok := obj.(game.EffectHolder); ok </span><span class="cov0" title="0">{
                                activeEffects := holder.GetEffects()
                                if len(activeEffects) &gt; 0 </span><span class="cov0" title="0">{
                                        logger.WithField("numEffects", len(activeEffects)).Info("adding effects for entity")
                                        effects[id] = make([]game.Effect, len(activeEffects))
                                        for i, effect := range activeEffects </span><span class="cov0" title="0">{
                                                effects[id][i] = *effect
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        logger.Debug("entity has no active effects")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                logger.Debug("entity does not implement EffectHolder")
                        }</span>
                } else<span class="cov0" title="0"> {
                        logger.Warn("entity not found in world state")
                }</span>
        }

        <span class="cov0" title="0">logger.WithField("totalEntities", len(effects)).Info("finished collecting combat effects")
        return effects</span>
}

// isPositionVisible checks if a target position is visible from a given source position.
// It determines visibility based on Manhattan distance and level matching.
//
// Parameters:
//   - from: The source Position containing X,Y coordinates and Level
//   - to: The target Position to check visibility for
//
// Returns:
//   - bool: true if target position is visible (within 10 unit distance and on same level),
//     false otherwise
//
// Notes:
//   - Uses square of Euclidean distance (dx+dy) &lt;= 100 for performance
//   - Requires positions to be on the same level
//   - Distance check uses a radius of 10 units (square root of 100)
func (s *RPCServer) isPositionVisible(from, to game.Position) bool <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "isPositionVisible",
                "from":     from,
                "to":       to,
        })
        logger.Debug("checking position visibility")

        dx := from.X - to.X
        dy := from.Y - to.Y
        distanceSquared := dx*dx + dy*dy

        result := distanceSquared &lt;= 100 &amp;&amp; from.Level == to.Level
        logger.WithFields(logrus.Fields{
                "distanceSquared": distanceSquared,
                "sameLevel":       from.Level == to.Level,
                "visible":         result,
        }).Info("visibility check complete")

        return result
}</span>

// processEndTurnEffects processes any effects that should trigger at the end of a turn for a given game object.
// It checks if the object implements the EffectHolder interface and if so, iterates through its effects,
// processing any that should tick based on the current game time.
//
// Parameters:
//   - character: The game object to process end-turn effects for. Must implement game.GameObject interface.
//
// The function handles the following cases:
//   - If character does not implement EffectHolder, no effects are processed
//   - Each effect is checked against current time to determine if it should tick
//
// Related types:
//   - game.GameObject
//   - game.EffectHolder
//   - game.Effect
func (s *RPCServer) processEndTurnEffects(character game.GameObject) <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "processEndTurnEffects",
                "charID":   character.GetID(),
        })
        logger.Debug("processing end turn effects")

        if holder, ok := character.(game.EffectHolder); ok </span><span class="cov8" title="1">{
                effects := holder.GetEffects()
                logger.WithField("numEffects", len(effects)).Info("checking effects")

                for _, effect := range effects </span><span class="cov0" title="0">{
                        logger := logger.WithField("effectID", effect.ID)
                        if effect.ShouldTick(s.state.TimeManager.CurrentTime.RealTime) </span><span class="cov0" title="0">{
                                logger.Info("processing effect tick")
                                s.state.processEffectTick(effect)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Debug("effect not ready to tick")
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                logger.Debug("character has no effects")
        }</span>
}

// processEndRound handles end-of-round processing for the game state:
// 1. Increments the current round counter
// 2. Processes any delayed/queued actions
// 3. Checks if combat has ended
//
// Related:
// - TurnManager.CurrentRound
// - processDelayedActions()
// - checkCombatEnd()
func (s *RPCServer) processEndRound() <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "processEndRound",
                "round":    s.state.TurnManager.CurrentRound,
        })
        logger.Debug("processing end of round")

        s.state.TurnManager.CurrentRound++
        logger.WithField("newRound", s.state.TurnManager.CurrentRound).Info("incremented round counter")

        s.processDelayedActions()
        logger.Debug("processed delayed actions")

        s.checkCombatEnd()
        logger.Debug("checked combat end conditions")
}</span>

// isTimeToExecute checks if a given game time has been reached based on tick counts
//
// Parameters:
//   - current: The current game time
//   - trigger: The target game time to compare against
//
// Returns:
//
//        bool: true if current game ticks is greater than or equal to trigger ticks,
//        false otherwise
//
// Related:
//   - game.GameTime struct
//
// ADDED: isTimeToExecute checks if the current game time has reached or exceeded a trigger time.
// It compares game tick counts to determine if a scheduled event should execute.
//
// Parameters:
//   - current: Current game time state
//   - trigger: Target trigger time to check against
//
// Returns:
//   - bool: true if current ticks &gt;= trigger ticks, false otherwise
//
// This function is used for:
// - Scheduled event execution
// - Effect duration checking
// - Time-based game mechanics
func isTimeToExecute(current, trigger game.GameTime) bool <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function":     "isTimeToExecute",
                "currentTicks": current.GameTicks,
                "triggerTicks": trigger.GameTicks,
        })
        logger.Debug("checking execution time")

        result := current.GameTicks &gt;= trigger.GameTicks
        logger.WithField("result", result).Info("time check complete")
        return result
}</span>

// ADDED: findSpell searches for a spell by ID within a slice of spell objects.
// It performs linear search through the provided spell collection.
//
// Parameters:
//   - spells: Slice of game.Spell objects to search through
//   - spellID: String identifier of the spell to find
//
// Returns:
//   - *game.Spell: Pointer to found spell, or nil if not found
//
// Search behavior:
// - Case-sensitive string matching on spell ID field
// - Returns first match found (assumes unique IDs)
// - Returns nil if spell not found in collection
func findSpell(spells []game.Spell, spellID string) *game.Spell <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "findSpell",
                "spellID":  spellID,
        })
        logger.Debug("searching for spell")

        for i := range spells </span><span class="cov8" title="1">{
                if spells[i].ID == spellID </span><span class="cov8" title="1">{
                        logger.WithField("found", true).Info("found spell")
                        return &amp;spells[i]
                }</span>
        }

        <span class="cov8" title="1">logger.WithField("found", false).Info("spell not found")
        return nil</span>
}

// ADDED: findInventoryItem searches for an item by ID within an inventory collection.
// It performs linear search through the provided inventory items.
//
// Parameters:
//   - inventory: Slice of game.Item objects representing the inventory to search
//   - itemID: String identifier of the item to find
//
// Returns:
//   - *game.Item: Pointer to found item, or nil if not found
//
// Search behavior:
// - Case-sensitive string matching on item ID field
// - Returns first match found (assumes unique IDs)
// - Commonly used for inventory management operations
func findInventoryItem(inventory []game.Item, itemID string) *game.Item <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "findInventoryItem",
                "itemID":   itemID,
        })
        logger.Debug("searching inventory for item")

        for i := range inventory </span><span class="cov8" title="1">{
                if inventory[i].ID == itemID </span><span class="cov8" title="1">{
                        logger.WithField("found", true).Info("found inventory item")
                        return &amp;inventory[i]
                }</span>
        }

        <span class="cov8" title="1">logger.WithField("found", false).Info("item not found in inventory")
        return nil</span>
}

// parseDamageString takes a damage string in dice notation format (e.g. "2d6+3") and returns the average damage value.
//
// The function accepts the following formats:
//   - Plain number (e.g. "5")
//   - Dice notation "XdY+Z" where:
//     X = number of dice (optional, defaults to 1)
//     Y = number of sides on each die
//     Z = fixed modifier to add (optional)
//
// Parameters:
//
//        damage string - The damage string to parse in dice notation format
//
// Returns:
//
//        int - The calculated average damage:
//        - For plain numbers, returns the number as-is
//        - For dice notation, returns average roll value of dice + modifier
//        - Returns 0 for invalid input formats
//
// Examples:
//
//        parseDamageString("5")    // Returns 5
//        parseDamageString("2d6")  // Returns 7 (avg of 2 six-sided dice)
//        parseDamageString("d8+2") // Returns 6.5 rounded to 6 (avg of 1d8 + 2)
//        parseDamageString("foo")  // Returns 0 (invalid format)
//
// ADDED: parseDamageString converts dice notation strings to average damage values.
// It supports standard RPG dice notation including modifiers and plain numbers.
//
// Supported formats:
// - Plain numbers: "5", "10"
// - Dice notation: "1d6", "2d8", "3d10"
// - Dice with modifiers: "1d6+2", "2d4-1"
// - Shorthand: "d6" (implies 1d6)
//
// Calculation method: Returns mathematical average of dice rolls plus any modifiers
func parseDamageString(damage string) int <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "parseDamageString",
                "damage":   damage,
        })
        logger.Debug("parsing damage string")

        // Regular expression to match dice notation: XdY+Z
        re := regexp.MustCompile(`^(\d+)?d(\d+)(?:\+(\d+))?$`)

        // If it's just a number, return it
        if num, err := strconv.Atoi(damage); err == nil </span><span class="cov8" title="1">{
                logger.WithField("value", num).Info("parsed plain number")
                return num
        }</span>

        <span class="cov8" title="1">matches := re.FindStringSubmatch(damage)
        if matches == nil </span><span class="cov8" title="1">{
                logger.Warn("invalid dice notation format")
                return 0
        }</span>

        // Parse components
        <span class="cov8" title="1">numDice := 1
        if matches[1] != "" </span><span class="cov8" title="1">{
                var err error
                numDice, err = strconv.Atoi(matches[1])
                if err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("failed to parse number of dice")
                        return 0
                }</span>
        }

        <span class="cov8" title="1">dieSize, err := strconv.Atoi(matches[2])
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to parse die size")
                return 0
        }</span>

        <span class="cov8" title="1">modifier := 0
        if matches[3] != "" </span><span class="cov8" title="1">{
                var err error
                modifier, err = strconv.Atoi(matches[3])
                if err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("failed to parse modifier")
                        return 0
                }</span>
        }

        // Calculate average damage
        <span class="cov8" title="1">averageDamage := int(float64(numDice) * (float64(dieSize) + 1) / 2)
        result := averageDamage + modifier

        logger.WithFields(logrus.Fields{
                "numDice":  numDice,
                "dieSize":  dieSize,
                "modifier": modifier,
                "result":   result,
        }).Info("calculated average damage")

        return result</span>
}

// ADDED: min returns the smaller of two integer values.
// This is a simple utility function for integer comparisons.
//
// Parameters:
//   - a: First integer to compare
//   - b: Second integer to compare
//
// Returns:
//   - int: The smaller of the two input values
//
// Note: This function provides basic minimum value logic used throughout the server.
func min(a, b int) int <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "min",
                "a":        a,
                "b":        b,
        })
        logger.Debug("comparing two integers")

        if a &lt; b </span><span class="cov8" title="1">{
                logger.WithField("result", a).Debug("returning first value")
                return a
        }</span>
        <span class="cov8" title="1">logger.WithField("result", b).Debug("returning second value")
        return b</span>
}

// ADDED: isStaticFileRequest determines if an HTTP request path is for a static file resource.
// It checks the file extension against a list of common web static file types.
//
// Parameters:
//   - path: URL path to examine for static file characteristics
//
// Returns:
//   - bool: true if path appears to be a static file, false otherwise
//
// Recognized static file extensions:
// - Web assets: .html, .css, .js
// - Images: .jpg, .jpeg, .png, .gif, .svg, .ico
// - Fonts: .woff, .woff2, .ttf, .eot
//
// This function helps route requests between static file serving and RPC handling.
func isStaticFileRequest(path string) bool <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "isStaticFileRequest",
                "path":     path,
        })
        logger.Debug("checking if path is static file")

        // Add common static file extensions
        staticExtensions := []string{
                ".html", ".css", ".js", ".jpg", ".jpeg",
                ".png", ".gif", ".svg", ".ico", ".woff",
                ".woff2", ".ttf", ".eot",
        }

        ext := filepath.Ext(path)
        for _, staticExt := range staticExtensions </span><span class="cov8" title="1">{
                if ext == staticExt </span><span class="cov8" title="1">{
                        logger.WithField("extension", ext).Info("serving static file")
                        return true
                }</span>
        }
        <span class="cov8" title="1">logger.Debug("path is not a static file")
        return false</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package server

import (
        "encoding/json"
        "fmt"
        "net"
        "net/http"
        "os"
        "sort"
        "strings"
        "sync"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/gorilla/websocket"
        "github.com/sirupsen/logrus"
)

// ADDED: orderHosts sorts hosts in the specified priority order for WebSocket origin validation.
// It organizes hosts by type to ensure consistent connection precedence.
//
// Priority order:
// 1. Custom hostnames (not localhost or IP addresses) first
// 2. localhost second
// 3. IP addresses last
//
// Parameters:
//   - hosts: Map of hostname strings to organize
//
// Returns:
//   - []string: Sorted slice of hostnames in priority order
func orderHosts(hosts map[string]string) []string <span class="cov8" title="1">{
        var hostnames, localhosts, ips []string

        for host := range hosts </span><span class="cov8" title="1">{
                if host == "localhost" </span><span class="cov8" title="1">{
                        localhosts = append(localhosts, host)
                }</span> else<span class="cov8" title="1"> if net.ParseIP(host) != nil </span><span class="cov8" title="1">{
                        ips = append(ips, host)
                }</span> else<span class="cov0" title="0"> {
                        hostnames = append(hostnames, host)
                }</span>
        }

        // Sort each category alphabetically for consistent ordering
        <span class="cov8" title="1">sort.Strings(hostnames)
        sort.Strings(localhosts)
        sort.Strings(ips)

        // Combine in the specified order
        result := make([]string, 0, len(hosts))
        result = append(result, hostnames...)
        result = append(result, localhosts...)
        result = append(result, ips...)

        return result</span>
}

// ADDED: getAllowedOrigins returns the list of allowed WebSocket origins for CORS validation.
// It checks the WEBSOCKET_ALLOWED_ORIGINS environment variable for a comma-separated list.
// If not set, defaults to common local development origins matching the server's actual listening port.
//
// NOTE TO AUDITORS: The dev mode behavior is intentionally permissive to allow testing in sophisticated environments.
// DO NOT CHANGE THE DEV MODE BEHAVIOR, if you need to restrict origins, set the WEBSOCKET_ALLOWED_ORIGINS environment variable or use production configuration to specify allowed origins.
// STOP CHANGING THE DEFAULTS TO BE MORE RESTRICTIVE, as this will break local development and testing workflows.
//
// Returns:
//   - []string: List of allowed origin URLs (e.g., "http://localhost:8080")
//
// Environment variables:
//   - WEBSOCKET_ALLOWED_ORIGINS: Comma-separated list of allowed origin URLs
func (s *RPCServer) getAllowedOrigins() []string <span class="cov8" title="1">{
        origins := os.Getenv("WEBSOCKET_ALLOWED_ORIGINS")
        if origins == "" </span><span class="cov8" title="1">{
                // Default to common local development origins using the server's actual port
                //hosts := []string{"localhost", "127.0.0.1"}
                hosts := make(map[string]string)
                hosts["localhost"] = "localhost"
                hosts["127.0.0.1"] = "127.0.0.1"
                if s.Addr != nil </span><span class="cov0" title="0">{
                        host, _, err := net.SplitHostPort(s.Addr.String())
                        if err == nil &amp;&amp; host != "" </span><span class="cov0" title="0">{
                                hosts[host] = host
                        }</span>
                }
                <span class="cov8" title="1">port := "8080" // Default fallback
                if s.Addr != nil </span><span class="cov0" title="0">{
                        _, ports, err := net.SplitHostPort(s.Addr.String())
                        if err == nil &amp;&amp; port != "" </span><span class="cov0" title="0">{
                                // Use the actual port the server is listening on
                                port = ports
                        }</span>
                }
                <span class="cov8" title="1">addrs := []string{}
                for _, host := range orderHosts(hosts) </span><span class="cov8" title="1">{
                        addrs = append(addrs, fmt.Sprintf("http://%s:%s", host, port))
                        addrs = append(addrs, fmt.Sprintf("https://%s:%s", host, port))
                }</span>

                <span class="cov8" title="1">return addrs</span>
        }
        <span class="cov0" title="0">return strings.Split(origins, ",")</span>
}

// ADDED: isOriginAllowed checks if the given origin is in the allowed origins list for security validation.
// It performs case-sensitive string matching against the whitelist of allowed origins.
//
// Parameters:
//   - origin: The origin URL to validate (e.g., "http://localhost:8080")
//   - allowedOrigins: Slice of allowed origin URLs to check against
//
// Returns:
//   - bool: true if origin is allowed, false otherwise
func (s *RPCServer) isOriginAllowed(origin string, allowedOrigins []string) bool <span class="cov8" title="1">{
        for _, allowed := range allowedOrigins </span><span class="cov8" title="1">{
                if strings.TrimSpace(allowed) == origin </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// ADDED: upgrader creates and configures a WebSocket upgrader instance for handling HTTP to WebSocket protocol upgrades.
// It sets buffer sizes and implements origin checking for security purposes.
//
// Configuration:
//   - ReadBufferSize: 1024 bytes for incoming WebSocket frames
//   - WriteBufferSize: 1024 bytes for outgoing WebSocket frames
//   - CheckOrigin: Validates request origin against allowed origins list
//
// Security: The CheckOrigin function prevents cross-site WebSocket hijacking by validating
// request origins against the configured allowed origins list.
//
// Returns:
//   - *websocket.Upgrader: Configured upgrader instance for WebSocket connections
func (s *RPCServer) upgrader() *websocket.Upgrader <span class="cov8" title="1">{
        var upgrader = websocket.Upgrader{
                ReadBufferSize:  1024,
                WriteBufferSize: 1024,
                CheckOrigin: func(r *http.Request) bool </span><span class="cov8" title="1">{
                        origin := r.Header.Get("Origin")
                        allowedOrigins := s.getAllowedOrigins()
                        allowed := s.isOriginAllowed(origin, allowedOrigins)

                        if !allowed </span><span class="cov8" title="1">{
                                logrus.WithFields(logrus.Fields{
                                        "origin":         origin,
                                        "allowedOrigins": allowedOrigins,
                                }).Warn("WebSocket connection rejected: origin not allowed")
                        }</span>

                        <span class="cov8" title="1">return allowed</span>
                },
        }
        <span class="cov8" title="1">return &amp;upgrader</span>
}

// ADDED: wsConnection represents a WebSocket connection with thread-safe operations.
// It wraps the standard websocket.Conn with a mutex for concurrent access control.
//
// Fields:
//   - conn: The underlying WebSocket connection handler
//   - mu: Mutex to ensure thread-safe access to the connection
//
// Thread Safety: All write operations to the WebSocket connection should be protected
// by the mutex to prevent concurrent write panics.
//
// Related types:
//   - websocket.Conn from "github.com/gorilla/websocket"
type wsConnection struct {
        conn *websocket.Conn
        mu   sync.Mutex
}

// RPCRequest represents a JSON-RPC 2.0 request message structure.
// It encapsulates all required fields for RPC method invocation over WebSocket.
//
// Fields:
//   - JSONRPC: Protocol version identifier (always "2.0")
//   - Method: RPC method name to invoke
//   - Params: Method parameters as a flexible map structure
//   - ID: Request identifier for matching responses
//
// Related standards: JSON-RPC 2.0 specification
type RPCRequest struct {
        JSONRPC string                 `json:"jsonrpc"`
        Method  string                 `json:"method"`
        Params  map[string]interface{} `json:"params"`
        ID      interface{}            `json:"id"`
}

// NewResponse creates a new JSON-RPC 2.0 success response message.
// It formats the result data according to JSON-RPC 2.0 specification.
//
// Parameters:
//   - id: Request identifier to match with original request
//   - result: Response data/payload to return to client
//
// Returns:
//   - interface{}: JSON-RPC 2.0 formatted response object
func NewResponse(id, result interface{}) interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "jsonrpc": "2.0",
                "result":  result,
                "id":      id,
        }
}</span>

// NewErrorResponse creates a new JSON-RPC 2.0 error response message.
// It formats error information according to JSON-RPC 2.0 specification.
//
// Parameters:
//   - id: Request identifier to match with original request
//   - err: Error object containing failure details
//
// Returns:
//   - interface{}: JSON-RPC 2.0 formatted error response object with code -32000
func NewErrorResponse(id interface{}, err error) interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "jsonrpc": "2.0",
                "error": map[string]interface{}{
                        "code":    -32000,
                        "message": err.Error(),
                },
                "id": id,
        }
}</span>

// HandleWebSocket manages WebSocket connections for real-time game communication.
// It upgrades HTTP connections to WebSocket protocol and handles bidirectional message flow.
//
// This method:
// 1. Retrieves the player session from request context
// 2. Upgrades the HTTP connection to WebSocket
// 3. Sends session confirmation to client
// 4. Spawns goroutines for message handling (send/receive)
// 5. Manages connection lifecycle and cleanup
//
// Parameters:
//   - w: HTTP response writer for the upgrade
//   - r: HTTP request containing session context
//
// Connection management:
//   - Automatic cleanup on disconnect
//   - Session state synchronization
//   - Bidirectional message queuing
func (s *RPCServer) HandleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logger := logrus.WithField("function", "HandleWebSocket")
        session := r.Context().Value(sessionKey).(*PlayerSession)
        if session == nil </span><span class="cov0" title="0">{
                logrus.Error("no session in context")
                return
        }</span>

        <span class="cov0" title="0">conn, err := s.upgrader().Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("websocket upgrade failed")
                return
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Send session confirmation
        if err := conn.WriteJSON(map[string]interface{}{
                "jsonrpc": "2.0",
                "result": map[string]string{
                        "session_id": session.SessionID,
                },
                "id": 0,
        }); err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("failed to send session confirmation")
                return
        }</span>

        <span class="cov0" title="0">session.WSConn = conn
        logrus.Info("websocket connection established")

        // Message handling loop
        for </span><span class="cov0" title="0">{
                var req RPCRequest
                if err := conn.ReadJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        break</span>
                }

                // Inject session ID into params
                <span class="cov0" title="0">if req.Params == nil </span><span class="cov0" title="0">{
                        req.Params = make(map[string]interface{})
                }</span>
                <span class="cov0" title="0">req.Params["session_id"] = session.SessionID

                // Convert string to RPCMethod type
                method := RPCMethod(req.Method)

                // Convert params to json.RawMessage
                paramsJSON, err := json.Marshal(req.Params)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to marshal params")
                        conn.WriteJSON(NewErrorResponse(req.ID, err))
                        continue</span>
                }

                <span class="cov0" title="0">result, err := s.handleMethod(method, paramsJSON)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("RPC method execution failed")
                        conn.WriteJSON(NewErrorResponse(req.ID, err))
                        continue</span>
                }

                <span class="cov0" title="0">if err := conn.WriteJSON(NewResponse(req.ID, result)); err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to write response")
                        break</span>
                }
        }
}

// ADDED: validateSession validates and retrieves a player session from RPC parameters.
// It extracts the session ID from the parameters map and returns the corresponding session.
//
// Parameters:
//   - params: Map containing RPC parameters, must include "session_id" key
//
// Returns:
//   - *PlayerSession: Valid player session if found
//   - error: ErrInvalidSession if session ID is missing or session not found
//
// This function is used by RPC handlers to authenticate and authorize requests.
func (s *RPCServer) validateSession(params map[string]interface{}) (*PlayerSession, error) <span class="cov0" title="0">{
        sessionID, ok := params["session_id"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidSession
        }</span>

        <span class="cov0" title="0">return s.getSessionSafely(sessionID)</span>
}

// ADDED: sendWSResponse sends a JSON-RPC 2.0 response message over a WebSocket connection.
// It constructs a properly formatted response and handles thread-safe transmission.
//
// Parameters:
//   - wsConn: The WebSocket connection wrapper (must not be nil)
//   - result: The result payload to include in the response (JSON-serializable)
//   - id: The request ID to correlate with the original request
//
// Response format follows JSON-RPC 2.0 specification:
//   - jsonrpc: "2.0"
//   - result: The provided result value
//   - id: The provided request ID
//
// Thread safety: Uses the connection's mutex lock to prevent concurrent write operations.
// Errors are logged but not returned to avoid breaking the message flow.
func (s *RPCServer) sendWSResponse(wsConn *wsConnection, result, id interface{}) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "sendWSResponse",
                "id":       id,
        })
        logger.Debug("sending websocket response")

        response := struct {
                JSONRPC string      `json:"jsonrpc"`
                Result  interface{} `json:"result"`
                ID      interface{} `json:"id"`
        }{
                JSONRPC: "2.0",
                Result:  result,
                ID:      id,
        }

        wsConn.mu.Lock()
        defer wsConn.mu.Unlock()

        if err := wsConn.conn.WriteJSON(response); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to write websocket response")
        }</span> else<span class="cov0" title="0"> {
                logger.Debug("websocket response sent successfully")
        }</span>
}

// ADDED: sendWSError sends a JSON-RPC 2.0 error response over the WebSocket connection.
// It constructs a properly formatted error response following JSON-RPC 2.0 specification.
//
// Parameters:
//   - wsConn: The WebSocket connection wrapper to send the response on
//   - code: The JSON-RPC error code to include (standard or custom)
//   - message: Human-readable error message describing the error
//   - data: Optional additional error details (may be nil)
//   - id: The JSON-RPC request ID the error responds to
//
// Error response structure:
//   - jsonrpc: "2.0"
//   - error: Object containing code, message, and optional data
//   - id: Original request identifier
//
// Thread safety: Uses mutex locking to prevent concurrent write operations.
// Write errors are logged but not returned to avoid breaking message flow.
func (s *RPCServer) sendWSError(wsConn *wsConnection, code int, message string, data, id interface{}) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "sendWSError",
                "id":       id,
                "code":     code,
        })
        logger.Debug("sending websocket error response")

        response := struct {
                JSONRPC string `json:"jsonrpc"`
                Error   struct {
                        Code    int         `json:"code"`
                        Message string      `json:"message"`
                        Data    interface{} `json:"data,omitempty"`
                } `json:"error"`
                ID interface{} `json:"id"`
        }{
                JSONRPC: "2.0",
                Error: struct {
                        Code    int         `json:"code"`
                        Message string      `json:"message"`
                        Data    interface{} `json:"data,omitempty"`
                }{
                        Code:    code,
                        Message: message,
                        Data:    data,
                },
                ID: id,
        }

        wsConn.mu.Lock()
        defer wsConn.mu.Unlock()

        if err := wsConn.conn.WriteJSON(response); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to write websocket error response")
        }</span> else<span class="cov0" title="0"> {
                logger.Debug("websocket error response sent successfully")
        }</span>
}

// ADDED: getSessionSafely retrieves and validates a player session with thread-safe access.
// It performs atomic session lookup, validation, and timestamp updates to prevent race conditions.
//
// This function ensures:
// - Thread-safe session map access using read locks
// - Session existence and validity validation
// - WebSocket connection presence verification
// - Atomic LastActive timestamp updates
//
// Parameters:
//   - sessionID: The session ID to look up (must not be empty)
//
// Returns:
//   - *PlayerSession: Valid session if found and has active WebSocket connection
//   - error: ErrInvalidSession if not found, invalid, or missing WebSocket connection
//
// Thread Safety: Prevents TOCTOU race conditions by maintaining locks during
// validation and ensuring returned session references remain valid.
func (s *RPCServer) getSessionSafely(sessionID string) (*PlayerSession, error) <span class="cov8" title="1">{
        if sessionID == "" </span><span class="cov8" title="1">{
                return nil, ErrInvalidSession
        }</span>

        <span class="cov8" title="1">s.mu.RLock()
        session, exists := s.sessions[sessionID]
        if !exists </span><span class="cov8" title="1">{
                s.mu.RUnlock()
                return nil, ErrInvalidSession
        }</span>

        // Additional validation while still holding the lock
        <span class="cov8" title="1">if session.WSConn == nil </span><span class="cov8" title="1">{
                s.mu.RUnlock()
                return nil, ErrInvalidSession
        }</span>

        // Increment reference count and update last active timestamp while holding lock
        <span class="cov8" title="1">session.addRef()
        session.LastActive = time.Now()
        s.mu.RUnlock()

        return session, nil</span>
}

// WebSocketBroadcaster manages real-time event broadcasting to all connected WebSocket clients.
// It bridges the game event system with WebSocket connections for live multiplayer updates.
//
// Core responsibilities:
// - Event subscription and filtering for relevant game events
// - Broadcasting events to all active WebSocket connections
// - Connection lifecycle management and cleanup
// - Message formatting and serialization for WebSocket transmission
//
// Fields:
//   - server: Reference to the RPC server for accessing sessions and connections
//   - eventTypes: Set of EventType values that should be broadcast to clients
//   - mu: Mutex for thread-safe access to connection management
//   - active: Flag indicating if the broadcaster is running
//
// The broadcaster subscribes to specific game events and distributes them to all
// connected WebSocket clients in real-time, enabling live multiplayer gameplay.
type WebSocketBroadcaster struct {
        server     *RPCServer
        eventTypes map[game.EventType]bool
        mu         sync.RWMutex
        active     bool
}

// NewWebSocketBroadcaster creates and initializes a new WebSocket event broadcaster.
//
// Parameters:
//   - server: The RPC server instance containing WebSocket connections
//
// Returns:
//   - *WebSocketBroadcaster: Configured broadcaster ready for event subscription
func NewWebSocketBroadcaster(server *RPCServer) *WebSocketBroadcaster <span class="cov8" title="1">{
        return &amp;WebSocketBroadcaster{
                server:     server,
                eventTypes: make(map[game.EventType]bool),
                active:     false,
        }
}</span>

// Start activates the WebSocket broadcaster and subscribes to relevant game events.
// It registers event handlers for multiplayer-relevant events that should be broadcast.
//
// Subscribed events:
//   - Movement events: Player position changes
//   - Combat events: Attacks, damage, death
//   - Spell casting: Magic effects and targeting
//   - Chat/communication: Player messages
//   - World changes: Item drops, object interactions
func (wb *WebSocketBroadcaster) Start() <span class="cov8" title="1">{
        wb.mu.Lock()
        defer wb.mu.Unlock()

        if wb.active </span><span class="cov0" title="0">{
                return // Already started
        }</span>

        // Subscribe to events that should be broadcast to all clients
        <span class="cov8" title="1">wb.eventTypes[game.EventMovement] = true
        wb.eventTypes[game.EventDamage] = true
        wb.eventTypes[game.EventSpellCast] = true
        wb.eventTypes[game.EventDeath] = true
        wb.eventTypes[game.EventItemDrop] = true
        wb.eventTypes[EventCombatStart] = true
        wb.eventTypes[EventCombatEnd] = true

        // Register as event handler for each type
        for eventType := range wb.eventTypes </span><span class="cov8" title="1">{
                wb.server.eventSys.Subscribe(eventType, wb.handleEvent)
        }</span>

        <span class="cov8" title="1">wb.active = true
        logrus.Info("WebSocket broadcaster started and subscribed to game events")</span>
}

// Stop deactivates the WebSocket broadcaster and unsubscribes from game events.
func (wb *WebSocketBroadcaster) Stop() <span class="cov0" title="0">{
        wb.mu.Lock()
        defer wb.mu.Unlock()

        wb.active = false
        wb.eventTypes = make(map[game.EventType]bool)
        logrus.Info("WebSocket broadcaster stopped")
}</span>

// handleEvent processes game events and broadcasts them to all connected WebSocket clients.
//
// Parameters:
//   - event: The game event to broadcast
func (wb *WebSocketBroadcaster) handleEvent(event game.GameEvent) <span class="cov8" title="1">{
        wb.mu.RLock()
        active := wb.active
        shouldBroadcast := wb.eventTypes[event.Type]
        wb.mu.RUnlock()

        if !active || !shouldBroadcast </span><span class="cov0" title="0">{
                return
        }</span>

        // Create WebSocket event message
        <span class="cov8" title="1">wsEvent := map[string]interface{}{
                "type":      "game_event",
                "event":     event.Type,
                "source":    event.SourceID,
                "target":    event.TargetID,
                "data":      event.Data,
                "timestamp": event.Timestamp,
        }

        // Broadcast to all connected WebSocket clients
        wb.broadcastToAll(wsEvent)</span>
}

// broadcastToAll sends a message to all active WebSocket connections.
//
// Parameters:
//   - message: The message data to broadcast (must be JSON-serializable)
func (wb *WebSocketBroadcaster) broadcastToAll(message interface{}) <span class="cov8" title="1">{
        wb.server.mu.RLock()
        sessions := make([]*PlayerSession, 0, len(wb.server.sessions))
        for _, session := range wb.server.sessions </span><span class="cov8" title="1">{
                if session != nil &amp;&amp; session.WSConn != nil &amp;&amp; session.Connected </span><span class="cov8" title="1">{
                        sessions = append(sessions, session)
                }</span>
        }
        <span class="cov8" title="1">wb.server.mu.RUnlock()

        if len(sessions) == 0 </span><span class="cov0" title="0">{
                return // No active WebSocket connections
        }</span>

        <span class="cov8" title="1">successCount := 0
        for _, session := range sessions </span><span class="cov8" title="1">{
                // Double-check connection is still valid before writing
                if session.WSConn != nil </span><span class="cov8" title="1">{
                        // Safely attempt to write, catching any panics from invalid connections
                        func() </span><span class="cov8" title="1">{
                                defer func() </span><span class="cov8" title="1">{
                                        if r := recover(); r != nil </span><span class="cov8" title="1">{
                                                logrus.WithFields(logrus.Fields{
                                                        "sessionID": session.SessionID,
                                                        "error":     fmt.Sprintf("panic during WebSocket write: %v", r),
                                                }).Warn("recovered from WebSocket write panic")
                                        }</span>
                                }()

                                <span class="cov8" title="1">if err := session.WSConn.WriteJSON(message); err != nil </span><span class="cov0" title="0">{
                                        logrus.WithFields(logrus.Fields{
                                                "sessionID": session.SessionID,
                                                "error":     err.Error(),
                                        }).Warn("failed to broadcast to WebSocket client")
                                }</span> else<span class="cov0" title="0"> {
                                        successCount++
                                }</span>
                        }()
                }
        }

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "totalClients":    len(sessions),
                "successfulSends": successCount,
                "failedSends":     len(sessions) - successCount,
        }).Debug("WebSocket broadcast completed")</span>
}

// Package server implements the game server and combat system functionality
</pre>
		
		<pre class="file" id="file62" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"
)

// findUntestedFiles finds Go source files that don't have corresponding test files
func findUntestedFiles(rootDir string) ([]string, error) <span class="cov8" title="1">{
        sourceFiles := make(map[string]bool)
        testFiles := make(map[string]bool)
        var untestedFiles []string

        // Walk through the directory tree
        err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                // Skip directories and non-Go files
                <span class="cov8" title="1">if info.IsDir() || !strings.HasSuffix(path, ".go") </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Get relative path from root directory
                <span class="cov8" title="1">relPath, err := filepath.Rel(rootDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">fileName := info.Name()

                if strings.HasSuffix(fileName, "_test.go") </span><span class="cov8" title="1">{
                        // This is a test file - extract the base name
                        baseName := strings.TrimSuffix(fileName, "_test.go")
                        dir := filepath.Dir(relPath)
                        baseFile := filepath.Join(dir, baseName+".go")
                        testFiles[baseFile] = true
                }</span> else<span class="cov8" title="1"> {
                        // This is a source file
                        sourceFiles[relPath] = true
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Find source files without corresponding test files
        <span class="cov8" title="1">for sourceFile := range sourceFiles </span><span class="cov8" title="1">{
                if !testFiles[sourceFile] </span><span class="cov8" title="1">{
                        // Skip main.go files as they typically don't have tests
                        if strings.HasSuffix(sourceFile, "main.go") </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">untestedFiles = append(untestedFiles, sourceFile)</span>
                }
        }

        // Sort the results for consistent output
        <span class="cov8" title="1">sort.Strings(untestedFiles)

        return untestedFiles, nil</span>
}

func main() <span class="cov0" title="0">{
        rootDir := "."
        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                rootDir = os.Args[1]
        }</span>

        <span class="cov0" title="0">untestedFiles, err := findUntestedFiles(rootDir)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(untestedFiles) == 0 </span><span class="cov0" title="0">{
                fmt.Println("All Go source files have corresponding test files!")
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Found %d Go source files without test files:\n\n", len(untestedFiles))

        for _, file := range untestedFiles </span><span class="cov0" title="0">{
                fmt.Println(file)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nSummary: %d files need test coverage\n", len(untestedFiles))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
