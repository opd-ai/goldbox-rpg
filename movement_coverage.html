
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">goldbox-rpg/pkg/server/combat.go (0.0%)</option>
				
				<option value="file1">goldbox-rpg/pkg/server/handlers.go (0.0%)</option>
				
				<option value="file2">goldbox-rpg/pkg/server/movement.go (100.0%)</option>
				
				<option value="file3">goldbox-rpg/pkg/server/process.go (0.0%)</option>
				
				<option value="file4">goldbox-rpg/pkg/server/server.go (0.0%)</option>
				
				<option value="file5">goldbox-rpg/pkg/server/session.go (0.0%)</option>
				
				<option value="file6">goldbox-rpg/pkg/server/spell.go (0.0%)</option>
				
				<option value="file7">goldbox-rpg/pkg/server/spells.go (0.0%)</option>
				
				<option value="file8">goldbox-rpg/pkg/server/state.go (0.0%)</option>
				
				<option value="file9">goldbox-rpg/pkg/server/types.go (100.0%)</option>
				
				<option value="file10">goldbox-rpg/pkg/server/util.go (41.9%)</option>
				
				<option value="file11">goldbox-rpg/pkg/server/websocket.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package server implements the game server and combat system functionality
package server

import (
        "fmt"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

var DefaultTurnDuration = 10 * time.Second

// CombatState represents the current state of a combat encounter.
// It tracks participating entities, round count, combat area, and active effects.
type CombatState struct {
        // ActiveCombatants contains the IDs of all entities currently in combat
        ActiveCombatants []string `yaml:"combat_active_entities"`
        // RoundCount tracks the current combat round number
        RoundCount int `yaml:"combat_round_count"`
        // CombatZone defines the center position of the combat area
        CombatZone game.Position `yaml:"combat_zone_center"`
        // StatusEffects maps entity IDs to their active effects
        StatusEffects map[string][]game.Effect `yaml:"combat_status_effects"`
}

// TurnManager handles combat turn order and initiative tracking.
// It manages the flow of combat rounds and tracks allied groups.
type TurnManager struct {
        // CurrentRound represents the current combat round number
        CurrentRound int `yaml:"turn_current_round"`
        // Initiative holds entity IDs in their initiative order
        Initiative []string `yaml:"turn_initiative_order"`
        // CurrentIndex tracks the current actor's position in the initiative order
        CurrentIndex int `yaml:"turn_current_index"`
        // IsInCombat indicates whether combat is currently active
        IsInCombat bool `yaml:"turn_in_combat"`
        // CombatGroups maps entity IDs to their allied group members
        CombatGroups map[string][]string `yaml:"turn_combat_groups"`
        // DelayedActions holds actions to be executed at a later time
        DelayedActions []DelayedAction `yaml:"turn_delayed_actions"`
        turnTimer      *time.Timer     // Timer for turn timeouts
        turnDuration   time.Duration   // Duration for turn timeouts
}

func NewTurnManager() *TurnManager <span class="cov0" title="0">{
        return &amp;TurnManager{
                CurrentRound:   0,
                Initiative:     []string{},
                CurrentIndex:   0,
                IsInCombat:     false,
                CombatGroups:   make(map[string][]string),
                DelayedActions: make([]DelayedAction, 0),
                turnTimer:      &amp;time.Timer{},
                turnDuration:   DefaultTurnDuration,
        }
}</span>

// Update applies the provided updates to the TurnManager.
//
// Parameters:
//   - turnUpdates: Map of field names to their new values
//
// Returns:
//   - any: Updated TurnManager instance
func (tm *TurnManager) Update(turnUpdates map[string]interface{}) error <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "Update",
        }).Debug("updating turn manager state")

        // Update fields if present in updates map
        if round, ok := turnUpdates["current_round"].(int); ok </span><span class="cov0" title="0">{
                tm.CurrentRound = round
        }</span>

        <span class="cov0" title="0">if initiative, ok := turnUpdates["initiative_order"].([]string); ok </span><span class="cov0" title="0">{
                tm.Initiative = initiative
        }</span>

        <span class="cov0" title="0">if index, ok := turnUpdates["current_index"].(int); ok </span><span class="cov0" title="0">{
                tm.CurrentIndex = index
        }</span>

        <span class="cov0" title="0">if inCombat, ok := turnUpdates["in_combat"].(bool); ok </span><span class="cov0" title="0">{
                tm.IsInCombat = inCombat
        }</span>

        <span class="cov0" title="0">if groups, ok := turnUpdates["combat_groups"].(map[string][]string); ok </span><span class="cov0" title="0">{
                tm.CombatGroups = groups
        }</span>

        <span class="cov0" title="0">if actions, ok := turnUpdates["delayed_actions"].([]DelayedAction); ok </span><span class="cov0" title="0">{
                tm.DelayedActions = actions
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "Update",
        }).Debug("turn manager state updated")

        return nil</span>
}

// Clone creates and returns a deep copy of the TurnManager
func (tm *TurnManager) Clone() *TurnManager <span class="cov0" title="0">{
        // Create new TurnManager
        clone := &amp;TurnManager{
                CurrentRound:   tm.CurrentRound,
                CurrentIndex:   tm.CurrentIndex,
                IsInCombat:     tm.IsInCombat,
                Initiative:     make([]string, len(tm.Initiative)),
                CombatGroups:   make(map[string][]string),
                DelayedActions: make([]DelayedAction, len(tm.DelayedActions)),
        }

        // Copy initiative slice
        copy(clone.Initiative, tm.Initiative)

        // Deep copy combat groups map
        for k, v := range tm.CombatGroups </span><span class="cov0" title="0">{
                groupCopy := make([]string, len(v))
                copy(groupCopy, v)
                clone.CombatGroups[k] = groupCopy
        }</span>

        // Copy delayed actions
        <span class="cov0" title="0">copy(clone.DelayedActions, tm.DelayedActions)

        return clone</span>
}

func (tm *TurnManager) Serialize() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "current_round":    tm.CurrentRound,
                "initiative_order": tm.Initiative,
                "current_index":    tm.CurrentIndex,
                "in_combat":        tm.IsInCombat,
                "combat_groups":    tm.CombatGroups,
                "delayed_actions":  tm.DelayedActions,
        }
}</span>

// DelayedAction represents a combat action that will be executed at a specific time.
type DelayedAction struct {
        // ActorID is the ID of the entity performing the action
        ActorID string `yaml:"action_actor_id"`
        // ActionType defines the type of action to be performed
        ActionType string `yaml:"action_type"`
        // Target specifies the position where the action will take effect
        Target game.Position `yaml:"action_target_pos"`
        // TriggerTime determines when the action should be executed
        TriggerTime game.GameTime `yaml:"action_trigger_time"`
        // Parameters contains additional data needed for the action
        Parameters []string `yaml:"action_parameters"`
}

// IsCurrentTurn checks if the given entity is the current actor in combat.
//
// Parameters:
//   - entityID: The ID of the entity to check
//
// Returns:
//   - bool: true if it's the entity's turn, false otherwise
func (tm *TurnManager) IsCurrentTurn(entityID string) bool <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "IsCurrentTurn",
                "entityID": entityID,
        }).Debug("checking if entity has current turn")

        if !tm.IsInCombat || tm.CurrentIndex &gt;= len(tm.Initiative) </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":      "IsCurrentTurn",
                        "isInCombat":    tm.IsInCombat,
                        "currentIndex":  tm.CurrentIndex,
                        "initiativeLen": len(tm.Initiative),
                }).Debug("combat inactive or invalid index")
                return false
        }</span>

        <span class="cov0" title="0">isCurrent := tm.Initiative[tm.CurrentIndex] == entityID
        logrus.WithFields(logrus.Fields{
                "function":  "IsCurrentTurn",
                "entityID":  entityID,
                "isCurrent": isCurrent,
        }).Debug("turn check complete")

        return isCurrent</span>
}

// StartCombat initializes a new combat encounter with the given initiative order.
//
// Parameters:
//   - initiative: Ordered slice of entity IDs representing turn order
func (tm *TurnManager) StartCombat(initiative []string) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function":        "StartCombat",
                "initiativeCount": len(initiative),
        }).Debug("starting new combat")

        tm.IsInCombat = true
        tm.Initiative = initiative
        tm.CurrentIndex = 0
        tm.CurrentRound = 1
        tm.startTurnTimer()

        logrus.WithFields(logrus.Fields{
                "function": "StartCombat",
                "round":    tm.CurrentRound,
        }).Info("combat started successfully")
}</span>

func (tm *TurnManager) startTurnTimer() <span class="cov0" title="0">{
        if tm.turnTimer != nil </span><span class="cov0" title="0">{
                tm.turnTimer.Stop()
        }</span>
        <span class="cov0" title="0">tm.turnTimer = time.AfterFunc(tm.turnDuration, tm.endTurn)</span>
}

func (tm *TurnManager) endTurn() <span class="cov0" title="0">{
        currentActor := tm.Initiative[tm.CurrentIndex]

        // Check if actor took action
        actorHasAction := false
        for _, action := range tm.DelayedActions </span><span class="cov0" title="0">{
                if action.ActorID == currentActor </span><span class="cov0" title="0">{
                        actorHasAction = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !actorHasAction </span><span class="cov0" title="0">{
                tm.moveToTopOfInitiative(currentActor)
        }</span>

        // Process delayed actions
        <span class="cov0" title="0">tm.processDelayedActions()

        // Advance turn
        tm.CurrentIndex = (tm.CurrentIndex + 1) % len(tm.Initiative)
        if tm.CurrentIndex == 0 </span><span class="cov0" title="0">{
                tm.CurrentRound++
        }</span>

        <span class="cov0" title="0">if tm.IsInCombat </span><span class="cov0" title="0">{
                tm.startTurnTimer()
        }</span>
}

// AdvanceTurn moves to the next entity in the initiative order.
// Increments the round counter when returning to the first entity.
//
// Returns:
//   - string: The ID of the next entity in the initiative order, or empty string if not in combat
func (tm *TurnManager) AdvanceTurn() string <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function":   "AdvanceTurn",
                "isInCombat": tm.IsInCombat,
        }).Debug("checking combat state")

        if !tm.IsInCombat </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "AdvanceTurn",
                }).Debug("not in combat, returning")
                return ""
        }</span>

        <span class="cov0" title="0">prevIndex := tm.CurrentIndex
        tm.CurrentIndex = (tm.CurrentIndex + 1) % len(tm.Initiative)

        if tm.CurrentIndex == 0 </span><span class="cov0" title="0">{
                tm.CurrentRound++
                logrus.WithFields(logrus.Fields{
                        "function": "AdvanceTurn",
                        "round":    tm.CurrentRound,
                }).Info("new combat round started")
        }</span>

        <span class="cov0" title="0">nextEntity := tm.Initiative[tm.CurrentIndex]
        logrus.WithFields(logrus.Fields{
                "function":   "AdvanceTurn",
                "prevIndex":  prevIndex,
                "nextIndex":  tm.CurrentIndex,
                "nextEntity": nextEntity,
        }).Debug("turn advanced")

        return nextEntity</span>
}

// processDelayedActions checks and executes any delayed actions that are due.
// Removes executed actions from the pending actions list.
func (s *RPCServer) processDelayedActions() <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "processDelayedActions",
        }).Debug("processing delayed actions")

        currentTime := s.state.TimeManager.CurrentTime
        totalActions := len(s.state.TurnManager.DelayedActions)

        logrus.WithFields(logrus.Fields{
                "function":    "processDelayedActions",
                "currentTime": currentTime,
                "actionCount": totalActions,
        }).Debug("checking delayed actions")

        for i := totalActions - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                action := s.state.TurnManager.DelayedActions[i]

                logrus.WithFields(logrus.Fields{
                        "function":    "processDelayedActions",
                        "actionIndex": i,
                        "actorID":     action.ActorID,
                        "actionType":  action.ActionType,
                        "triggerTime": action.TriggerTime,
                }).Debug("checking action timing")

                if isTimeToExecute(currentTime, action.TriggerTime) </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "function":   "processDelayedActions",
                                "actorID":    action.ActorID,
                                "actionType": action.ActionType,
                        }).Info("executing delayed action")

                        s.executeDelayedAction(action)
                        s.state.TurnManager.DelayedActions = append(
                                s.state.TurnManager.DelayedActions[:i],
                                s.state.TurnManager.DelayedActions[i+1:]...,
                        )
                }</span>
        }

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function":         "processDelayedActions",
                "remainingActions": len(s.state.TurnManager.DelayedActions),
        }).Debug("finished processing delayed actions")</span>
}

// checkCombatEnd determines if combat should end based on remaining hostile groups.
//
// Returns:
//   - bool: true if combat ended, false if it should continue
func (s *RPCServer) checkCombatEnd() bool <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function":   "checkCombatEnd",
                "isInCombat": s.state.TurnManager.IsInCombat,
        }).Debug("checking if combat should end")

        if !s.state.TurnManager.IsInCombat </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "checkCombatEnd",
                }).Debug("not in combat, returning")
                return false
        }</span>

        <span class="cov0" title="0">hostileGroups := s.getHostileGroups()
        logrus.WithFields(logrus.Fields{
                "function":          "checkCombatEnd",
                "hostileGroupCount": len(hostileGroups),
        }).Debug("got hostile groups")

        if len(hostileGroups) &lt;= 1 </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "checkCombatEnd",
                }).Info("ending combat - only one or no hostile groups remain")
                s.endCombat()
                return true
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "checkCombatEnd",
        }).Debug("combat continues")
        return false</span>
}

// executeDelayedAction handles the execution of a delayed combat action.
// Implementation depends on the specific action type.
//
// Parameters:
//   - action: The DelayedAction to execute
func (s *RPCServer) executeDelayedAction(action DelayedAction) {<span class="cov0" title="0">
        // Implement the logic to execute the delayed action here
}</span>

// getHostileGroups returns groups of allied entities in combat.
//
// Returns:
//   - [][]string: Slice of entity ID groups, where each group represents allied entities
func (s *RPCServer) getHostileGroups() [][]string <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "getHostileGroups",
        }).Debug("getting hostile groups")

        groups := make([][]string, 0)
        processed := make(map[string]bool)

        logrus.WithFields(logrus.Fields{
                "function":    "getHostileGroups",
                "groupsCount": len(s.state.TurnManager.CombatGroups),
        }).Debug("processing combat groups")

        for id := range s.state.TurnManager.CombatGroups </span><span class="cov0" title="0">{
                if !processed[id] </span><span class="cov0" title="0">{
                        group := s.state.TurnManager.CombatGroups[id]
                        groups = append(groups, group)
                        for _, memberID := range group </span><span class="cov0" title="0">{
                                processed[memberID] = true
                        }</span>

                        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                                "function":     "getHostileGroups",
                                "groupLeader":  id,
                                "membersCount": len(group),
                        }).Debug("processed group")</span>
                }
        }

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function":          "getHostileGroups",
                "hostileGroupCount": len(groups),
        }).Info("hostile groups identified")

        return groups</span>
}

// endCombat terminates the current combat encounter and emits a combat end event.
func (s *RPCServer) endCombat() <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "endCombat",
        }).Debug("ending combat")

        s.state.TurnManager.IsInCombat = false
        s.state.TurnManager.Initiative = nil
        s.state.TurnManager.CurrentIndex = 0

        logrus.WithFields(logrus.Fields{
                "function": "endCombat",
                "rounds":   s.state.TurnManager.CurrentRound,
        }).Info("combat ended")

        s.eventSys.Emit(game.GameEvent{
                Type: EventCombatEnd,
                Data: map[string]interface{}{
                        "rounds_completed": s.state.TurnManager.CurrentRound,
                },
        })

        logrus.WithFields(logrus.Fields{
                "function": "endCombat",
        }).Debug("combat cleanup complete")
}</span>

// applyDamage applies damage to a game object, handling death if applicable.
//
// Parameters:
//   - target: The GameObject receiving damage
//   - damage: Amount of damage to apply
//
// Returns:
//   - error: Error if target cannot receive damage
func (s *RPCServer) applyDamage(target game.GameObject, damage int) error <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "applyDamage",
                "damage":   damage,
                "targetID": target.GetID(),
        }).Debug("applying damage to target")

        if char, ok := target.(*game.Character); ok </span><span class="cov0" title="0">{
                oldHP := char.HP
                char.HP -= damage

                if char.HP &lt; 0 </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "function": "applyDamage",
                                "charID":   char.GetID(),
                        }).Debug("clamping HP to 0")
                        char.HP = 0
                }</span>

                <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                        "function": "applyDamage",
                        "charID":   char.GetID(),
                        "oldHP":    oldHP,
                        "newHP":    char.HP,
                        "damage":   damage,
                }).Info("damage applied to character")

                if char.HP == 0 </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "function": "applyDamage",
                                "charID":   char.GetID(),
                        }).Info("character died from damage")
                        s.handleCharacterDeath(char)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">err := fmt.Errorf("target cannot receive damage")
        logrus.WithFields(logrus.Fields{
                "function": "applyDamage",
                "error":    err.Error(),
        }).Error("invalid target type")
        return err</span>
}

// calculateWeaponDamage computes the total damage for a weapon attack.
//
// Parameters:
//   - weapon: The weapon being used
//   - attacker: The attacking player
//
// Returns:
//   - int: Total calculated damage
func calculateWeaponDamage(weapon *game.Item, attacker *game.Player) int <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function":   "calculateWeaponDamage",
                "weaponID":   weapon.ID,
                "attackerID": attacker.GetID(),
        }).Debug("calculating weapon damage")

        baseDamage := parseDamageString(weapon.Damage)
        strBonus := (attacker.Strength - 10) / 2

        logrus.WithFields(logrus.Fields{
                "function":    "calculateWeaponDamage",
                "baseDamage":  baseDamage,
                "strBonus":    strBonus,
                "totalDamage": baseDamage + strBonus,
        }).Info("damage calculation completed")

        return baseDamage + strBonus
}</span>

// handleCharacterDeath processes a character's death, dropping inventory and emitting event.
//
// Parameters:
//   - character: The Character that died
func (s *RPCServer) handleCharacterDeath(character *game.Character) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function":    "handleCharacterDeath",
                "characterID": character.GetID(),
        }).Debug("handling character death")

        character.SetActive(false)
        dropPosition := character.GetPosition()

        logrus.WithFields(logrus.Fields{
                "function":     "handleCharacterDeath",
                "characterID":  character.GetID(),
                "dropPosition": dropPosition,
                "itemCount":    len(character.Inventory),
        }).Info("processing inventory drops")

        for _, item := range character.Inventory </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleCharacterDeath",
                        "itemID":   item.ID,
                }).Debug("dropping item")
                s.state.WorldState.AddObject(CreateItemDrop(item, character, dropPosition))
        }</span>
        <span class="cov0" title="0">character.Inventory = nil

        logrus.WithFields(logrus.Fields{
                "function":    "handleCharacterDeath",
                "characterID": character.GetID(),
        }).Info("emitting death event")

        s.eventSys.Emit(game.GameEvent{
                Type:     game.EventDeath,
                SourceID: character.GetID(),
                Data: map[string]interface{}{
                        "position": dropPosition,
                },
        })

        logrus.WithFields(logrus.Fields{
                "function": "handleCharacterDeath",
        }).Debug("character death handling complete")</span>
}

// CreateItemDrop creates a new item object when dropped from inventory.
//
// Parameters:
//   - item: The item being dropped
//   - char: The character dropping the item
//   - dropPosition: Where the item should be placed
//
// Returns:
//   - game.GameObject: The created item object
func CreateItemDrop(item game.Item, char *game.Character, dropPosition game.Position) game.GameObject <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function":     "CreateItemDrop",
                "itemID":       item.ID,
                "characterID":  char.GetID(),
                "dropPosition": dropPosition,
        }).Debug("creating new item drop")

        droppedItem := &amp;game.Item{
                ID:         fmt.Sprintf("drop_%s_%s", item.ID, char.GetName()),
                Name:       item.Name,
                Type:       item.Type,
                Damage:     item.Damage,
                AC:         item.AC,
                Weight:     item.Weight,
                Value:      item.Value,
                Properties: item.Properties,
                Position:   dropPosition,
        }

        logrus.WithFields(logrus.Fields{
                "function":    "CreateItemDrop",
                "droppedID":   droppedItem.ID,
                "droppedName": droppedItem.Name,
        }).Info("item drop created")

        return droppedItem
}</span>

// processCombatAction handles weapon attacks during combat.
//
// Parameters:
//   - player: The attacking player
//   - targetID: ID of the attack target
//   - weaponID: ID of the weapon to use (optional)
//
// Returns:
//   - interface{}: Combat result containing success and damage
//   - error: Error if target is invalid or attack fails
func (s *RPCServer) processCombatAction(player *game.Player, targetID, weaponID string) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "processCombatAction",
                "playerID": player.GetID(),
                "targetID": targetID,
                "weaponID": weaponID,
        }).Debug("processing combat action")

        target, exists := s.state.WorldState.Objects[targetID]
        if !exists </span><span class="cov0" title="0">{
                err := fmt.Errorf("invalid target")
                logrus.WithFields(logrus.Fields{
                        "function": "processCombatAction",
                        "error":    err.Error(),
                }).Error("target not found")
                return nil, err
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "processCombatAction",
                "targetID": targetID,
        }).Debug("found valid target")

        var weapon *game.Item
        if weaponID != "" </span><span class="cov0" title="0">{
                weapon = findInventoryItem(player.Inventory, weaponID)
                if weapon == nil &amp;&amp; player.Equipment != nil </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "function": "processCombatAction",
                        }).Debug("checking equipped weapon")
                        w := player.Equipment[game.SlotHands]
                        weapon = &amp;w
                }</span>
        }

        <span class="cov0" title="0">damage := calculateWeaponDamage(weapon, player)
        logrus.WithFields(logrus.Fields{
                "function": "processCombatAction",
                "damage":   damage,
        }).Info("calculated weapon damage")

        if err := s.applyDamage(target, damage); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "processCombatAction",
                        "error":    err.Error(),
                }).Error("failed to apply damage")
                return nil, err
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "success": true,
                "damage":  damage,
        }

        logrus.WithFields(logrus.Fields{
                "function": "processCombatAction",
                "damage":   damage,
        }).Debug("combat action completed successfully")

        return result, nil</span>
}

func (tm *TurnManager) QueueAction(action DelayedAction) error <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "QueueAction",
                "actorID":  action.ActorID,
        })

        if !tm.IsCurrentTurn(action.ActorID) </span><span class="cov0" title="0">{
                logger.Warn("attempt to queue action on wrong turn")
                return fmt.Errorf("not actor's turn")
        }</span>

        <span class="cov0" title="0">action.TriggerTime = game.GameTime{
                RealTime:  time.Now(),
                GameTicks: tm.getCurrentGameTicks(),
                TimeScale: 1.0,
        }

        logger.WithField("triggerTime", action.TriggerTime).Debug("queueing delayed action")
        tm.DelayedActions = append(tm.DelayedActions, action)
        return nil</span>
}

func (tm *TurnManager) moveToTopOfInitiative(entityID string) <span class="cov0" title="0">{
        // Find group members
        group := append([]string{entityID}, tm.CombatGroups[entityID]...)

        // Create new initiative order
        newOrder := make([]string, 0, len(tm.Initiative))
        newOrder = append(newOrder, group...)

        for _, id := range tm.Initiative </span><span class="cov0" title="0">{
                inGroup := false
                for _, gid := range group </span><span class="cov0" title="0">{
                        if id == gid </span><span class="cov0" title="0">{
                                inGroup = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !inGroup </span><span class="cov0" title="0">{
                        newOrder = append(newOrder, id)
                }</span>
        }

        <span class="cov0" title="0">tm.Initiative = newOrder
        tm.CurrentIndex = 0</span>
}

func (tm *TurnManager) processDelayedActions() <span class="cov0" title="0">{
        currentTime := game.GameTime{
                RealTime:  time.Now(),
                GameTicks: tm.getCurrentGameTicks(),
        }

        remainingActions := make([]DelayedAction, 0)
        for _, action := range tm.DelayedActions </span><span class="cov0" title="0">{
                if currentTime.IsSameTurn(action.TriggerTime) </span><span class="cov0" title="0">{
                        logrus.WithField("action", action).Debug("processing delayed action")
                }</span> else<span class="cov0" title="0"> {
                        remainingActions = append(remainingActions, action)
                }</span>
        }
        <span class="cov0" title="0">tm.DelayedActions = remainingActions</span>
}

func (tm *TurnManager) getCurrentGameTicks() int64 <span class="cov0" title="0">{
        return int64(tm.CurrentRound*6+tm.CurrentIndex) * 10
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package server

import (
        "encoding/json"
        "errors"
        "fmt"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// ErrInvalidSession is returned when a session ID is invalid or not found
var ErrInvalidSession = errors.New("invalid session")

// handleMove processes a player movement request in the game world.
//
// Parameters:
//   - params: json.RawMessage containing:
//   - session_id: string identifier for the player session
//   - direction: game.Direction enum indicating movement direction
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if move was successful
//   - position: Updated position coordinates
//   - error: Possible errors:
//   - "invalid movement parameters" if JSON unmarshaling fails
//   - "invalid session" if session ID not found
//   - Validation errors from WorldState.ValidateMove
//   - Position setting errors from Player.SetPosition
//
// Related:
//   - game.Direction
//   - game.GameEvent
//   - game.EventMovement
//   - RPCServer.sessions
//   - WorldState.ValidateMove
//   - Player.SetPosition
//   - Player.GetPosition
func (s *RPCServer) handleMove(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleMove",
        }).Debug("entering handleMove")

        var req struct {
                SessionID string         `json:"session_id"`
                Direction game.Direction `json:"direction"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleMove",
                        "error":    err.Error(),
                }).Error("failed to unmarshal movement parameters")
                return nil, fmt.Errorf("invalid movement parameters")
        }</span>

        <span class="cov0" title="0">session, exists := s.sessions[req.SessionID]
        if !exists </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":  "handleMove",
                        "sessionID": req.SessionID,
                }).Warn("invalid session ID")
                return nil, fmt.Errorf("invalid session")
        }</span>

        <span class="cov0" title="0">player := session.Player
        currentPos := player.GetPosition()
        newPos := calculateNewPosition(currentPos, req.Direction)

        logrus.WithFields(logrus.Fields{
                "function": "handleMove",
                "playerID": player.GetID(),
                "from":     currentPos,
                "to":       newPos,
        }).Info("validating player move")

        if err := s.state.WorldState.ValidateMove(player, newPos); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleMove",
                        "error":    err.Error(),
                }).Error("move validation failed")
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := player.SetPosition(newPos); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleMove",
                        "error":    err.Error(),
                }).Error("failed to set player position")
                return nil, err
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "handleMove",
                "playerID": player.GetID(),
        }).Info("emitting movement event")

        s.eventSys.Emit(game.GameEvent{
                Type:     game.EventMovement,
                SourceID: player.GetID(),
                Data: map[string]interface{}{
                        "old_position": currentPos,
                        "new_position": newPos,
                },
        })

        logrus.WithFields(logrus.Fields{
                "function": "handleMove",
        }).Debug("exiting handleMove")

        return map[string]interface{}{
                "success":  true,
                "position": newPos,
        }, nil</span>
}

// handleAttack processes an attack action during combat in the RPG game.
//
// Parameters:
//   - params: json.RawMessage containing the attack request with:
//   - session_id: string identifier for the player session
//   - target_id: string identifier for the attack target
//   - weapon_id: string identifier for the weapon being used
//
// Returns:
//   - interface{}: The result of the combat action if successful
//   - error: Error if the attack is invalid due to:
//   - Invalid JSON parameters
//   - Invalid session
//   - Not being in combat
//   - Not being the player's turn
//   - Combat action processing errors
//
// Related:
//   - TurnManager.IsInCombat
//   - TurnManager.IsCurrentTurn
//   - processCombatAction
func (s *RPCServer) handleAttack(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleAttack",
        }).Debug("entering handleAttack")

        var req struct {
                SessionID string `json:"session_id"`
                TargetID  string `json:"target_id"`
                WeaponID  string `json:"weapon_id"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleAttack",
                        "error":    err.Error(),
                }).Error("failed to unmarshal attack parameters")
                return nil, fmt.Errorf("invalid attack parameters")
        }</span>

        <span class="cov0" title="0">session, exists := s.sessions[req.SessionID]
        if !exists </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":  "handleAttack",
                        "sessionID": req.SessionID,
                }).Warn("invalid session ID")
                return nil, fmt.Errorf("invalid session")
        }</span>

        <span class="cov0" title="0">if !s.state.TurnManager.IsInCombat </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleAttack",
                }).Warn("attempted attack while not in combat")
                return nil, fmt.Errorf("not in combat")
        }</span>

        <span class="cov0" title="0">if !s.state.TurnManager.IsCurrentTurn(session.Player.GetID()) </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleAttack",
                        "playerID": session.Player.GetID(),
                }).Warn("player attempted attack when not their turn")
                return nil, fmt.Errorf("not your turn")
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "handleAttack",
                "playerID": session.Player.GetID(),
                "targetID": req.TargetID,
                "weaponID": req.WeaponID,
        }).Info("processing combat action")

        result, err := s.processCombatAction(session.Player, req.TargetID, req.WeaponID)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleAttack",
                        "error":    err.Error(),
                }).Error("combat action failed")
                return nil, err
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "handleAttack",
        }).Debug("exiting handleAttack")

        return result, nil</span>
}

// handleCastSpell processes a spell casting request from a client.
// It validates the spell parameters, checks if the spell exists in player's known spells,
// and executes the spell casting logic.
//
// Parameters:
//   - params: Raw JSON message containing:
//   - session_id: Unique identifier for the player session
//   - spell_id: Identifier of the spell to cast
//   - target_id: ID of the target entity (if applicable)
//   - position: Target position for area spells (optional)
//
// Returns:
//   - interface{}: Result of the spell cast operation
//   - error: Error if:
//   - Invalid JSON parameters
//   - Invalid session ID
//   - Spell not found in player's known spells
//   - Spell casting fails (via processSpellCast)
//
// Related:
//   - processSpellCast: Handles the actual spell casting logic
//   - findSpell: Searches for a spell in player's known spells
func (s *RPCServer) handleCastSpell(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleCastSpell",
        }).Debug("entering handleCastSpell")

        var req struct {
                SessionID string        `json:"session_id"`
                SpellID   string        `json:"spell_id"`
                TargetID  string        `json:"target_id"`
                Position  game.Position `json:"position,omitempty"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleCastSpell",
                        "error":    err.Error(),
                }).Error("failed to unmarshal spell parameters")
                return nil, fmt.Errorf("invalid spell parameters")
        }</span>

        <span class="cov0" title="0">session, exists := s.sessions[req.SessionID]
        if !exists </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":  "handleCastSpell",
                        "sessionID": req.SessionID,
                }).Warn("invalid session ID")
                return nil, fmt.Errorf("invalid session")
        }</span>

        <span class="cov0" title="0">player := session.Player
        spell := findSpell(player.KnownSpells, req.SpellID)
        if spell == nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleCastSpell",
                        "spellID":  req.SpellID,
                        "playerID": player.GetID(),
                }).Warn("spell not found in player's known spells")
                return nil, fmt.Errorf("spell not found")
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "handleCastSpell",
                "spellID":  req.SpellID,
                "targetID": req.TargetID,
                "playerID": player.GetID(),
        }).Info("attempting to cast spell")

        result, err := s.processSpellCast(player, spell, req.TargetID, req.Position)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleCastSpell",
                        "error":    err.Error(),
                        "spellID":  req.SpellID,
                }).Error("spell cast failed")
                return nil, err
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "handleCastSpell",
        }).Debug("exiting handleCastSpell")

        return result, nil</span>
}

// handleStartCombat initiates a new combat session with the specified participants.
//
// Parameters:
//   - params: Raw JSON message containing:
//   - session_id: Unique identifier for the game session
//   - participant_ids: Array of string IDs for the combat participants
//
// Returns:
//   - interface{}: Map containing:
//   - success: Boolean indicating successful combat start
//   - initiative: Ordered array of participant IDs based on initiative rolls
//   - first_turn: ID of the participant who goes first
//   - error: Error if:
//   - Invalid JSON parameters provided
//   - Combat is already in progress for this session
//
// Related:
//   - TurnManager.StartCombat(): Handles the actual combat state management
//   - rollInitiative(): Determines turn order for participants
func (s *RPCServer) handleStartCombat(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleStartCombat",
        }).Debug("entering handleStartCombat")

        var req struct {
                SessionID    string   `json:"session_id"`
                Participants []string `json:"participant_ids"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleStartCombat",
                        "error":    err.Error(),
                }).Error("failed to unmarshal combat parameters")
                return nil, fmt.Errorf("invalid combat parameters")
        }</span>

        <span class="cov0" title="0">if s.state.TurnManager.IsInCombat </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleStartCombat",
                }).Warn("attempted to start combat while already in combat")
                return nil, fmt.Errorf("combat already in progress")
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function":     "handleStartCombat",
                "participants": len(req.Participants),
        }).Info("rolling initiative for combat participants")

        initiative := s.rollInitiative(req.Participants)
        s.state.TurnManager.StartCombat(initiative)

        logrus.WithFields(logrus.Fields{
                "function":  "handleStartCombat",
                "firstTurn": initiative[0],
        }).Info("combat started successfully")

        logrus.WithFields(logrus.Fields{
                "function": "handleStartCombat",
        }).Debug("exiting handleStartCombat")

        return map[string]interface{}{
                "success":    true,
                "initiative": initiative,
                "first_turn": initiative[0],
        }, nil</span>
}

// handleEndTurn processes a request to end the current player's turn in combat.
//
// Params:
//   - params: json.RawMessage containing a session_id field
//
// Returns:
//   - interface{}: A map containing "success" (bool) and "next_turn" with the next player's ID
//   - error: If session is invalid, not in combat, not player's turn, or invalid parameters
//
// Errors:
//   - "invalid turn parameters": If params cannot be unmarshaled
//   - "invalid session": If session ID does not exist
//   - "not in combat": If TurnManager.IsInCombat is false
//   - "not your turn": If current turn does not belong to requesting player
//
// Related:
//   - TurnManager.AdvanceTurn()
//   - processEndTurnEffects()
//   - processEndRound()
func (s *RPCServer) handleEndTurn(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleEndTurn",
        }).Debug("entering handleEndTurn")

        var req struct {
                SessionID string `json:"session_id"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleEndTurn",
                        "error":    err.Error(),
                }).Error("failed to unmarshal request parameters")
                return nil, fmt.Errorf("invalid turn parameters")
        }</span>

        <span class="cov0" title="0">session, exists := s.sessions[req.SessionID]
        if !exists </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":  "handleEndTurn",
                        "sessionID": req.SessionID,
                }).Warn("invalid session ID")
                return nil, fmt.Errorf("invalid session")
        }</span>

        <span class="cov0" title="0">if !s.state.TurnManager.IsInCombat </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleEndTurn",
                }).Warn("attempted to end turn while not in combat")
                return nil, fmt.Errorf("not in combat")
        }</span>

        <span class="cov0" title="0">if !s.state.TurnManager.IsCurrentTurn(session.Player.GetID()) </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleEndTurn",
                        "playerID": session.Player.GetID(),
                }).Warn("player attempted to end turn when not their turn")
                return nil, fmt.Errorf("not your turn")
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "handleEndTurn",
                "playerID": session.Player.GetID(),
        }).Info("processing end of turn effects")
        s.processEndTurnEffects(session.Player)

        nextTurn := s.state.TurnManager.AdvanceTurn()
        logrus.WithFields(logrus.Fields{
                "function": "handleEndTurn",
                "nextTurn": nextTurn,
        }).Info("advanced to next turn")

        if s.state.TurnManager.CurrentIndex == 0 </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleEndTurn",
                }).Info("processing end of round")
                s.processEndRound()
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "handleEndTurn",
        }).Debug("exiting handleEndTurn")

        return map[string]interface{}{
                "success":   true,
                "next_turn": nextTurn,
        }, nil</span>
}

// handleGetGameState processes a request to retrieve the current game state for a given session.
// The method returns a comprehensive snapshot of the player's state and visible world elements.
//
// Parameters:
//   - params: json.RawMessage containing the session_id parameter
//
// Returns:
//   - interface{}: A map containing two main sections:
//   - player: Contains position, stats, active effects, inventory, spells and experience
//   - world: Contains visible objects, current game time and combat state if any
//   - error: Returns error if:
//   - Session ID is invalid or not found
//   - Request parameters cannot be unmarshaled
//
// Related:
//   - Player.GetPosition()
//   - Player.GetStats()
//   - TimeManager.CurrentTime
//   - getVisibleObjects()
//   - getActiveEffects()
//   - getCombatStateIfActive()
/*func (s *RPCServer) handleGetGameState(params json.RawMessage) (interface{}, error) {
        logger := logrus.WithFields(logrus.Fields{
                "function": "handleGetGameState",
        })
        logger.Debug("entering handleGetGameState")

        // 1. Validate params
        var req struct {
                SessionID string `json:"session_id"`
        }
        if err := json.Unmarshal(params, &amp;req); err != nil {
                logger.WithError(err).Error("failed to unmarshal parameters")
                return nil, fmt.Errorf("invalid parameters")
        }

        // 2. Validate session
        if req.SessionID == "" {
                logger.Warn("invalid session ID")
                return nil, ErrInvalidSession
        }

        // 3. Validate server state
        if s.state == nil {
                logger.Error("game state not initialized")
                return nil, fmt.Errorf("server state not initialized")
        }

        // 4. Get and validate session
        s.mu.RLock()
        session, exists := s.sessions[req.SessionID]
        s.mu.RUnlock()

        if !exists {
                logger.WithField("sessionID", req.SessionID).Warn("session not found")
                return nil, ErrInvalidSession
        }

        // 5. Get game state
        session.LastActive = time.Now()
        state := s.state.GetState()

        // 6. Validate response
        if state == nil {
                logger.Error("failed to get game state")
                return nil, fmt.Errorf("internal server error")
        }

        logger.Debug("exiting handleGetGameState")
        return state, nil
}*/

func (s *RPCServer) handleGetGameState(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "handleGetGameState",
        })
        logger.Debug("entering handleGetGameState")

        // 1. Validate params
        var req struct {
                SessionID string `json:"session_id"`
        }
        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to unmarshal parameters")
                return nil, fmt.Errorf("invalid parameters")
        }</span>

        // 2. Check session with read lock
        <span class="cov0" title="0">s.mu.RLock()
        session, exists := s.sessions[req.SessionID]
        s.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                logger.WithField("sessionID", req.SessionID).Warn("session not found")
                return nil, ErrInvalidSession
        }</span>

        // 3. Update last active time with write lock
        <span class="cov0" title="0">s.mu.Lock()
        session.LastActive = time.Now()
        s.mu.Unlock()

        // 4. Get game state (uses its own internal locking)
        state := s.state.GetState()
        if state == nil </span><span class="cov0" title="0">{
                logger.Error("failed to get game state")
                return nil, fmt.Errorf("internal server error")
        }</span>

        <span class="cov0" title="0">logger.Debug("exiting handleGetGameState")
        return state, nil</span>
}

// handleApplyEffect processes a request to apply an effect to a target entity in the game world.
//
// Parameters:
// - params: json.RawMessage containing the request parameters:
//   - session_id: string identifier for the player session
//   - effect_type: game.EffectType enum specifying the type of effect
//   - target_id: string identifier for the target entity
//   - magnitude: float64 indicating the strength/amount of the effect
//   - duration: game.Duration specifying how long the effect lasts
//
// Returns:
// - interface{}: A map containing:
//   - success: bool indicating if effect was applied
//   - effect_id: string identifier for the created effect
//
// - error: Error if request fails due to:
//   - Invalid JSON parameters
//   - Invalid session ID
//   - Invalid target ID
//   - Target not implementing EffectHolder interface
//   - Effect application failure
//
// Related types:
// - game.Effect
// - game.EffectHolder
// - game.EffectType
// - game.Duration
func (s *RPCServer) handleApplyEffect(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleApplyEffect",
        }).Debug("entering handleApplyEffect")

        var req struct {
                SessionID  string          `json:"session_id"`
                EffectType game.EffectType `json:"effect_type"`
                TargetID   string          `json:"target_id"`
                Magnitude  float64         `json:"magnitude"`
                Duration   game.Duration   `json:"duration"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleApplyEffect",
                        "error":    err.Error(),
                }).Error("failed to unmarshal effect parameters")
                return nil, fmt.Errorf("invalid effect parameters")
        }</span>

        <span class="cov0" title="0">session, exists := s.sessions[req.SessionID]
        if !exists </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":  "handleApplyEffect",
                        "sessionID": req.SessionID,
                }).Warn("invalid session ID")
                return nil, fmt.Errorf("invalid session")
        }</span>

        // Create and apply the effect
        <span class="cov0" title="0">effect := game.NewEffect(req.EffectType, req.Duration, req.Magnitude)
        effect.SourceID = session.Player.GetID()

        logrus.WithFields(logrus.Fields{
                "function":   "handleApplyEffect",
                "effectType": req.EffectType,
                "targetID":   req.TargetID,
        }).Info("creating new effect")

        target, exists := s.state.WorldState.Objects[req.TargetID]
        if !exists </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleApplyEffect",
                        "targetID": req.TargetID,
                }).Warn("invalid target ID")
                return nil, fmt.Errorf("invalid target")
        }</span>

        <span class="cov0" title="0">effectHolder, ok := target.(game.EffectHolder)
        if !ok </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleApplyEffect",
                        "targetID": req.TargetID,
                }).Warn("target cannot receive effects")
                return nil, fmt.Errorf("target cannot receive effects")
        }</span>

        <span class="cov0" title="0">if err := effectHolder.AddEffect(effect); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleApplyEffect",
                        "error":    err.Error(),
                }).Error("failed to add effect")
                return nil, err
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "handleApplyEffect",
                "effectID": effect.ID,
        }).Info("effect successfully applied")

        logrus.WithFields(logrus.Fields{
                "function": "handleApplyEffect",
        }).Debug("exiting handleApplyEffect")

        return map[string]interface{}{
                "success":   true,
                "effect_id": effect.ID,
        }, nil</span>
}

func (s *RPCServer) handleJoinGame(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleJoinGame",
        }).Debug("entering handleJoinGame")

        var req struct {
                SessionID string `json:"session_id"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleJoinGame",
                        "error":    err.Error(),
                }).Error("failed to unmarshal join parameters")
                return nil, fmt.Errorf("invalid join parameters")
        }</span>

        <span class="cov0" title="0">if req.SessionID == "" </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleJoinGame",
                }).Warn("empty session ID")
                return nil, ErrInvalidSession
        }</span>

        <span class="cov0" title="0">s.mu.RLock()
        session, exists := s.sessions[req.SessionID]
        s.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":  "handleJoinGame",
                        "sessionID": req.SessionID,
                }).Warn("session not found")
                return nil, ErrInvalidSession
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function":  "handleJoinGame",
                "sessionID": req.SessionID,
        }).Info("adding player to game state")

        // Initialize player in session
        s.state.AddPlayer(session)

        logrus.WithFields(logrus.Fields{
                "function": "handleJoinGame",
        }).Debug("exiting handleJoinGame")

        return map[string]interface{}{
                "player_id": session.SessionID,
                "state":     s.state.GetState(),
        }, nil</span>
}

// handleCreateCharacter processes a character creation request and creates a new character.
//
// Parameters:
//   - params: json.RawMessage containing:
//   - name: string - Character name
//   - class: string - Character class ("fighter", "mage", "cleric", "thief", "ranger", "paladin")
//   - attribute_method: string - Attribute generation method ("roll", "pointbuy", "standard", "custom")
//   - custom_attributes: map[string]int - Custom attribute values (optional)
//   - starting_equipment: bool - Whether to include starting equipment
//   - starting_gold: int - Starting gold amount (optional)
//
// Returns:
//   - interface{}: Map containing:
//   - success: bool indicating if creation was successful
//   - character: Created character data
//   - player: Created player data
//   - session_id: Session ID for the new character
//   - errors: List of any error messages
//   - warnings: List of any warning messages
//
// Errors:
//   - "invalid character creation parameters" if JSON unmarshaling fails
//   - Character creation validation errors from CharacterCreator
//   - Session creation errors
func (s *RPCServer) handleCreateCharacter(params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "handleCreateCharacter",
        }).Debug("entering handleCreateCharacter")

        var req struct {
                Name             string         `json:"name"`
                Class            string         `json:"class"`
                AttributeMethod  string         `json:"attribute_method"`
                CustomAttributes map[string]int `json:"custom_attributes,omitempty"`
                StartingEquipment bool          `json:"starting_equipment"`
                StartingGold     int            `json:"starting_gold"`
        }

        if err := json.Unmarshal(params, &amp;req); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleCreateCharacter",
                        "error":    err.Error(),
                }).Error("failed to unmarshal character creation parameters")
                return nil, fmt.Errorf("invalid character creation parameters")
        }</span>

        // Convert string class to CharacterClass enum
        <span class="cov0" title="0">classMap := map[string]game.CharacterClass{
                "fighter": game.ClassFighter,
                "mage":    game.ClassMage,
                "cleric":  game.ClassCleric,
                "thief":   game.ClassThief,
                "ranger":  game.ClassRanger,
                "paladin": game.ClassPaladin,
        }

        characterClass, exists := classMap[req.Class]
        if !exists </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleCreateCharacter",
                        "class":    req.Class,
                }).Error("invalid character class")
                return nil, fmt.Errorf("invalid character class: %s", req.Class)
        }</span>

        // Set default starting gold if not specified
        <span class="cov0" title="0">if req.StartingGold == 0 </span><span class="cov0" title="0">{
                defaultGold := map[game.CharacterClass]int{
                        game.ClassFighter: 100,
                        game.ClassMage:    50,
                        game.ClassCleric:  75,
                        game.ClassThief:   80,
                        game.ClassRanger:  90,
                        game.ClassPaladin: 120,
                }
                req.StartingGold = defaultGold[characterClass]
        }</span>

        // Create character creation config
        <span class="cov0" title="0">config := game.CharacterCreationConfig{
                Name:              req.Name,
                Class:             characterClass,
                AttributeMethod:   req.AttributeMethod,
                CustomAttributes:  req.CustomAttributes,
                StartingEquipment: req.StartingEquipment,
                StartingGold:      req.StartingGold,
        }

        // Create character creator and generate character
        creator := game.NewCharacterCreator()
        result := creator.CreateCharacter(config)

        if !result.Success </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "handleCreateCharacter",
                        "errors":   result.Errors,
                }).Error("character creation failed")
                return map[string]interface{}{
                        "success":  false,
                        "errors":   result.Errors,
                        "warnings": result.Warnings,
                }, nil
        }</span>

        // Create a new session for this character
        <span class="cov0" title="0">sessionID := game.NewUID()
        session := &amp;PlayerSession{
                SessionID:   sessionID,
                Player:      result.PlayerData,
                LastActive:  time.Now(),
                CreatedAt:   time.Now(),
                Connected:   false,
                MessageChan: make(chan []byte, 100),
        }

        // Store session
        s.mu.Lock()
        s.sessions[sessionID] = session
        s.mu.Unlock()

        logrus.WithFields(logrus.Fields{
                "function":    "handleCreateCharacter",
                "sessionID":   sessionID,
                "characterName": req.Name,
                "class":       req.Class,
        }).Info("character created successfully")

        return map[string]interface{}{
                "success":    true,
                "character":  result.Character,
                "player":     result.PlayerData,
                "session_id": sessionID,
                "errors":     result.Errors,
                "warnings":   result.Warnings,
                "creation_time": result.CreationTime,
                "generated_stats": result.GeneratedStats,
                "starting_items": result.StartingItems,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package server

import (
        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// calculateNewPosition calculates a new position based on the current position and movement direction
//
// Parameters:
//   - current: The current Position containing X and Y coordinates
//   - direction: The Direction to move (North, South, East, or West)
//
// Returns:
//   - A new Position with updated coordinates based on the direction of movement
//
// Notes:
//   - Movement increments/decrements X or Y by 1 unit in the specified direction
//   - Does not check for boundary conditions or invalid positions
//   - Related to game.Position and game.Direction types
func calculateNewPosition(current game.Position, direction game.Direction) game.Position <span class="cov8" title="1">{
        logrus.WithFields(logrus.Fields{
                "function":  "calculateNewPosition",
                "current":   current,
                "direction": direction,
        }).Debug("entering calculateNewPosition")

        newPos := current

        logrus.WithFields(logrus.Fields{
                "function": "calculateNewPosition",
        }).Info("calculating new position")

        switch direction </span>{
        case game.North:<span class="cov8" title="1">
                newPos.Y++</span>
        case game.South:<span class="cov8" title="1">
                newPos.Y--</span>
        case game.East:<span class="cov8" title="1">
                newPos.X++</span>
        case game.West:<span class="cov8" title="1">
                newPos.X--</span>
        }

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "function": "calculateNewPosition",
                "newPos":   newPos,
        }).Debug("exiting calculateNewPosition")

        return newPos</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package server

import (
        "fmt"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// processEffectTick handles the processing of a single effect tick in the game state.
// It determines the effect type and routes the processing to the appropriate handler.
//
// Parameters:
//   - effect: *game.Effect - The effect to process. Must not be nil.
//
// Returns:
//   - error: Returns nil on success, or an error if:
//   - The effect parameter is nil
//   - The effect type is unknown/unsupported
//
// Related:
//   - processDamageEffect
//   - processHealEffect
//   - processStatEffect
//
// Handles effect types:
//   - EffectDamageOverTime
//   - EffectHealOverTime
//   - EffectStatBoost
//   - EffectStatPenalty
func (gs *GameState) processEffectTick(effect *game.Effect) error <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "processEffectTick",
        })
        logger.Debug("processing effect tick")

        if effect == nil </span><span class="cov0" title="0">{
                logger.Error("nil effect provided")
                return fmt.Errorf("nil effect")
        }</span>

        <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                "effectType": effect.Type,
                "targetID":   effect.TargetID,
        }).Info("processing effect")

        var err error
        switch effect.Type </span>{
        case game.EffectDamageOverTime:<span class="cov0" title="0">
                err = gs.processDamageEffect(effect)</span>
        case game.EffectHealOverTime:<span class="cov0" title="0">
                err = gs.processHealEffect(effect)</span>
        case game.EffectStatBoost, game.EffectStatPenalty:<span class="cov0" title="0">
                err = gs.processStatEffect(effect)</span>
        default:<span class="cov0" title="0">
                logger.WithField("effectType", effect.Type).Warn("unknown effect type")
                return fmt.Errorf("unknown effect type: %s", effect.Type)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to process effect")
        }</span>
        <span class="cov0" title="0">return err</span>
}

// processDamageEffect applies damage to a target character based on the provided effect.
// It locates the target in the world state and reduces their HP by the effect magnitude.
//
// Parameters:
//   - effect: *game.Effect - Contains target ID and damage magnitude to apply
//
// Returns:
//   - error - Returns nil if damage was successfully applied, or an error if:
//   - Target ID does not exist in world state
//   - Target is not a Character type that can receive damage
//
// Related:
//   - game.Character
//   - game.Effect
//   - GameState.WorldState
func (gs *GameState) processDamageEffect(effect *game.Effect) error <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "processDamageEffect",
        })
        logger.Debug("processing damage effect")

        target, exists := gs.WorldState.Objects[effect.TargetID]
        if !exists </span><span class="cov0" title="0">{
                logger.WithField("targetID", effect.TargetID).Error("invalid effect target")
                return fmt.Errorf("invalid effect target")
        }</span>

        <span class="cov0" title="0">if char, ok := target.(*game.Character); ok </span><span class="cov0" title="0">{
                damage := int(effect.Magnitude)
                char.HP -= damage
                if char.HP &lt; 0 </span><span class="cov0" title="0">{
                        char.HP = 0
                        logger.WithFields(logrus.Fields{
                                "targetID": effect.TargetID,
                                "damage":   damage,
                        }).Warn("character HP reduced to 0")
                }</span> else<span class="cov0" title="0"> {
                        logger.WithFields(logrus.Fields{
                                "targetID":    effect.TargetID,
                                "damage":      damage,
                                "remainingHP": char.HP,
                        }).Info("applied damage to character")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">logger.WithField("targetID", effect.TargetID).Error("target cannot receive damage")
        return fmt.Errorf("target cannot receive damage")</span>
}

// processHealEffect applies a healing effect to a target character in the game world.
// It increases the target's HP by the effect magnitude, up to their max HP.
//
// Parameters:
//   - effect: *game.Effect - The healing effect to process, must contain:
//   - TargetID: ID of the character to heal
//   - Magnitude: Amount of HP to heal
//
// Returns:
//   - error: Returns nil on success, or an error if:
//   - Target does not exist in world state
//   - Target is not a Character type
//
// Related:
//   - game.Character
//   - game.Effect
//   - GameState.WorldState
func (gs *GameState) processHealEffect(effect *game.Effect) error <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "processHealEffect",
        })
        logger.Debug("processing heal effect")

        target, exists := gs.WorldState.Objects[effect.TargetID]
        if !exists </span><span class="cov0" title="0">{
                logger.WithField("targetID", effect.TargetID).Error("invalid effect target")
                return fmt.Errorf("invalid effect target")
        }</span>

        <span class="cov0" title="0">if char, ok := target.(*game.Character); ok </span><span class="cov0" title="0">{
                healAmount := int(effect.Magnitude)
                oldHP := char.HP
                char.HP = min(char.HP+healAmount, char.MaxHP)
                logger.WithFields(logrus.Fields{
                        "targetID":   effect.TargetID,
                        "healAmount": healAmount,
                        "oldHP":      oldHP,
                        "newHP":      char.HP,
                }).Info("healed character")
                return nil
        }</span>

        <span class="cov0" title="0">logger.WithField("targetID", effect.TargetID).Error("target cannot be healed")
        return fmt.Errorf("target cannot be healed")</span>
}

// ProcessStatEffect applies a stat modification effect to a character target.
//
// Parameters:
//   - effect: *game.Effect - Contains the target ID, stat to modify, and magnitude
//     of the modification. Must have valid StatAffected and Magnitude fields.
//
// Returns:
//
//        error - Returns nil if successful, or an error if:
//        - Target ID doesn't exist in WorldState
//        - Target is not a Character type
//        - StatAffected is not a valid stat name
//
// StatAffected must be one of: strength, dexterity, constitution, intelligence,
// wisdom, charisma
//
// Related types:
//   - game.Effect
//   - game.Character
func (gs *GameState) processStatEffect(effect *game.Effect) error <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "processStatEffect",
        })
        logger.Debug("processing stat effect")

        target, exists := gs.WorldState.Objects[effect.TargetID]
        if !exists </span><span class="cov0" title="0">{
                logger.WithField("targetID", effect.TargetID).Error("invalid effect target")
                return fmt.Errorf("invalid effect target")
        }</span>

        <span class="cov0" title="0">if char, ok := target.(*game.Character); ok </span><span class="cov0" title="0">{
                magnitude := int(effect.Magnitude)
                logger.WithFields(logrus.Fields{
                        "function":  "processStatEffect",
                        "targetID":  effect.TargetID,
                        "stat":      effect.StatAffected,
                        "magnitude": magnitude,
                }).Info("applying stat modification")

                switch effect.StatAffected </span>{
                case "strength":<span class="cov0" title="0">
                        char.Strength += magnitude</span>
                case "dexterity":<span class="cov0" title="0">
                        char.Dexterity += magnitude</span>
                case "constitution":<span class="cov0" title="0">
                        char.Constitution += magnitude</span>
                case "intelligence":<span class="cov0" title="0">
                        char.Intelligence += magnitude</span>
                case "wisdom":<span class="cov0" title="0">
                        char.Wisdom += magnitude</span>
                case "charisma":<span class="cov0" title="0">
                        char.Charisma += magnitude</span>
                default:<span class="cov0" title="0">
                        logger.WithField("stat", effect.StatAffected).Error("unknown stat type")
                        return fmt.Errorf("unknown stat type: %s", effect.StatAffected)</span>
                }
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">logger.WithField("targetID", effect.TargetID).Error("target cannot receive stat effects")
        return fmt.Errorf("target cannot receive stat effects")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package server

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "sync"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

const (
        sessionCleanupInterval = 5 * time.Minute
        sessionTimeout         = 30 * time.Minute
)

// RPCServer represents the main RPC server instance that handles game state and player sessions.
// It provides functionality for managing game state, player sessions, and event handling.
//
// Fields:
//   - state: Pointer to GameState that maintains the current game state
//   - eventSys: Pointer to game.EventSystem for handling game events
//   - mu: RWMutex for thread-safe access to server resources
//   - timekeeper: Pointer to TimeManager for managing game time and scheduling
//   - sessions: Map of player session IDs to PlayerSession objects
//
// Related types:
//   - GameState
//   - game.EventSystem
//   - TimeManager
//   - PlayerSession
/*type RPCServer struct {
        webDir     string
        fileServer http.Handler
        state      *GameState
        eventSys   *game.EventSystem
        mu         sync.RWMutex
        timekeeper *TimeManager
        sessions   map[string]*PlayerSession
}*/

type RPCServer struct {
        webDir     string
        fileServer http.Handler
        state      *GameState
        eventSys   *game.EventSystem
        mu         sync.RWMutex
        timekeeper *TimeManager
        sessions   map[string]*PlayerSession
        done       chan struct{}
}

// NewRPCServer creates and initializes a new RPCServer instance with default configuration.
// It sets up the core game systems including:
//   - World state management
//   - Turn-based gameplay handling
//   - Time tracking and management
//   - Player session tracking
//
// Returns:
//   - *RPCServer: A fully initialized server instance ready to handle RPC requests
//
// Related types:
//   - GameState: Contains the core game state
//   - TurnManager: Manages turn order and progression
//   - TimeManager: Handles in-game time tracking
//   - PlayerSession: Tracks individual player connections
//   - EventSystem: Handles game event dispatching
func NewRPCServer(webDir string) *RPCServer <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "NewRPCServer",
                "webDir":   webDir,
        })
        logger.Debug("entering NewRPCServer")

        // Create server with default world
        server := &amp;RPCServer{
                webDir:     webDir,
                fileServer: http.FileServer(http.Dir(webDir)),
                state: &amp;GameState{
                        WorldState:  game.CreateDefaultWorld(), // Use default world
                        TurnManager: NewTurnManager(),
                        TimeManager: NewTimeManager(),
                        Sessions:    make(map[string]*PlayerSession),
                        Version:     1,
                },
                eventSys:   game.NewEventSystem(),
                sessions:   make(map[string]*PlayerSession),
                timekeeper: NewTimeManager(),
                done:       make(chan struct{}),
        }

        server.startSessionCleanup()

        logger.WithField("server", server).Info("initialized new RPC server")
        logger.Debug("exiting NewRPCServer")
        return server
}</span>

// ServeHTTP handles incoming JSON-RPC requests over HTTP, implementing the http.Handler interface.
// It processes POST requests only and expects a JSON-RPC 2.0 formatted request body.
//
// Parameters:
//   - w http.ResponseWriter: The response writer for sending the HTTP response
//   - r *http.Request: The incoming HTTP request containing the JSON-RPC payload
//
// The request body should contain a JSON object with:
//   - jsonrpc: String specifying the JSON-RPC version (must be "2.0")
//   - method: The RPC method name to invoke
//   - params: The parameters for the method (as raw JSON)
//   - id: Request identifier that will be echoed back in the response
//
// Error handling:
//   - Returns 405 Method Not Allowed if request is not POST
//   - Returns JSON-RPC error code -32700 for invalid JSON
//   - Returns JSON-RPC error code -32603 for internal errors during method execution
//
// Related:
//   - handleMethod: Processes the individual RPC method calls
//   - writeResponse: Formats and sends successful responses
//   - writeError: Formats and sends error responses
func (s *RPCServer) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "ServeHTTP",
                "method":   r.Method,
                "url":      r.URL.String(),
        })
        logger.Debug("entering ServeHTTP")

        session, err := s.getOrCreateSession(w, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("session creation failed")
                writeError(w, -32603, "Internal error", nil)
                return
        }</span>

        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), "session", session)
        r = r.WithContext(ctx)

        if r.Header.Get("Upgrade") == "websocket" </span><span class="cov0" title="0">{
                s.HandleWebSocket(w, r)
                return
        }</span>

        <span class="cov0" title="0">if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                logger.Info("serving static file")
                s.fileServer.ServeHTTP(w, r)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                JsonRPC string          `json:"jsonrpc"`
                Method  RPCMethod       `json:"method"`
                Params  json.RawMessage `json:"params"`
                ID      interface{}     `json:"id"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to decode request body")
                writeError(w, -32700, "Parse error", nil)
                return
        }</span>

        <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                "rpcMethod": req.Method,
                "requestId": req.ID,
        }).Info("handling RPC method")

        // Handle the RPC method
        result, err := s.handleMethod(req.Method, req.Params)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("method handler failed")
                writeError(w, -32603, err.Error(), nil)
                return
        }</span>

        // Write successful response
        <span class="cov0" title="0">writeResponse(w, result, req.ID)
        logger.Debug("exiting ServeHTTP")</span>
}

// handleMethod processes an RPC method call with the given parameters and returns the appropriate response.
// It uses a mutex to ensure thread-safe access to shared resources.
//
// Parameters:
//   - method: RPCMethod - The RPC method to be executed (e.g. MethodMove, MethodAttack, etc)
//   - params: json.RawMessage - The raw JSON parameters for the method call
//
// Returns:
//   - interface{} - The result of the method execution
//   - error - Any error that occurred during execution
//
// Error cases:
//   - Returns error if the method is not recognized
//
// Related methods:
//   - handleMove
//   - handleAttack
//   - handleCastSpell
//   - handleApplyEffect
//   - handleStartCombat
//   - handleEndTurn
//   - handleGetGameState
func (s *RPCServer) handleMethod(method RPCMethod, params json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "handleMethod",
                "method":   method,
        })
        logger.Debug("entering handleMethod")

        var result interface{}
        var err error

        switch method </span>{
        case MethodJoinGame:<span class="cov0" title="0">
                logger.Info("handling join game method")
                result, err = s.handleJoinGame(params)</span>
        case MethodCreateCharacter:<span class="cov0" title="0">
                logger.Info("handling create character method")
                result, err = s.handleCreateCharacter(params)</span>
        case MethodMove:<span class="cov0" title="0">
                logger.Info("handling move method")
                result, err = s.handleMove(params)</span>
        case MethodAttack:<span class="cov0" title="0">
                logger.Info("handling attack method")
                result, err = s.handleAttack(params)</span>
        case MethodCastSpell:<span class="cov0" title="0">
                logger.Info("handling cast spell method")
                result, err = s.handleCastSpell(params)</span>
        case MethodApplyEffect:<span class="cov0" title="0">
                logger.Info("handling apply effect method")
                result, err = s.handleApplyEffect(params)</span>
        case MethodStartCombat:<span class="cov0" title="0">
                logger.Info("handling start combat method")
                result, err = s.handleStartCombat(params)</span>
        case MethodEndTurn:<span class="cov0" title="0">
                logger.Info("handling end turn method")
                result, err = s.handleEndTurn(params)</span>
        case MethodGetGameState:<span class="cov0" title="0">
                logger.Info("handling get game state method")
                result, err = s.handleGetGameState(params)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unknown method: %s", method)
                logger.WithError(err).Error("unknown method")
                return nil, err</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("method handler failed")
                return nil, err
        }</span>

        <span class="cov0" title="0">logger.WithField("result", result).Debug("exiting handleMethod")
        return result, nil</span>
}

// writeResponse writes a JSON-RPC 2.0 compliant response to the http.ResponseWriter
//
// Parameters:
//   - w http.ResponseWriter: The response writer to write the JSON response to
//   - result interface{}: The result payload to include in the response
//   - id interface{}: The JSON-RPC request ID to correlate the response
//
// The function sets the Content-Type header to application/json and writes a JSON object
// containing the JSON-RPC version (2.0), the result, and the request ID.
//
// No error handling is currently implemented - errors from json.Encode are silently ignored.
// Consider adding error handling in production code.
//
// Related:
// - JSON-RPC 2.0 Specification: https://www.jsonrpc.org/specification
func writeResponse(w http.ResponseWriter, result, id interface{}) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "writeResponse",
        })
        logger.Debug("entering writeResponse")

        response := struct {
                JsonRPC string      `json:"jsonrpc"`
                Result  interface{} `json:"result"`
                ID      interface{} `json:"id"`
        }{
                JsonRPC: "2.0",
                Result:  result,
                ID:      id,
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to encode response")
                return
        }</span>

        <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                "response": response,
        }).Info("wrote response")
        logger.Debug("exiting writeResponse")</span>
}

// writeError writes a JSON-RPC 2.0 error response to the provided http.ResponseWriter
//
// Parameters:
//   - w http.ResponseWriter: The response writer to write the error to
//   - code int: The error code to include in the response
//   - message string: The error message to include in the response
//   - data interface{}: Optional additional error data (will be omitted if nil)
//
// The function writes the error as a JSON object with the following structure:
//
//        {
//          "jsonrpc": "2.0",
//          "error": {
//            "code": &lt;code&gt;,
//            "message": &lt;message&gt;,
//            "data": &lt;data&gt;  // Optional
//          },
//          "id": null
//        }
//
// The Content-Type header is set to application/json
func writeError(w http.ResponseWriter, code int, message string, data interface{}) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "writeError",
                "code":     code,
                "message":  message,
        })
        logger.Debug("entering writeError")

        response := struct {
                JsonRPC string `json:"jsonrpc"`
                Error   struct {
                        Code    int         `json:"code"`
                        Message string      `json:"message"`
                        Data    interface{} `json:"data,omitempty"`
                } `json:"error"`
                ID interface{} `json:"id"`
        }{
                JsonRPC: "2.0",
                Error: struct {
                        Code    int         `json:"code"`
                        Message string      `json:"message"`
                        Data    interface{} `json:"data,omitempty"`
                }{
                        Code:    code,
                        Message: message,
                        Data:    data,
                },
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to encode error response")
                return
        }</span>

        <span class="cov0" title="0">logger.WithFields(logrus.Fields{
                "response": response,
        }).Info("wrote error response")
        logger.Debug("exiting writeError")</span>
}

func (s *RPCServer) Stop() <span class="cov0" title="0">{
        close(s.done)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package server

import (
        "net/http"
        "time"

        "github.com/google/uuid"
        "github.com/sirupsen/logrus"
)

// getOrCreateSession handles session management for HTTP requests by either retrieving an existing
// session or creating a new one. It maintains user sessions through cookies and ensures thread-safe
// access to the sessions map.
//
// Parameters:
//   - w http.ResponseWriter: The response writer to set session cookies
//   - r *http.Request: The incoming HTTP request containing potential session cookies
//
// Returns:
//   - *PlayerSession: A pointer to either the existing or newly created session
//   - error: Error if session handling fails
//
// The function performs the following:
// 1. Checks for existing session cookie
// 2. If found and valid, returns the existing session
// 3. If not found or invalid, creates new session with UUID
// 4. Sets session cookie in response
// 5. Updates LastActive timestamp
//
// Thread-safety is ensured via mutex locking of the sessions map.
// Sessions expire after 1 hour (3600 seconds) as set in cookie MaxAge.
//
// Related types:
//   - PlayerSession struct
//   - RPCServer struct
func (s *RPCServer) getOrCreateSession(w http.ResponseWriter, r *http.Request) (*PlayerSession, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "func": "getOrCreateSession",
                "path": r.URL.Path,
        }).Debug("Starting session handling")

        s.mu.Lock()
        defer s.mu.Unlock()

        cookie, err := r.Cookie("session_id")
        if err == nil </span><span class="cov0" title="0">{
                if session, exists := s.sessions[cookie.Value]; exists </span><span class="cov0" title="0">{
                        session.LastActive = time.Now()
                        logrus.WithFields(logrus.Fields{
                                "func":      "getOrCreateSession",
                                "sessionID": cookie.Value,
                        }).Debug("Existing session found and updated")
                        return session, nil
                }</span>
                <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                        "func":      "getOrCreateSession",
                        "sessionID": cookie.Value,
                }).Warn("Cookie exists but session not found")</span>
        }

        <span class="cov0" title="0">sessionID := uuid.New().String()
        session := &amp;PlayerSession{
                SessionID:   sessionID,
                CreatedAt:   time.Now(),
                LastActive:  time.Now(),
                MessageChan: make(chan []byte, 100),
        }
        s.sessions[sessionID] = session

        http.SetCookie(w, &amp;http.Cookie{
                Name:     "session_id",
                Value:    sessionID,
                Path:     "/",
                HttpOnly: true,
                MaxAge:   3600,
                SameSite: http.SameSiteNoneMode,
                Secure:   true,
        })

        logrus.WithFields(logrus.Fields{
                "func":      "getOrCreateSession",
                "sessionID": sessionID,
        }).Info("New session created")

        return session, nil</span>
}

// startSessionCleanup starts a background goroutine that periodically cleans up expired sessions.
// It runs every 5 minutes and removes sessions that have been inactive for more than 30 minutes.
//
// The cleanup process:
// 1. Iterates through all sessions under a mutex lock
// 2. Checks each session's LastActive timestamp
// 3. For expired sessions:
//   - Closes the websocket connection if present
//   - Closes the message channel
//   - Removes the session from the sessions map
//
// The function logs:
// - Debug messages when starting and during each cleanup cycle
// - Info messages for removed sessions and cleanup completion
// - Error messages if websocket connections fail to close
//
// Related types:
// - RPCServer - The server instance this runs on
// - Session - The session objects being cleaned up
//
// Note: This is a non-blocking function as it launches the cleanup routine in a separate goroutine.
/*func (s *RPCServer) startSessionCleanup() {
        logrus.WithFields(logrus.Fields{
                "func": "startSessionCleanup",
        }).Debug("Starting session cleanup routine")

        go func() {
                ticker := time.NewTicker(5 * time.Minute)
                defer ticker.Stop()

                for range ticker.C {
                        logrus.WithFields(logrus.Fields{
                                "func": "startSessionCleanup",
                        }).Debug("Running cleanup cycle")

                        s.mu.Lock()
                        expiredCount := 0
                        for id, session := range s.sessions {
                                if time.Since(session.LastActive) &gt; 30*time.Minute {
                                        logrus.WithFields(logrus.Fields{
                                                "func":      "startSessionCleanup",
                                                "sessionID": id,
                                                "inactive":  time.Since(session.LastActive),
                                        }).Info("Removing expired session")

                                        if session.WSConn != nil {
                                                if err := session.WSConn.Close(); err != nil {
                                                        logrus.WithFields(logrus.Fields{
                                                                "func":      "startSessionCleanup",
                                                                "sessionID": id,
                                                                "error":     err,
                                                        }).Error("Failed to close websocket connection")
                                                }
                                        }
                                        close(session.MessageChan)
                                        delete(s.sessions, id)
                                        expiredCount++
                                }
                        }
                        s.mu.Unlock()

                        logrus.WithFields(logrus.Fields{
                                "func":         "startSessionCleanup",
                                "expiredCount": expiredCount,
                                "totalActive":  len(s.sessions),
                        }).Info("Cleanup cycle completed")
                }
        }()
}
*/
func (s *RPCServer) startSessionCleanup() <span class="cov0" title="0">{
        ticker := time.NewTicker(sessionCleanupInterval)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                s.cleanupExpiredSessions()</span>
                        case &lt;-s.done:<span class="cov0" title="0">
                                ticker.Stop()
                                return</span>
                        }
                }
        }()
}

func (s *RPCServer) cleanupExpiredSessions() <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        now := time.Now()
        for id, session := range s.sessions </span><span class="cov0" title="0">{
                if now.Sub(session.LastActive) &gt; sessionTimeout </span><span class="cov0" title="0">{
                        if session.WSConn != nil </span><span class="cov0" title="0">{
                                session.WSConn.Close()
                        }</span>
                        <span class="cov0" title="0">delete(s.sessions, id)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package server

import (
        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// processSpellCast handles the execution of a spell cast by a player.
// It validates the spell requirements and processes the effects based on the spell school.
//
// Parameters:
//   - caster: *game.Player - The player casting the spell
//   - spell: *game.Spell - The spell being cast
//   - targetID: string - ID of the target (player/monster/object)
//   - pos: game.Position - Position for location-based spells
//
// Returns:
//   - interface{} - The result of the spell cast, specific to each spell type
//   - error - Any validation or processing errors that occurred
//
// Errors:
//   - Returns validation errors from validateSpellCast
//   - May return errors from individual spell processing functions
//
// Related:
//   - validateSpellCast
//   - processEvocationSpell
//   - processEnchantmentSpell
//   - processIllusionSpell
//   - processGenericSpell
func (s *RPCServer) processSpellCast(caster *game.Player, spell *game.Spell, targetID string, pos game.Position) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "processSpellCast",
                "caster":   caster.ID,
                "spell":    spell.Name,
                "targetID": targetID,
        }).Debug("processing spell cast")

        // Validate spell requirements
        if err := s.validateSpellCast(caster, spell); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "processSpellCast",
                        "error":    err.Error(),
                }).Error("spell validation failed")
                return nil, err
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function":    "processSpellCast",
                "spellSchool": spell.School,
        }).Info("processing spell by school")

        // Process spell effects based on type
        var result interface{}
        var err error
        switch spell.School </span>{
        case game.SchoolEvocation:<span class="cov0" title="0">
                result, err = s.processEvocationSpell(spell, caster, targetID)</span>
        case game.SchoolEnchantment:<span class="cov0" title="0">
                result, err = s.processEnchantmentSpell(spell, caster, targetID)</span>
        case game.SchoolIllusion:<span class="cov0" title="0">
                result, err = s.processIllusionSpell(spell, caster, pos)</span>
        default:<span class="cov0" title="0">
                logrus.WithFields(logrus.Fields{
                        "function":    "processSpellCast",
                        "spellSchool": spell.School,
                }).Warn("unknown spell school, using generic processing")
                result, err = s.processGenericSpell(spell, caster, targetID)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function": "processSpellCast",
                        "error":    err.Error(),
                }).Error("spell processing failed")
        }</span>

        <span class="cov0" title="0">return result, err</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package server

import (
        "fmt"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

func (s *RPCServer) hasSpellComponent(caster *game.Player, component game.SpellComponent) bool <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function":  "hasSpellComponent",
                "caster_id": caster.ID,
                "component": component,
        }).Debug("checking spell component")

        // Check if the caster has the required spell component in their inventory
        if component == game.ComponentMaterial </span><span class="cov0" title="0">{
                for _, item := range caster.Inventory </span><span class="cov0" title="0">{
                        if item.Type == "SpellComponent" </span><span class="cov0" title="0">{
                                logrus.WithFields(logrus.Fields{
                                        "function": "hasSpellComponent",
                                }).Debug("found required spell component")
                                return true
                        }</span>
                }
                <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                        "function":  "hasSpellComponent",
                        "component": component,
                }).Warn("spell component not found in inventory")
                return false</span>
        }

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function":  "hasSpellComponent",
                "component": component,
        }).Debug("non-material component check completed")
        return false</span>
}

func (s *RPCServer) validateSpellCast(caster *game.Player, spell *game.Spell) error <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function":  "validateSpellCast",
                "caster_id": caster.ID,
                "spell_id":  spell.ID,
        }).Debug("validating spell cast")

        // Check level requirements
        if caster.Level &lt; spell.Level </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "function":       "validateSpellCast",
                        "caster_level":   caster.Level,
                        "required_level": spell.Level,
                }).Warn("insufficient level to cast spell")
                return fmt.Errorf("insufficient level to cast spell")
        }</span>

        // Check components
        <span class="cov0" title="0">for _, component := range spell.Components </span><span class="cov0" title="0">{
                if !s.hasSpellComponent(caster, component) </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "function":  "validateSpellCast",
                                "component": component,
                        }).Warn("missing required spell component")
                        return fmt.Errorf("missing required spell component: %v", component)
                }</span>
        }

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "function": "validateSpellCast",
        }).Debug("spell cast validation successful")
        return nil</span>
}

func (s *RPCServer) processEvocationSpell(spell *game.Spell, caster *game.Player, targetID string) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "processEvocationSpell",
                "spell_id": spell.ID,
                "caster":   caster.ID,
                "target":   targetID,
        }).Debug("processing evocation spell")

        // Implement damage/healing spells
        result := map[string]interface{}{
                "success":  true,
                "spell_id": spell.ID,
        }

        logrus.WithFields(logrus.Fields{
                "function": "processEvocationSpell",
                "spell_id": spell.ID,
        }).Debug("evocation spell processed")

        return result, nil
}</span>

func (s *RPCServer) processEnchantmentSpell(spell *game.Spell, caster *game.Player, targetID string) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "processEnchantmentSpell",
                "spell_id": spell.ID,
                "caster":   caster.ID,
                "target":   targetID,
        }).Debug("processing enchantment spell")

        // Implement buff/debuff spells
        result := map[string]interface{}{
                "success":  true,
                "spell_id": spell.ID,
        }

        logrus.WithFields(logrus.Fields{
                "function": "processEnchantmentSpell",
                "spell_id": spell.ID,
        }).Debug("enchantment spell processed")

        return result, nil
}</span>

func (s *RPCServer) processIllusionSpell(spell *game.Spell, caster *game.Player, pos game.Position) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "processIllusionSpell",
                "spell_id": spell.ID,
                "caster":   caster.ID,
                "position": pos,
        }).Debug("processing illusion spell")

        // Implement area effect spells
        result := map[string]interface{}{
                "success":  true,
                "spell_id": spell.ID,
        }

        logrus.WithFields(logrus.Fields{
                "function": "processIllusionSpell",
                "spell_id": spell.ID,
        }).Debug("illusion spell processed")

        return result, nil
}</span>

func (s *RPCServer) processGenericSpell(spell *game.Spell, caster *game.Player, targetID string) (interface{}, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "processGenericSpell",
                "spell_id": spell.ID,
                "caster":   caster.ID,
                "target":   targetID,
        }).Debug("processing generic spell")

        // Default spell processing
        result := map[string]interface{}{
                "success":  true,
                "spell_id": spell.ID,
        }

        logrus.WithFields(logrus.Fields{
                "function": "processGenericSpell",
                "spell_id": spell.ID,
        }).Debug("generic spell processed")

        return result, nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package server

import (
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// GameState represents the core game state container managing all dynamic game elements.
// It provides thread-safe access to the world state, turn sequencing, time tracking,
// and player session management.
//
// Fields:
//   - WorldState: Holds the current state of the game world including entities, items, etc
//   - TurnManager: Manages turn order and action resolution for game entities
//   - TimeManager: Tracks game time progression and scheduling
//   - Sessions: Maps session IDs to active PlayerSession objects
//   - mu: Provides thread-safe access to state
//   - updates: Channel for broadcasting state changes to listeners
//
// Thread Safety:
// All public methods are protected by mutex to ensure thread-safe concurrent access.
// The updates channel allows for non-blocking notifications of state changes.
//
// Related Types:
//   - game.World
//   - TurnManager
//   - TimeManager
//   - PlayerSession
type GameState struct {
        WorldState  *game.World               `yaml:"state_world"`
        TurnManager *TurnManager              `yaml:"state_turns"`
        TimeManager *TimeManager              `yaml:"state_time"`
        Sessions    map[string]*PlayerSession `yaml:"state_sessions"`
        Version     int                       `yaml:"state_version"`

        // Locking implementation
        stateMu   sync.RWMutex `yaml:"-"` // Primary state mutex
        worldMu   sync.RWMutex `yaml:"-"` // World state mutex
        sessionMu sync.RWMutex `yaml:"-"` // Session mutex
        turnMu    sync.RWMutex `yaml:"-"` // Turn manager mutex

        // State caching
        cachedState  atomic.Value `yaml:"-"` // Cached state data
        cacheVersion int32        `yaml:"-"` // Atomic cache version

        updates chan StateUpdate `yaml:"-"` // Update channel
}

// AddPlayer initializes a new player in the game state
func (gs *GameState) AddPlayer(session *PlayerSession) <span class="cov0" title="0">{
        if session == nil || session.Player == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">gs.worldMu.Lock()
        defer gs.worldMu.Unlock()

        // Initialize WorldState if nil
        if gs.WorldState == nil </span><span class="cov0" title="0">{
                gs.WorldState = &amp;game.World{}
        }</span>

        // Initialize Objects map if nil
        <span class="cov0" title="0">if gs.WorldState.Objects == nil </span><span class="cov0" title="0">{
                gs.WorldState.Objects = make(map[string]game.GameObject)
        }</span>

        // Add player to world state
        <span class="cov0" title="0">gs.WorldState.Objects[session.Player.GetID()] = session.Player</span>
}

func (s *GameState) GetState() map[string]interface{} <span class="cov0" title="0">{
        // Try to get cached state first
        if cached := s.cachedState.Load(); cached != nil </span><span class="cov0" title="0">{
                if state, ok := cached.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if atomic.LoadInt32(&amp;s.cacheVersion) == int32(s.Version) </span><span class="cov0" title="0">{
                                return state
                        }</span>
                }
        }

        // Cache miss - generate new state with minimal locking
        <span class="cov0" title="0">s.stateMu.RLock()
        version := s.Version
        s.stateMu.RUnlock()

        state := make(map[string]interface{})

        // Get world state with separate lock
        s.worldMu.RLock()
        state["world"] = s.WorldState.Serialize()
        s.worldMu.RUnlock()

        // Get time state
        state["time"] = s.TimeManager.Serialize()

        // Get turn state with separate lock
        s.turnMu.RLock()
        state["turns"] = s.TurnManager.Serialize()
        s.turnMu.RUnlock()

        // Get session data with separate lock
        s.sessionMu.RLock()
        sessions := make(map[string]interface{})
        for id, session := range s.Sessions </span><span class="cov0" title="0">{
                sessions[id] = session.PublicData()
        }</span>
        <span class="cov0" title="0">s.sessionMu.RUnlock()
        state["sessions"] = sessions

        state["version"] = version

        // Update cache
        s.cachedState.Store(state)
        atomic.StoreInt32(&amp;s.cacheVersion, int32(version))

        return state</span>
}

func (s *GameState) validate() error <span class="cov0" title="0">{
        if s.WorldState == nil ||
                s.TimeManager == nil ||
                s.TurnManager == nil ||
                s.Sessions == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("missing required state components")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *GameState) UpdateState(updates map[string]interface{}) error <span class="cov0" title="0">{
        // Create snapshot for rollback under read lock
        s.stateMu.RLock()
        snapshot := s.createSnapshot()
        version := s.Version
        s.stateMu.RUnlock()

        // Acquire locks in consistent order to prevent deadlocks
        s.worldMu.Lock()
        s.sessionMu.Lock()
        s.turnMu.Lock()
        s.stateMu.Lock()
        defer func() </span><span class="cov0" title="0">{
                s.stateMu.Unlock()
                s.turnMu.Unlock()
                s.sessionMu.Unlock()
                s.worldMu.Unlock()
        }</span>()

        // Verify version hasn't changed
        <span class="cov0" title="0">if s.Version != version </span><span class="cov0" title="0">{
                return fmt.Errorf("state version changed during update")
        }</span>

        // Apply updates with timeout
        <span class="cov0" title="0">done := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                done &lt;- s.applyUpdates(updates)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-done:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        s.rollback(snapshot)
                        return err
                }</span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                s.rollback(snapshot)
                return fmt.Errorf("update timed out")</span>
        }

        <span class="cov0" title="0">s.Version++
        // Invalidate cache
        atomic.StoreInt32(&amp;s.cacheVersion, -1)

        return nil</span>
}

func (gs *GameState) rollback(snapshot any) <span class="cov0" title="0">{
        if snapshotState, ok := snapshot.(*GameState); ok </span><span class="cov0" title="0">{
                // Restore all state components from snapshot
                gs.WorldState = snapshotState.WorldState
                gs.TimeManager = snapshotState.TimeManager
                gs.TurnManager = snapshotState.TurnManager
                gs.Sessions = snapshotState.Sessions
                gs.Version = snapshotState.Version

                logrus.WithField("version", gs.Version).Info("rolled back game state to previous snapshot")
        }</span> else<span class="cov0" title="0"> {
                logrus.Error("invalid snapshot type for rollback")
        }</span>
}

func (gs *GameState) applyUpdates(updates map[string]interface{}) error <span class="cov0" title="0">{
        // Handle world state updates
        if worldUpdates, ok := updates["world"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if err := gs.WorldState.Update(worldUpdates); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("world update failed: %w", err)
                }</span>
        }

        // Handle time manager updates
        <span class="cov0" title="0">if timeUpdates, ok := updates["time"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if currentTime, ok := timeUpdates["current_time"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if scale, ok := currentTime["time_scale"].(float64); ok </span><span class="cov0" title="0">{
                                gs.TimeManager.TimeScale = scale
                        }</span>
                }
        }

        // Handle turn manager updates
        <span class="cov0" title="0">if turnUpdates, ok := updates["turns"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if err := gs.TurnManager.Update(turnUpdates); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("turn update failed: %v", err)
                }</span>
        }

        // Handle session updates
        <span class="cov0" title="0">if sessionUpdates, ok := updates["sessions"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for id, update := range sessionUpdates </span><span class="cov0" title="0">{
                        if session, exists := gs.Sessions[id]; exists </span><span class="cov0" title="0">{
                                if updateMap, ok := update.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if err := session.Update(updateMap); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("session update failed for %s: %v", id, err)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (gs *GameState) createSnapshot() any <span class="cov0" title="0">{
        // Create a deep copy of the game state for rollback purposes
        snapshot := &amp;GameState{
                WorldState: gs.WorldState.Clone(), // Assuming World has a Clone method
                TimeManager: &amp;TimeManager{
                        CurrentTime:     gs.TimeManager.CurrentTime,
                        TimeScale:       gs.TimeManager.TimeScale,
                        LastTick:        gs.TimeManager.LastTick,
                        ScheduledEvents: make([]ScheduledEvent, len(gs.TimeManager.ScheduledEvents)),
                },
                TurnManager: gs.TurnManager.Clone(), // Assuming TurnManager has a Clone method
                Sessions:    make(map[string]*PlayerSession),
        }

        // Copy scheduled events
        copy(snapshot.TimeManager.ScheduledEvents, gs.TimeManager.ScheduledEvents)

        // Copy sessions
        for id, session := range gs.Sessions </span><span class="cov0" title="0">{
                snapshot.Sessions[id] = session.Clone() // Assuming PlayerSession has a Clone method
        }</span>

        <span class="cov0" title="0">return snapshot</span>
}

// TimeManager handles game time progression and scheduled event management.
// It maintains the current game time, controls time progression speed,
// and manages a queue of scheduled future events.
//
// Fields:
//   - CurrentTime: The current in-game time represented as a GameTime struct
//   - TimeScale: Multiplier that controls how fast game time progresses relative to real time (e.g. 2.0 = twice as fast)
//   - LastTick: Real-world timestamp of the most recent time update
//   - ScheduledEvents: Slice of pending events to be triggered at specific game times
//
// Related types:
//   - game.GameTime - Represents a point in game time
//   - ScheduledEvent - Defines a future event to occur at a specific game time
type TimeManager struct {
        CurrentTime     game.GameTime    `yaml:"time_current"`          // Current game time
        TimeScale       float64          `yaml:"time_scale"`            // Time progression rate
        LastTick        time.Time        `yaml:"time_last_tick"`        // Last update time
        ScheduledEvents []ScheduledEvent `yaml:"time_scheduled_events"` // Pending events
}

// Serialize returns a map representation of the TimeManager state
func (t *TimeManager) Serialize() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "current_time": map[string]interface{}{
                        "real_time":  t.CurrentTime.RealTime,
                        "game_ticks": t.CurrentTime.GameTicks,
                        "time_scale": t.CurrentTime.TimeScale,
                },
                "time_scale": t.TimeScale,
                "last_tick":  t.LastTick,
                "events": func() []map[string]interface{} </span><span class="cov0" title="0">{
                        events := make([]map[string]interface{}, len(t.ScheduledEvents))
                        for i, event := range t.ScheduledEvents </span><span class="cov0" title="0">{
                                events[i] = map[string]interface{}{
                                        "id":           event.EventID,
                                        "type":         event.EventType,
                                        "trigger_time": event.TriggerTime,
                                        "parameters":   event.Parameters,
                                        "repeating":    event.Repeating,
                                }
                        }</span>
                        <span class="cov0" title="0">return events</span>
                }(),
        }
}

// ScheduledEvent represents a future event that will be triggered at a specific game time.
// It is used to schedule in-game events like monster spawns, weather changes, or quest updates.
//
// Fields:
//   - EventID: Unique string identifier for the event
//   - EventType: Category/type of the event (e.g. "spawn", "weather", etc)
//   - TriggerTime: The game.GameTime when this event should execute
//   - Parameters: Additional string data needed for the event execution
//   - Repeating: If true, the event will reschedule itself after triggering
//
// Related types:
//   - game.GameTime: Represents the in-game time when event triggers
type ScheduledEvent struct {
        EventID     string        `yaml:"event_id"`           // Event identifier
        EventType   string        `yaml:"event_type"`         // Type of event
        TriggerTime game.GameTime `yaml:"event_trigger_time"` // When to trigger
        Parameters  []string      `yaml:"event_parameters"`   // Event data
        Repeating   bool          `yaml:"event_is_repeating"` // Whether it repeats
}

// ScriptContext represents the execution state and variables of a running script in the game.
// It maintains context between script executions including variables and timing.
//
// Fields:
//   - ScriptID: Unique identifier string for the script
//   - Variables: Map storing script state variables and their values
//   - LastExecuted: Timestamp of when the script was last run
//   - IsActive: Boolean flag indicating if script is currently executing
//
// Related types:
//   - Server.Scripts (map[string]*ScriptContext)
//   - ScriptEngine interface
//
// Thread-safety: This struct should be protected by a mutex when accessed concurrently
type ScriptContext struct {
        ScriptID     string                 `yaml:"script_id"`            // Script identifier
        Variables    map[string]interface{} `yaml:"script_variables"`     // Script state
        LastExecuted time.Time              `yaml:"script_last_executed"` // Last run timestamp
        IsActive     bool                   `yaml:"script_is_active"`     // Execution state
}

// NewTimeManager creates and initializes a new TimeManager instance.
//
// The TimeManager handles game time tracking, time scaling, and scheduled event management.
// It maintains the current game time, real time mapping, and a list of scheduled events.
//
// Returns:
//   - *TimeManager: A new TimeManager instance initialized with:
//   - Current time set to now
//   - Game ticks starting at 0
//   - Default time scale of 1.0
//   - Empty scheduled events list
//
// Related types:
//   - game.GameTime
//   - ScheduledEvent
func NewTimeManager() *TimeManager <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "function": "NewTimeManager",
        }).Debug("creating new time manager")

        tm := &amp;TimeManager{
                CurrentTime: game.GameTime{
                        RealTime:  time.Now(),
                        GameTicks: 0,
                        TimeScale: 1.0,
                },
                TimeScale:       1.0,
                LastTick:        time.Now(),
                ScheduledEvents: make([]ScheduledEvent, 0),
        }

        logrus.WithFields(logrus.Fields{
                "function":  "NewTimeManager",
                "timeScale": tm.TimeScale,
                "lastTick":  tm.LastTick,
        }).Info("time manager initialized")

        return tm
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package server

import (
        "fmt"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/gorilla/websocket"
)

// RPCMethod represents a unique identifier for RPC methods in the system.
// It is a string type alias used to strongly type RPC method names and
// prevent errors from mistyped method strings.
type RPCMethod string

// MethodMove represents an RPC method for handling player movement actions in the game.
// This method allows a player character to change their position on the game map.
// Related methods: MethodEndTurn, MethodGetGameState
//
// Expected payload parameters:
// - position: Vec2D - Target destination coordinates
// - characterID: string - ID of the character being moved
//
// Returns:
// - error if movement is invalid or character cannot move
//
// Edge cases:
// - Movement blocked by obstacles/terrain
// - Character has insufficient movement points
// - Position is outside map bounds
const (
        MethodMove           RPCMethod = "move"
        MethodAttack         RPCMethod = "attack"
        MethodCastSpell      RPCMethod = "castSpell"
        MethodUseItem        RPCMethod = "useItem"
        MethodApplyEffect    RPCMethod = "applyEffect"
        MethodStartCombat    RPCMethod = "startCombat"
        MethodEndTurn        RPCMethod = "endTurn"
        MethodGetGameState   RPCMethod = "getGameState"
        MethodJoinGame       RPCMethod = "joinGame"
        MethodLeaveGame      RPCMethod = "leaveGame"
        MethodCreateCharacter RPCMethod = "createCharacter"
)

// EventCombatStart represents when combat begins in the game. This event is triggered
// when characters initiate or are forced into combat.
// Event number: 100 (base combat event number + iota)
// Related events: EventCombatEnd, EventTurnStart, EventTurnEnd
const (
        EventCombatStart game.EventType = 100 + iota
        EventCombatEnd
        EventTurnStart
        EventTurnEnd
        EventMovement
)

// StateUpdate represents an atomic change to the game state.
// It captures what changed, which entity was affected, and when the change occurred.
//
// Fields:
//   - UpdateType: String identifying the type of update (e.g. "MOVE", "DAMAGE")
//   - EntityID: Unique identifier for the affected game entity
//   - ChangeData: Map containing the specific changes/updates to apply.
//     Values can be of any type due to interface{}
//   - Timestamp: When this state update occurred
//
// StateUpdate is used by the game engine to track and apply changes to entities.
// Updates are processed in chronological order based on Timestamp.
//
// Related types:
//   - Entity: The game object being modified
//   - Game: Top level game state manager
type StateUpdate struct {
        UpdateType string                 `yaml:"update_type"`      // Type of update
        EntityID   string                 `yaml:"update_entity_id"` // Affected entity
        ChangeData map[string]interface{} `yaml:"update_data"`      // Update details
        Timestamp  time.Time              `yaml:"update_timestamp"` // When it occurred
}

// PlayerSession represents an active game session for a player, managing their connection state
// and activity tracking. It maintains the link between a player and their current game session.
//
// Fields:
//   - SessionID: A unique string identifier for this specific session
//   - Player: Pointer to the associated game.Player instance containing player data
//   - LastActive: Timestamp of the most recent player activity in this session
//   - Connected: Boolean flag indicating if the player is currently connected
//
// Related types:
//   - game.Player: The player entity associated with this session
type PlayerSession struct {
        SessionID   string          `yaml:"session_id"`  // Unique session identifier
        Player      *game.Player    `yaml:"player"`      // Associated player
        LastActive  time.Time       `yaml:"last_active"` // Last activity timestamp
        CreatedAt   time.Time       `yaml:"created_at"`  // Session creation timestamp
        Connected   bool            `yaml:"connected"`   // Connection status
        MessageChan chan []byte     `yaml:"-"`           // Channel for sending messages
        WSConn      *websocket.Conn `yaml:"-"`           // WebSocket connection
}

func (p *PlayerSession) Update(updateMap map[string]interface{}) error <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot update nil PlayerSession")
        }</span>

        <span class="cov8" title="1">for key, value := range updateMap </span><span class="cov8" title="1">{
                switch key </span>{
                case "player":<span class="cov8" title="1">
                        if playerData, ok := value.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                p.Player.Update(playerData)
                        }</span>
                case "connected":<span class="cov8" title="1">
                        if connected, ok := value.(bool); ok </span><span class="cov8" title="1">{
                                p.Connected = connected
                        }</span>
                case "lastActive":<span class="cov8" title="1">
                        if timestamp, ok := value.(time.Time); ok </span><span class="cov8" title="1">{
                                p.LastActive = timestamp
                        }</span>
                case "sessionId":<span class="cov8" title="1">
                        if sessionID, ok := value.(string); ok </span><span class="cov8" title="1">{
                                p.SessionID = sessionID
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (p *PlayerSession) Clone() *PlayerSession <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">clone := &amp;PlayerSession{
                SessionID:   p.SessionID,
                Player:      p.Player.Clone(), // Assuming Player has a Clone method
                LastActive:  p.LastActive,
                CreatedAt:   p.CreatedAt,
                Connected:   p.Connected,
                MessageChan: make(chan []byte), // Create new channel
                WSConn:      p.WSConn,          // Keep same connection
        }
        return clone</span>
}

func (p *PlayerSession) PublicData() interface{} <span class="cov8" title="1">{
        return struct {
                SessionID  string      `json:"sessionId"`
                PlayerData interface{} `json:"player"`
                Connected  bool        `json:"connected"`
                LastActive time.Time   `json:"lastActive"`
        }{
                SessionID:  p.SessionID,
                PlayerData: p.Player.PublicData(),
                Connected:  p.Connected,
                LastActive: p.LastActive,
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package server

import (
        "path/filepath"
        "regexp"
        "sort"
        "strconv"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
        "golang.org/x/exp/rand"
)

// rollInitiative determines the combat turn order for a list of participants by rolling initiative.
//
// Parameters:
//   - participants: A slice of entity IDs (strings) representing the combatants
//
// Returns:
//   - A slice of entity IDs sorted by initiative roll (highest to lowest)
//
// The initiative roll is calculated as:
//   - For Characters: d20 + DEX modifier (Dexterity-10)/2
//   - For other entities: d20 only
//
// Note: Characters must exist in s.state.WorldState.Objects to have their DEX bonus applied.
// Non-existent entities are skipped in the result.
//
// Related:
//   - game.Character struct - for character stats
//   - s.state.WorldState.Objects - entity storage
func (s *RPCServer) rollInitiative(participants []string) []string <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function":        "rollInitiative",
                "numParticipants": len(participants),
        })
        logger.Debug("rolling initiative")

        type initiativeRoll struct {
                entityID string
                roll     int
        }

        rolls := make([]initiativeRoll, len(participants))
        for i, id := range participants </span><span class="cov0" title="0">{
                logger := logger.WithField("entityID", id)
                if obj, exists := s.state.WorldState.Objects[id]; exists </span><span class="cov0" title="0">{
                        if char, ok := obj.(*game.Character); ok </span><span class="cov0" title="0">{
                                roll := rand.Intn(20) + 1
                                modifier := (char.Dexterity - 10) / 2
                                rolls[i] = initiativeRoll{
                                        entityID: id,
                                        roll:     roll + modifier,
                                }
                                logger.WithFields(logrus.Fields{
                                        "baseRoll": roll,
                                        "modifier": modifier,
                                        "total":    rolls[i].roll,
                                }).Info("rolled initiative for character")
                        }</span> else<span class="cov0" title="0"> {
                                roll := rand.Intn(20) + 1
                                rolls[i] = initiativeRoll{
                                        entityID: id,
                                        roll:     roll,
                                }
                                logger.WithField("roll", roll).Info("rolled initiative for entity")
                        }</span>
                } else<span class="cov0" title="0"> {
                        logger.Warn("entity not found in world state")
                }</span>
        }

        <span class="cov0" title="0">sort.Slice(rolls, func(i, j int) bool </span><span class="cov0" title="0">{
                return rolls[i].roll &gt; rolls[j].roll
        }</span>)

        <span class="cov0" title="0">result := make([]string, len(rolls))
        for i, roll := range rolls </span><span class="cov0" title="0">{
                result[i] = roll.entityID
        }</span>

        <span class="cov0" title="0">logger.WithField("order", result).Info("initiative order determined")
        return result</span>
}

// getVisibleObjects returns all game objects that are within the player's visible range.
// The visibility is determined by the isPositionVisible method which checks if the object's
// position is within line of sight and range of the player.
//
// Parameters:
//   - player: *game.Player - The player whose visibility range is being checked
//
// Returns:
//   - []game.GameObject - Slice containing all visible game objects from the world state
//
// Related:
//   - isPositionVisible() - Used to check if a position is visible from player's position
//   - game.GameObject - Interface implemented by all game objects
//   - game.Player - Player entity struct
func (s *RPCServer) getVisibleObjects(player *game.Player) []game.GameObject <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "getVisibleObjects",
                "playerID": player.GetID(),
        })
        logger.Debug("getting visible objects for player")

        playerPos := player.GetPosition()
        logger.WithField("position", playerPos).Debug("got player position")

        visibleObjects := make([]game.GameObject, 0)

        for _, obj := range s.state.WorldState.Objects </span><span class="cov0" title="0">{
                objPos := obj.GetPosition()
                if s.isPositionVisible(playerPos, objPos) </span><span class="cov0" title="0">{
                        logger.WithFields(logrus.Fields{
                                "objectID": obj.GetID(),
                                "position": objPos,
                        }).Debug("object is visible")
                        visibleObjects = append(visibleObjects, obj)
                }</span>
        }

        <span class="cov0" title="0">logger.WithField("visibleCount", len(visibleObjects)).Info("finished getting visible objects")
        return visibleObjects</span>
}

// getActiveEffects retrieves all active effects currently applied to a player
//
// Parameters:
//   - player *game.Player: The player object to check for effects. Must not be nil.
//
// Returns:
//   - []*game.Effect: Slice of active effects on the player. Returns nil if player
//     does not implement game.EffectHolder interface.
//
// Related types:
//   - game.Effect
//   - game.EffectHolder
//   - game.Player
//
// Note: Uses type assertion to check if player implements EffectHolder interface.
func (s *RPCServer) getActiveEffects(player *game.Player) []*game.Effect <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "getActiveEffects",
                "playerID": player.GetID(),
        })
        logger.Debug("getting active effects for player")

        if holder, ok := interface{}(player).(game.EffectHolder); ok </span><span class="cov0" title="0">{
                effects := holder.GetEffects()
                logger.WithField("numEffects", len(effects)).Info("retrieved active effects")
                return effects
        }</span>
        <span class="cov0" title="0">logger.Warn("player does not implement EffectHolder interface")
        return nil</span>
}

// getCombatStateIfActive retrieves the current combat state for an active combat session.
// If there is no active combat, it returns nil.
//
// Parameters:
//   - player: *game.Player - The player for whom to get the combat state
//
// Returns:
//   - *CombatState - Contains combat information including:
//   - Active combatants in initiative order
//   - Current round count
//   - Combat zone position
//   - Active status effects
//     Returns nil if no combat is active
//
// Related:
//   - TurnManager.IsInCombat
//   - CombatState struct
func (s *RPCServer) getCombatStateIfActive(player *game.Player) *CombatState <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "getCombatStateIfActive",
                "playerID": player.GetID(),
        })
        logger.Debug("checking combat state")

        if !s.state.TurnManager.IsInCombat </span><span class="cov0" title="0">{
                logger.Info("no active combat")
                return nil
        }</span>

        <span class="cov0" title="0">state := &amp;CombatState{
                ActiveCombatants: s.state.TurnManager.Initiative,
                RoundCount:       s.state.TurnManager.CurrentRound,
                CombatZone:       player.GetPosition(),
                StatusEffects:    s.getCombatEffects(),
        }

        logger.WithFields(logrus.Fields{
                "combatants": len(state.ActiveCombatants),
                "round":      state.RoundCount,
                "position":   state.CombatZone,
        }).Info("retrieved active combat state")

        return state</span>
}

// getCombatEffects returns a map of active effects for all objects in the current combat initiative order.
//
// The function iterates through all objects in the TurnManager's initiative order and collects
// any active effects on objects that implement the EffectHolder interface.
//
// Returns:
//   - map[string][]game.Effect: A map where keys are object IDs and values are slices of active effects
//
// Related types:
//   - game.Effect: The effect type being collected
//   - game.EffectHolder: Interface for objects that can have effects
//
// Note: Objects that don't exist in WorldState or don't implement EffectHolder are skipped.
// Only objects with active effects will have entries in the returned map.
func (s *RPCServer) getCombatEffects() map[string][]game.Effect <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "getCombatEffects",
        })
        logger.Debug("collecting combat effects")

        effects := make(map[string][]game.Effect)

        for _, id := range s.state.TurnManager.Initiative </span><span class="cov0" title="0">{
                logger := logger.WithField("entityID", id)
                if obj, exists := s.state.WorldState.Objects[id]; exists </span><span class="cov0" title="0">{
                        if holder, ok := obj.(game.EffectHolder); ok </span><span class="cov0" title="0">{
                                activeEffects := holder.GetEffects()
                                if len(activeEffects) &gt; 0 </span><span class="cov0" title="0">{
                                        logger.WithField("numEffects", len(activeEffects)).Info("adding effects for entity")
                                        effects[id] = make([]game.Effect, len(activeEffects))
                                        for i, effect := range activeEffects </span><span class="cov0" title="0">{
                                                effects[id][i] = *effect
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        logger.Debug("entity has no active effects")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                logger.Debug("entity does not implement EffectHolder")
                        }</span>
                } else<span class="cov0" title="0"> {
                        logger.Warn("entity not found in world state")
                }</span>
        }

        <span class="cov0" title="0">logger.WithField("totalEntities", len(effects)).Info("finished collecting combat effects")
        return effects</span>
}

// isPositionVisible checks if a target position is visible from a given source position.
// It determines visibility based on Manhattan distance and level matching.
//
// Parameters:
//   - from: The source Position containing X,Y coordinates and Level
//   - to: The target Position to check visibility for
//
// Returns:
//   - bool: true if target position is visible (within 10 unit distance and on same level),
//     false otherwise
//
// Notes:
//   - Uses square of Euclidean distance (dx+dy) &lt;= 100 for performance
//   - Requires positions to be on the same level
//   - Distance check uses a radius of 10 units (square root of 100)
func (s *RPCServer) isPositionVisible(from, to game.Position) bool <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "isPositionVisible",
                "from":     from,
                "to":       to,
        })
        logger.Debug("checking position visibility")

        dx := from.X - to.X
        dy := from.Y - to.Y
        distanceSquared := dx*dx + dy*dy

        result := distanceSquared &lt;= 100 &amp;&amp; from.Level == to.Level
        logger.WithFields(logrus.Fields{
                "distanceSquared": distanceSquared,
                "sameLevel":       from.Level == to.Level,
                "visible":         result,
        }).Info("visibility check complete")

        return result
}</span>

// processEndTurnEffects processes any effects that should trigger at the end of a turn for a given game object.
// It checks if the object implements the EffectHolder interface and if so, iterates through its effects,
// processing any that should tick based on the current game time.
//
// Parameters:
//   - character: The game object to process end-turn effects for. Must implement game.GameObject interface.
//
// The function handles the following cases:
//   - If character does not implement EffectHolder, no effects are processed
//   - Each effect is checked against current time to determine if it should tick
//
// Related types:
//   - game.GameObject
//   - game.EffectHolder
//   - game.Effect
func (s *RPCServer) processEndTurnEffects(character game.GameObject) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "processEndTurnEffects",
                "charID":   character.GetID(),
        })
        logger.Debug("processing end turn effects")

        if holder, ok := character.(game.EffectHolder); ok </span><span class="cov0" title="0">{
                effects := holder.GetEffects()
                logger.WithField("numEffects", len(effects)).Info("checking effects")

                for _, effect := range effects </span><span class="cov0" title="0">{
                        logger := logger.WithField("effectID", effect.ID)
                        if effect.ShouldTick(s.state.TimeManager.CurrentTime.RealTime) </span><span class="cov0" title="0">{
                                logger.Info("processing effect tick")
                                s.state.processEffectTick(effect)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Debug("effect not ready to tick")
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                logger.Debug("character has no effects")
        }</span>
}

// processEndRound handles end-of-round processing for the game state:
// 1. Increments the current round counter
// 2. Processes any delayed/queued actions
// 3. Checks if combat has ended
//
// Related:
// - TurnManager.CurrentRound
// - processDelayedActions()
// - checkCombatEnd()
func (s *RPCServer) processEndRound() <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "processEndRound",
                "round":    s.state.TurnManager.CurrentRound,
        })
        logger.Debug("processing end of round")

        s.state.TurnManager.CurrentRound++
        logger.WithField("newRound", s.state.TurnManager.CurrentRound).Info("incremented round counter")

        s.processDelayedActions()
        logger.Debug("processed delayed actions")

        s.checkCombatEnd()
        logger.Debug("checked combat end conditions")
}</span>

// isTimeToExecute checks if a given game time has been reached based on tick counts
//
// Parameters:
//   - current: The current game time
//   - trigger: The target game time to compare against
//
// Returns:
//
//        bool: true if current game ticks is greater than or equal to trigger ticks,
//        false otherwise
//
// Related:
//   - game.GameTime struct
func isTimeToExecute(current, trigger game.GameTime) bool <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function":     "isTimeToExecute",
                "currentTicks": current.GameTicks,
                "triggerTicks": trigger.GameTicks,
        })
        logger.Debug("checking execution time")

        result := current.GameTicks &gt;= trigger.GameTicks
        logger.WithField("result", result).Info("time check complete")
        return result
}</span>

// findSpell searches for a spell in the provided slice of spells by ID.
// Parameters:
//   - spells: Slice of game.Spell objects to search through
//   - spellID: String ID of the spell to find
//
// Returns:
//   - *game.Spell: Pointer to the found spell, or nil if not found
//
// Related:
//   - game.Spell struct
func findSpell(spells []game.Spell, spellID string) *game.Spell <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "findSpell",
                "spellID":  spellID,
        })
        logger.Debug("searching for spell")

        for i := range spells </span><span class="cov8" title="1">{
                if spells[i].ID == spellID </span><span class="cov8" title="1">{
                        logger.WithField("found", true).Info("found spell")
                        return &amp;spells[i]
                }</span>
        }

        <span class="cov8" title="1">logger.WithField("found", false).Info("spell not found")
        return nil</span>
}

// findInventoryItem searches for an item in the inventory by its ID and returns a pointer to it if found.
//
// Parameters:
//   - inventory: []game.Item - slice of game items to search through
//   - itemID: string - unique identifier of the item to find
//
// Returns:
//   - *game.Item - pointer to the found item, or nil if not found
//
// Related:
//   - game.Item type
//
// Note: Returns nil if the item is not found in the inventory
func findInventoryItem(inventory []game.Item, itemID string) *game.Item <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "findInventoryItem",
                "itemID":   itemID,
        })
        logger.Debug("searching inventory for item")

        for i := range inventory </span><span class="cov8" title="1">{
                if inventory[i].ID == itemID </span><span class="cov8" title="1">{
                        logger.WithField("found", true).Info("found inventory item")
                        return &amp;inventory[i]
                }</span>
        }

        <span class="cov8" title="1">logger.WithField("found", false).Info("item not found in inventory")
        return nil</span>
}

// parseDamageString takes a damage string in dice notation format (e.g. "2d6+3") and returns the average damage value.
//
// The function accepts the following formats:
//   - Plain number (e.g. "5")
//   - Dice notation "XdY+Z" where:
//     X = number of dice (optional, defaults to 1)
//     Y = number of sides on each die
//     Z = fixed modifier to add (optional)
//
// Parameters:
//
//        damage string - The damage string to parse in dice notation format
//
// Returns:
//
//        int - The calculated average damage:
//        - For plain numbers, returns the number as-is
//        - For dice notation, returns average roll value of dice + modifier
//        - Returns 0 for invalid input formats
//
// Examples:
//
//        parseDamageString("5")    // Returns 5
//        parseDamageString("2d6")  // Returns 7 (avg of 2 six-sided dice)
//        parseDamageString("d8+2") // Returns 6.5 rounded to 6 (avg of 1d8 + 2)
//        parseDamageString("foo")  // Returns 0 (invalid format)
func parseDamageString(damage string) int <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "parseDamageString",
                "damage":   damage,
        })
        logger.Debug("parsing damage string")

        // Regular expression to match dice notation: XdY+Z
        re := regexp.MustCompile(`^(\d+)?d(\d+)(?:\+(\d+))?$`)

        // If it's just a number, return it
        if num, err := strconv.Atoi(damage); err == nil </span><span class="cov8" title="1">{
                logger.WithField("value", num).Info("parsed plain number")
                return num
        }</span>

        <span class="cov8" title="1">matches := re.FindStringSubmatch(damage)
        if matches == nil </span><span class="cov8" title="1">{
                logger.Warn("invalid dice notation format")
                return 0
        }</span>

        // Parse components
        <span class="cov8" title="1">numDice := 1
        if matches[1] != "" </span><span class="cov8" title="1">{
                var err error
                numDice, err = strconv.Atoi(matches[1])
                if err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("failed to parse number of dice")
                        return 0
                }</span>
        }

        <span class="cov8" title="1">dieSize, err := strconv.Atoi(matches[2])
        if err != nil </span><span class="cov8" title="1">{
                logger.WithError(err).Error("failed to parse die size")
                return 0
        }</span>

        <span class="cov8" title="1">modifier := 0
        if matches[3] != "" </span><span class="cov8" title="1">{
                var err error
                modifier, err = strconv.Atoi(matches[3])
                if err != nil </span><span class="cov8" title="1">{
                        logger.WithError(err).Error("failed to parse modifier")
                        return 0
                }</span>
        }

        // Calculate average damage
        <span class="cov8" title="1">averageDamage := int(float64(numDice) * (float64(dieSize) + 1) / 2)
        result := averageDamage + modifier

        logger.WithFields(logrus.Fields{
                "numDice":  numDice,
                "dieSize":  dieSize,
                "modifier": modifier,
                "result":   result,
        }).Info("calculated average damage")

        return result</span>
}

// min returns the smaller of two integers.
// Parameters:
//   - a: first integer to compare
//   - b: second integer to compare
//
// Returns:
//
//        The smaller of a and b
func min(a, b int) int <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "min",
                "a":        a,
                "b":        b,
        })
        logger.Debug("comparing two integers")

        if a &lt; b </span><span class="cov8" title="1">{
                logger.WithField("result", a).Debug("returning first value")
                return a
        }</span>
        <span class="cov8" title="1">logger.WithField("result", b).Debug("returning second value")
        return b</span>
}

// isStaticFileRequest determines if the request is for a static file
func isStaticFileRequest(path string) bool <span class="cov8" title="1">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "isStaticFileRequest",
                "path":     path,
        })
        logger.Debug("checking if path is static file")

        // Add common static file extensions
        staticExtensions := []string{
                ".html", ".css", ".js", ".jpg", ".jpeg",
                ".png", ".gif", ".svg", ".ico", ".woff",
                ".woff2", ".ttf", ".eot",
        }

        ext := filepath.Ext(path)
        for _, staticExt := range staticExtensions </span><span class="cov8" title="1">{
                if ext == staticExt </span><span class="cov8" title="1">{
                        logger.WithField("extension", ext).Info("serving static file")
                        return true
                }</span>
        }
        <span class="cov8" title="1">logger.Debug("path is not a static file")
        return false</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package server

import (
        "encoding/json"
        "net/http"
        "sync"
        "time"

        "github.com/gorilla/websocket"
        "github.com/sirupsen/logrus"
)

// upgrader is a websocket.Upgrader instance that handles WebSocket connection upgrades.
// It configures the following settings:
//   - ReadBufferSize: 1024 bytes for incoming WebSocket frames
//   - WriteBufferSize: 1024 bytes for outgoing WebSocket frames
//   - CheckOrigin: Allows all origins by always returning true (note: only suitable for development)
//
// Security Note: The current CheckOrigin setting allows any origin to establish WebSocket connections.
// This should be restricted in production environments to prevent cross-site WebSocket hijacking.
//
// Related Types:
//   - websocket.Upgrader (gorilla/websocket)
//   - http.Request
var upgrader = websocket.Upgrader{
        ReadBufferSize:  1024,
        WriteBufferSize: 1024,
        // Allow all origins for development
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                return true
        }</span>,
}

// wsConnection represents a WebSocket connection with thread-safe operations.
// It wraps the standard websocket.Conn with a mutex for concurrent access control.
//
// Fields:
//   - conn: The underlying WebSocket connection handler
//   - mu: Mutex to ensure thread-safe access to the connection
//
// Related types:
//   - websocket.Conn from "github.com/gorilla/websocket"
type wsConnection struct {
        conn *websocket.Conn
        mu   sync.Mutex
}

// RPCRequest represents a JSON-RPC 2.0 request
type RPCRequest struct {
        JsonRPC string                 `json:"jsonrpc"`
        Method  string                 `json:"method"`
        Params  map[string]interface{} `json:"params"`
        ID      interface{}            `json:"id"`
}

// NewResponse creates a new JSON-RPC 2.0 response
func NewResponse(id, result interface{}) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "jsonrpc": "2.0",
                "result":  result,
                "id":      id,
        }
}</span>

// NewErrorResponse creates a new JSON-RPC 2.0 error response
func NewErrorResponse(id interface{}, err error) interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "jsonrpc": "2.0",
                "error": map[string]interface{}{
                        "code":    -32000,
                        "message": err.Error(),
                },
                "id": id,
        }
}</span>

func (s *RPCServer) HandleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logger := logrus.WithField("function", "HandleWebSocket")
        session := r.Context().Value("session").(*PlayerSession)
        if session == nil </span><span class="cov0" title="0">{
                logrus.Error("no session in context")
                return
        }</span>

        <span class="cov0" title="0">conn, err := upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("websocket upgrade failed")
                return
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Send session confirmation
        if err := conn.WriteJSON(map[string]interface{}{
                "jsonrpc": "2.0",
                "result": map[string]string{
                        "session_id": session.SessionID,
                },
                "id": 0,
        }); err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("failed to send session confirmation")
                return
        }</span>

        <span class="cov0" title="0">session.WSConn = conn
        logrus.Info("websocket connection established")

        // Message handling loop
        for </span><span class="cov0" title="0">{
                var req RPCRequest
                if err := conn.ReadJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        break</span>
                }

                // Inject session ID into params
                <span class="cov0" title="0">if req.Params == nil </span><span class="cov0" title="0">{
                        req.Params = make(map[string]interface{})
                }</span>
                <span class="cov0" title="0">req.Params["session_id"] = session.SessionID

                // Convert string to RPCMethod type
                method := RPCMethod(req.Method)

                // Convert params to json.RawMessage
                paramsJSON, err := json.Marshal(req.Params)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to marshal params")
                        conn.WriteJSON(NewErrorResponse(req.ID, err))
                        continue</span>
                }

                <span class="cov0" title="0">result, err := s.handleMethod(method, paramsJSON)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("RPC method execution failed")
                        conn.WriteJSON(NewErrorResponse(req.ID, err))
                        continue</span>
                }

                <span class="cov0" title="0">if err := conn.WriteJSON(NewResponse(req.ID, result)); err != nil </span><span class="cov0" title="0">{
                        logger.WithError(err).Error("failed to write response")
                        break</span>
                }
        }
}

func (s *RPCServer) validateSession(params map[string]interface{}) (*PlayerSession, error) <span class="cov0" title="0">{
        sessionID, ok := params["session_id"].(string)
        if !ok || sessionID == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidSession
        }</span>

        <span class="cov0" title="0">s.mu.RLock()
        session, exists := s.sessions[sessionID]
        s.mu.RUnlock()

        if !exists || session.WSConn == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidSession
        }</span>

        <span class="cov0" title="0">session.LastActive = time.Now()
        return session, nil</span>
}

// sendWSResponse sends a JSON-RPC 2.0 response message over a WebSocket connection.
//
// Parameters:
//   - wsConn (*wsConnection): The WebSocket connection to send the response on. Must not be nil.
//   - result (interface{}): The result payload to include in the response. Can be any JSON-serializable value.
//   - id (interface{}): The request ID to correlate the response with the original request.
//
// The function constructs a JSON-RPC 2.0 compliant response object with:
//   - jsonrpc: Fixed to "2.0"
//   - result: The provided result value
//   - id: The provided request ID
//
// Thread safety is handled via the connection's mutex lock.
//
// Errors:
//   - Logs but does not return WebSocket write errors
//
// Related:
//   - wsConnection type (containing the WebSocket conn and mutex)
func (s *RPCServer) sendWSResponse(wsConn *wsConnection, result, id interface{}) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "sendWSResponse",
                "id":       id,
        })
        logger.Debug("sending websocket response")

        response := struct {
                JsonRPC string      `json:"jsonrpc"`
                Result  interface{} `json:"result"`
                ID      interface{} `json:"id"`
        }{
                JsonRPC: "2.0",
                Result:  result,
                ID:      id,
        }

        wsConn.mu.Lock()
        defer wsConn.mu.Unlock()

        if err := wsConn.conn.WriteJSON(response); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to write websocket response")
        }</span> else<span class="cov0" title="0"> {
                logger.Debug("websocket response sent successfully")
        }</span>
}

// sendWSError sends a JSON-RPC 2.0 error response over the WebSocket connection.
//
// Parameters:
//   - wsConn: The WebSocket connection wrapper to send the response on
//   - code: The JSON-RPC error code to include
//   - message: A human-readable error message describing the error
//   - data: Optional additional error details to include in response (may be nil)
//   - id: The JSON-RPC request ID the error is in response to
//
// The function constructs a proper JSON-RPC 2.0 error response object and sends it
// over the provided WebSocket connection. Thread safety is handled via mutex locking.
//
// Error handling:
// - If the write to WebSocket fails, error is logged but not returned to caller
//
// Related:
// - JSON-RPC 2.0 Spec: https://www.jsonrpc.org/specification#error_object
func (s *RPCServer) sendWSError(wsConn *wsConnection, code int, message string, data, id interface{}) <span class="cov0" title="0">{
        logger := logrus.WithFields(logrus.Fields{
                "function": "sendWSError",
                "id":       id,
                "code":     code,
        })
        logger.Debug("sending websocket error response")

        response := struct {
                JsonRPC string `json:"jsonrpc"`
                Error   struct {
                        Code    int         `json:"code"`
                        Message string      `json:"message"`
                        Data    interface{} `json:"data,omitempty"`
                } `json:"error"`
                ID interface{} `json:"id"`
        }{
                JsonRPC: "2.0",
                Error: struct {
                        Code    int         `json:"code"`
                        Message string      `json:"message"`
                        Data    interface{} `json:"data,omitempty"`
                }{
                        Code:    code,
                        Message: message,
                        Data:    data,
                },
                ID: id,
        }

        wsConn.mu.Lock()
        defer wsConn.mu.Unlock()

        if err := wsConn.conn.WriteJSON(response); err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("failed to write websocket error response")
        }</span> else<span class="cov0" title="0"> {
                logger.Debug("websocket error response sent successfully")
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
