
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>pcg: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">goldbox-rpg/pkg/pcg/manager.go (0.0%)</option>
				
				<option value="file1">goldbox-rpg/pkg/pcg/metrics.go (100.0%)</option>
				
				<option value="file2">goldbox-rpg/pkg/pcg/registry.go (0.0%)</option>
				
				<option value="file3">goldbox-rpg/pkg/pcg/seed.go (97.3%)</option>
				
				<option value="file4">goldbox-rpg/pkg/pcg/types.go (0.0%)</option>
				
				<option value="file5">goldbox-rpg/pkg/pcg/validation.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package pcg

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// PCGManager is the main coordinator for procedural content generation
// Integrates with existing game systems and manages the generation lifecycle
type PCGManager struct {
        registry    *Registry
        factory     *Factory
        validator   *Validator
        logger      *logrus.Logger
        world       *game.World
        seedManager *SeedManager
        metrics     *GenerationMetrics
}

// NewPCGManager creates a new PCG manager instance
func NewPCGManager(world *game.World, logger *logrus.Logger) *PCGManager <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = logrus.New()
        }</span>

        <span class="cov0" title="0">registry := NewRegistry(logger)
        factory := NewFactory(registry, logger)
        validator := NewValidator(false)
        seedManager := NewSeedManager(0) // Will be set by game initialization
        metrics := NewGenerationMetrics()

        return &amp;PCGManager{
                registry:    registry,
                factory:     factory,
                validator:   validator,
                logger:      logger,
                world:       world,
                seedManager: seedManager,
                metrics:     metrics,
        }</span>
}

// InitializeWithSeed sets the base seed for all generation
func (pcg *PCGManager) InitializeWithSeed(seed int64) <span class="cov0" title="0">{
        pcg.seedManager = NewSeedManager(seed)
        pcg.logger.WithField("seed", seed).Info("PCG manager initialized with seed")
}</span>

// RegisterDefaultGenerators registers the built-in generators
func (pcg *PCGManager) RegisterDefaultGenerators() error <span class="cov0" title="0">{
        pcg.logger.Info("Registering default PCG generators")

        // Note: Actual generators are registered by the server initialization
        // to avoid import cycles. This method serves as a placeholder for
        // future expansion and is called to ensure the system is ready.

        return nil
}</span>

// GenerateTerrainForLevel generates terrain for a specific game level
func (pcg *PCGManager) GenerateTerrainForLevel(ctx context.Context, levelID string, width, height int, biome BiomeType, difficulty int) (*game.GameMap, error) <span class="cov0" title="0">{
        startTime := time.Now()
        defer func() </span><span class="cov0" title="0">{
                duration := time.Since(startTime)
                pcg.metrics.RecordGeneration(ContentTypeTerrain, duration)
                pcg.logger.WithFields(logrus.Fields{
                        "content_type": ContentTypeTerrain,
                        "level_id":     levelID,
                        "duration":     duration,
                }).Debug("terrain generation completed")
        }</span>()

        <span class="cov0" title="0">params := TerrainParams{
                GenerationParams: GenerationParams{
                        Seed:        pcg.seedManager.DeriveContextSeed(ContentTypeTerrain, levelID),
                        Difficulty:  difficulty,
                        PlayerLevel: 1, // Could be derived from world state
                        WorldState:  pcg.world,
                        Timeout:     30 * time.Second,
                        Constraints: make(map[string]interface{}),
                },
                BiomeType:    biome,
                Density:      0.45,
                Connectivity: ConnectivityModerate,
                WaterLevel:   0.1,
                Roughness:    0.5,
        }

        // Add terrain-specific constraints
        params.Constraints["width"] = width
        params.Constraints["height"] = height
        params.Constraints["terrain_params"] = params

        gameMap, err := pcg.factory.GenerateTerrain(ctx, "cellular_automata", params)
        if err != nil </span><span class="cov0" title="0">{
                pcg.metrics.RecordError(ContentTypeTerrain)
        }</span>

        <span class="cov0" title="0">return gameMap, err</span>
}

// GenerateItemsForLocation generates items appropriate for a specific location
func (pcg *PCGManager) GenerateItemsForLocation(ctx context.Context, locationID string, itemCount int, minRarity, maxRarity RarityTier, playerLevel int) ([]*game.Item, error) <span class="cov0" title="0">{
        startTime := time.Now()
        defer func() </span><span class="cov0" title="0">{
                duration := time.Since(startTime)
                pcg.metrics.RecordGeneration(ContentTypeItems, duration)
                pcg.logger.WithFields(logrus.Fields{
                        "content_type": ContentTypeItems,
                        "location_id":  locationID,
                        "item_count":   itemCount,
                        "duration":     duration,
                }).Debug("item generation completed")
        }</span>()

        <span class="cov0" title="0">params := ItemParams{
                GenerationParams: GenerationParams{
                        Seed:        pcg.seedManager.DeriveContextSeed(ContentTypeItems, locationID),
                        Difficulty:  pcg.calculateLocationDifficulty(locationID),
                        PlayerLevel: playerLevel,
                        WorldState:  pcg.world,
                        Timeout:     10 * time.Second,
                        Constraints: make(map[string]interface{}),
                },
                MinRarity:       minRarity,
                MaxRarity:       maxRarity,
                EnchantmentRate: 0.2,
                UniqueChance:    0.05,
                LevelScaling:    true,
        }

        // Add item count constraint
        params.Constraints["item_count"] = itemCount

        items, err := pcg.factory.GenerateItems(ctx, "template_based", params)
        if err != nil </span><span class="cov0" title="0">{
                pcg.metrics.RecordError(ContentTypeItems)
        }</span>

        <span class="cov0" title="0">return items, err</span>
}

// GenerateDungeonLevel generates a complete dungeon level
func (pcg *PCGManager) GenerateDungeonLevel(ctx context.Context, levelID string, minRooms, maxRooms int, theme LevelTheme, difficulty int) (*game.Level, error) <span class="cov0" title="0">{
        params := LevelParams{
                GenerationParams: GenerationParams{
                        Seed:        pcg.seedManager.DeriveContextSeed(ContentTypeLevels, levelID),
                        Difficulty:  difficulty,
                        PlayerLevel: pcg.getAveragePartyLevel(),
                        WorldState:  pcg.world,
                        Timeout:     60 * time.Second,
                        Constraints: make(map[string]interface{}),
                },
                MinRooms:      minRooms,
                MaxRooms:      maxRooms,
                RoomTypes:     []RoomType{RoomTypeEntrance, RoomTypeExit, RoomTypeCombat, RoomTypeTreasure},
                CorridorStyle: CorridorWindy,
                LevelTheme:    theme,
                HasBoss:       difficulty &gt;= 10,
                SecretRooms:   maxRooms / 10,
        }

        return pcg.factory.GenerateLevel(ctx, "room_corridor", params)
}</span>

// GenerateQuestForArea generates a quest appropriate for a specific area
func (pcg *PCGManager) GenerateQuestForArea(ctx context.Context, areaID string, questType QuestType, playerLevel int) (*game.Quest, error) <span class="cov0" title="0">{
        params := QuestParams{
                GenerationParams: GenerationParams{
                        Seed:        pcg.seedManager.DeriveContextSeed(ContentTypeQuests, areaID),
                        Difficulty:  pcg.calculateAreaDifficulty(areaID),
                        PlayerLevel: playerLevel,
                        WorldState:  pcg.world,
                        Timeout:     15 * time.Second,
                        Constraints: make(map[string]interface{}),
                },
                QuestType:     questType,
                MinObjectives: 1,
                MaxObjectives: 3,
                RewardTier:    RarityRare,
                Narrative:     NarrativeLinear,
        }

        return pcg.factory.GenerateQuest(ctx, "objective_based", params)
}</span>

// ValidateGeneratedContent validates content before integration into the world
func (pcg *PCGManager) ValidateGeneratedContent(content interface{}) (*ValidationResult, error) <span class="cov0" title="0">{
        switch v := content.(type) </span>{
        case *game.GameMap:<span class="cov0" title="0">
                return pcg.validator.ValidateGameMap(v), nil</span>
        case *game.Item:<span class="cov0" title="0">
                return pcg.validator.ValidateItem(v), nil</span>
        case *game.Level:<span class="cov0" title="0">
                return pcg.validator.ValidateLevel(v), nil</span>
        case *game.Quest:<span class="cov0" title="0">
                return pcg.validator.ValidateQuest(v), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported content type for validation: %T", content)</span>
        }
}

// IntegrateContentIntoWorld integrates generated content into the game world
func (pcg *PCGManager) IntegrateContentIntoWorld(content interface{}, locationID string) error <span class="cov0" title="0">{
        // Validate content before integration
        validationResult, err := pcg.ValidateGeneratedContent(content)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if !validationResult.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("content validation failed: %v", validationResult.Errors)
        }</span>

        // Log warnings if present
        <span class="cov0" title="0">if validationResult.HasWarnings() </span><span class="cov0" title="0">{
                pcg.logger.WithFields(logrus.Fields{
                        "location": locationID,
                        "warnings": validationResult.Warnings,
                }).Warn("Generated content has validation warnings")
        }</span>

        // Integrate based on content type
        <span class="cov0" title="0">switch v := content.(type) </span>{
        case *game.Level:<span class="cov0" title="0">
                return pcg.integrateLevelIntoWorld(v, locationID)</span>
        case *game.Item:<span class="cov0" title="0">
                return pcg.integrateItemIntoWorld(v, locationID)</span>
        case []*game.Item:<span class="cov0" title="0">
                for _, item := range v </span><span class="cov0" title="0">{
                        if err := pcg.integrateItemIntoWorld(item, locationID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported content type for integration: %T", content)</span>
        }
}

// RegenerateContentForLocation regenerates content for a specific location
func (pcg *PCGManager) RegenerateContentForLocation(ctx context.Context, locationID string, contentType ContentType) (interface{}, error) <span class="cov0" title="0">{
        pcg.logger.WithFields(logrus.Fields{
                "location":     locationID,
                "content_type": contentType,
        }).Info("Regenerating content for location")

        // Get current world state for context
        difficulty := pcg.calculateLocationDifficulty(locationID)
        playerLevel := pcg.getAveragePartyLevel()

        switch contentType </span>{
        case ContentTypeTerrain:<span class="cov0" title="0">
                return pcg.GenerateTerrainForLevel(ctx, locationID, 50, 50, BiomeDungeon, difficulty)</span>
        case ContentTypeItems:<span class="cov0" title="0">
                return pcg.GenerateItemsForLocation(ctx, locationID, 3, RarityCommon, RarityRare, playerLevel)</span>
        case ContentTypeLevels:<span class="cov0" title="0">
                return pcg.GenerateDungeonLevel(ctx, locationID, 5, 15, ThemeClassic, difficulty)</span>
        case ContentTypeQuests:<span class="cov0" title="0">
                return pcg.GenerateQuestForArea(ctx, locationID, QuestTypeFetch, playerLevel)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported content type for regeneration: %s", contentType)</span>
        }
}

// GetGenerationStatistics returns statistics about generation activity
func (pcg *PCGManager) GetGenerationStatistics() map[string]interface{} <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Get available generators
        stats["available_generators"] = pcg.registry.ListAllGenerators()

        // Get seed information
        stats["base_seed"] = pcg.seedManager.GetBaseSeed()

        // Include generation metrics
        stats["performance_metrics"] = pcg.metrics.GetStats()

        return stats
}</span>

// GetRegistry returns the generator registry for external registration
func (pcg *PCGManager) GetRegistry() *Registry <span class="cov0" title="0">{
        return pcg.registry
}</span>

// GetMetrics returns the generation metrics instance
func (pcg *PCGManager) GetMetrics() *GenerationMetrics <span class="cov0" title="0">{
        return pcg.metrics
}</span>

// ResetMetrics clears all generation metrics
func (pcg *PCGManager) ResetMetrics() <span class="cov0" title="0">{
        pcg.metrics.Reset()
        pcg.logger.Info("PCG generation metrics reset")
}</span>

// Helper methods for integration

func (pcg *PCGManager) integrateLevelIntoWorld(level *game.Level, locationID string) error <span class="cov0" title="0">{
        // Add level to world - World should provide thread-safe methods for this
        // For now, we'll use a direct approach assuming World has proper synchronization
        pcg.world.Levels = append(pcg.world.Levels, *level)

        pcg.logger.WithFields(logrus.Fields{
                "level_id": level.ID,
                "location": locationID,
                "width":    level.Width,
                "height":   level.Height,
        }).Info("Integrated generated level into world")

        return nil
}</span>

func (pcg *PCGManager) integrateItemIntoWorld(item *game.Item, locationID string) error <span class="cov0" title="0">{
        // Add item to world objects - World should provide thread-safe methods for this
        if pcg.world.Objects == nil </span><span class="cov0" title="0">{
                pcg.world.Objects = make(map[string]game.GameObject)
        }</span>

        <span class="cov0" title="0">pcg.world.Objects[item.ID] = item

        // Update spatial index if available
        if pcg.world.SpatialIndex != nil </span><span class="cov0" title="0">{
                if err := pcg.world.SpatialIndex.Insert(item); err != nil </span><span class="cov0" title="0">{
                        pcg.logger.WithFields(logrus.Fields{
                                "item_id": item.ID,
                                "error":   err.Error(),
                        }).Warn("Failed to add item to spatial index")
                }</span>
        }

        <span class="cov0" title="0">pcg.logger.WithFields(logrus.Fields{
                "item_id":  item.ID,
                "location": locationID,
                "type":     item.Type,
                "value":    item.Value,
        }).Info("Integrated generated item into world")

        return nil</span>
}

// Helper methods for world state analysis

func (pcg *PCGManager) calculateLocationDifficulty(locationID string) int <span class="cov0" title="0">{
        // Analyze world state to determine appropriate difficulty
        // This would examine factors like:
        // - Player party levels
        // - Location depth/progression
        // - Existing challenges in the area
        // - World difficulty curve

        // Simplified implementation
        return 5 // Default moderate difficulty
}</span>

func (pcg *PCGManager) calculateAreaDifficulty(areaID string) int <span class="cov0" title="0">{
        // Similar to location difficulty but for larger areas
        return pcg.calculateLocationDifficulty(areaID)
}</span>

func (pcg *PCGManager) getAveragePartyLevel() int <span class="cov0" title="0">{
        if pcg.world == nil </span><span class="cov0" title="0">{
                return 1
        }</span>

        // Note: In a real implementation, World should provide thread-safe accessors
        <span class="cov0" title="0">if len(pcg.world.Players) == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov0" title="0">totalLevel := 0
        count := 0

        for _, player := range pcg.world.Players </span><span class="cov0" title="0">{
                // Note: Character is a struct, not a pointer, so we check Level directly
                if player.Character.Level &gt; 0 </span><span class="cov0" title="0">{
                        totalLevel += player.Character.Level
                        count++
                }</span>
        }

        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov0" title="0">return totalLevel / count</span>
}

// convertMapContent attempts to convert map[string]interface{} content to appropriate struct types
func (pcg *PCGManager) convertMapContent(content map[string]interface{}, contentType string) (interface{}, error) <span class="cov0" title="0">{
        // Convert map back to JSON, then unmarshal to the correct type
        jsonData, err := json.Marshal(content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal content: %w", err)
        }</span>

        <span class="cov0" title="0">switch contentType </span>{
        case "quests":<span class="cov0" title="0">
                var quest game.Quest
                if err := json.Unmarshal(jsonData, &amp;quest); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal quest content: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;quest, nil</span>
        case "items":<span class="cov0" title="0">
                var item game.Item
                if err := json.Unmarshal(jsonData, &amp;item); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal item content: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;item, nil</span>
        case "levels":<span class="cov0" title="0">
                var level game.Level
                if err := json.Unmarshal(jsonData, &amp;level); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal level content: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;level, nil</span>
        case "maps":<span class="cov0" title="0">
                var gameMap game.GameMap
                if err := json.Unmarshal(jsonData, &amp;gameMap); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal map content: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;gameMap, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported content type for conversion: %s", contentType)</span>
        }
}

// ValidateGeneratedContentWithType validates content with explicit type information
func (pcg *PCGManager) ValidateGeneratedContentWithType(content interface{}, contentType string) (*ValidationResult, error) <span class="cov0" title="0">{
        // Handle map[string]interface{} content by converting to proper types
        if mapContent, ok := content.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                convertedContent, err := pcg.convertMapContent(mapContent, contentType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert map content: %w", err)
                }</span>
                <span class="cov0" title="0">content = convertedContent</span>
        }

        <span class="cov0" title="0">return pcg.ValidateGeneratedContent(content)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package pcg

import (
        "sync"
        "time"
)

// GenerationMetrics tracks performance statistics
type GenerationMetrics struct {
        mu               sync.RWMutex
        GenerationCounts map[ContentType]int64         `json:"generation_counts"`
        AverageTimings   map[ContentType]time.Duration `json:"average_timings"`
        ErrorCounts      map[ContentType]int64         `json:"error_counts"`
        CacheHits        int64                         `json:"cache_hits"`
        CacheMisses      int64                         `json:"cache_misses"`
        TotalGenerations int64                         `json:"total_generations"`
}

// NewGenerationMetrics creates a new metrics tracker
func NewGenerationMetrics() *GenerationMetrics <span class="cov8" title="1">{
        return &amp;GenerationMetrics{
                GenerationCounts: make(map[ContentType]int64),
                AverageTimings:   make(map[ContentType]time.Duration),
                ErrorCounts:      make(map[ContentType]int64),
        }
}</span>

// RecordGeneration records a successful generation
func (gm *GenerationMetrics) RecordGeneration(contentType ContentType, duration time.Duration) <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.GenerationCounts[contentType]++
        gm.TotalGenerations++

        // Update rolling average
        if current, exists := gm.AverageTimings[contentType]; exists </span><span class="cov8" title="1">{
                count := gm.GenerationCounts[contentType]
                gm.AverageTimings[contentType] = (current*time.Duration(count-1) + duration) / time.Duration(count)
        }</span> else<span class="cov8" title="1"> {
                gm.AverageTimings[contentType] = duration
        }</span>
}

// RecordError records a generation error
func (gm *GenerationMetrics) RecordError(contentType ContentType) <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.ErrorCounts[contentType]++
}</span>

// RecordCacheHit records a cache hit
func (gm *GenerationMetrics) RecordCacheHit() <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.CacheHits++
}</span>

// RecordCacheMiss records a cache miss
func (gm *GenerationMetrics) RecordCacheMiss() <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.CacheMisses++
}</span>

// GetStats returns current performance statistics
func (gm *GenerationMetrics) GetStats() map[string]interface{} <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        return map[string]interface{}{
                "generation_counts": gm.GenerationCounts,
                "average_timings":   gm.AverageTimings,
                "error_counts":      gm.ErrorCounts,
                "cache_hits":        gm.CacheHits,
                "cache_misses":      gm.CacheMisses,
                "total_generations": gm.TotalGenerations,
        }
}</span>

// GetGenerationCount returns the total generation count for a content type
func (gm *GenerationMetrics) GetGenerationCount(contentType ContentType) int64 <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        return gm.GenerationCounts[contentType]
}</span>

// GetAverageTiming returns the average generation time for a content type
func (gm *GenerationMetrics) GetAverageTiming(contentType ContentType) time.Duration <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        return gm.AverageTimings[contentType]
}</span>

// GetErrorCount returns the total error count for a content type
func (gm *GenerationMetrics) GetErrorCount(contentType ContentType) int64 <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        return gm.ErrorCounts[contentType]
}</span>

// GetCacheHitRatio returns the cache hit ratio as a percentage
func (gm *GenerationMetrics) GetCacheHitRatio() float64 <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        total := gm.CacheHits + gm.CacheMisses
        if total == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        <span class="cov8" title="1">return float64(gm.CacheHits) / float64(total) * 100.0</span>
}

// Reset clears all metrics data
func (gm *GenerationMetrics) Reset() <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.GenerationCounts = make(map[ContentType]int64)
        gm.AverageTimings = make(map[ContentType]time.Duration)
        gm.ErrorCounts = make(map[ContentType]int64)
        gm.CacheHits = 0
        gm.CacheMisses = 0
        gm.TotalGenerations = 0
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package pcg

import (
        "context"
        "fmt"
        "sync"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// Registry manages all registered PCG generators and provides factory methods
// Thread-safe registry following the established locking patterns
type Registry struct {
        mu         sync.RWMutex
        generators map[ContentType]map[string]Generator
        logger     *logrus.Logger
}

// NewRegistry creates a new generator registry
func NewRegistry(logger *logrus.Logger) *Registry <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = logrus.New()
        }</span>

        <span class="cov0" title="0">return &amp;Registry{
                generators: make(map[ContentType]map[string]Generator),
                logger:     logger,
        }</span>
}

// RegisterGenerator registers a new generator with the registry
// Generator names must be unique within their content type
func (r *Registry) RegisterGenerator(name string, generator Generator) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        contentType := generator.GetType()

        // Initialize content type map if needed
        if r.generators[contentType] == nil </span><span class="cov0" title="0">{
                r.generators[contentType] = make(map[string]Generator)
        }</span>

        // Check for duplicate names
        <span class="cov0" title="0">if _, exists := r.generators[contentType][name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("generator '%s' already registered for content type '%s'", name, contentType)
        }</span>

        <span class="cov0" title="0">r.generators[contentType][name] = generator

        r.logger.WithFields(logrus.Fields{
                "generator":    name,
                "content_type": contentType,
                "version":      generator.GetVersion(),
        }).Info("Registered PCG generator")

        return nil</span>
}

// UnregisterGenerator removes a generator from the registry
func (r *Registry) UnregisterGenerator(contentType ContentType, name string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.generators[contentType] == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no generators registered for content type '%s'", contentType)
        }</span>

        <span class="cov0" title="0">if _, exists := r.generators[contentType][name]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("generator '%s' not found for content type '%s'", name, contentType)
        }</span>

        <span class="cov0" title="0">delete(r.generators[contentType], name)

        r.logger.WithFields(logrus.Fields{
                "generator":    name,
                "content_type": contentType,
        }).Info("Unregistered PCG generator")

        return nil</span>
}

// GetGenerator retrieves a specific generator by content type and name
func (r *Registry) GetGenerator(contentType ContentType, name string) (Generator, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        if r.generators[contentType] == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no generators registered for content type '%s'", contentType)
        }</span>

        <span class="cov0" title="0">generator, exists := r.generators[contentType][name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generator '%s' not found for content type '%s'", name, contentType)
        }</span>

        <span class="cov0" title="0">return generator, nil</span>
}

// ListGenerators returns all registered generators for a content type
func (r *Registry) ListGenerators(contentType ContentType) []string <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        if r.generators[contentType] == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov0" title="0">names := make([]string, 0, len(r.generators[contentType]))
        for name := range r.generators[contentType] </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>

        <span class="cov0" title="0">return names</span>
}

// ListAllGenerators returns all registered generators grouped by content type
func (r *Registry) ListAllGenerators() map[ContentType][]string <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        result := make(map[ContentType][]string)
        for contentType, generators := range r.generators </span><span class="cov0" title="0">{
                names := make([]string, 0, len(generators))
                for name := range generators </span><span class="cov0" title="0">{
                        names = append(names, name)
                }</span>
                <span class="cov0" title="0">result[contentType] = names</span>
        }

        <span class="cov0" title="0">return result</span>
}

// GenerateContent creates content using the specified generator
func (r *Registry) GenerateContent(ctx context.Context, contentType ContentType, generatorName string, params GenerationParams) (interface{}, error) <span class="cov0" title="0">{
        generator, err := r.GetGenerator(contentType, generatorName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate parameters before generation
        <span class="cov0" title="0">if err := generator.Validate(params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parameter validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.WithFields(logrus.Fields{
                "generator":    generatorName,
                "content_type": contentType,
                "seed":         params.Seed,
                "difficulty":   params.Difficulty,
        }).Info("Starting content generation")

        // Generate content with timeout handling
        resultChan := make(chan interface{}, 1)
        errorChan := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                result, err := generator.Generate(ctx, params)
                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>
                <span class="cov0" title="0">resultChan &lt;- result</span>
        }()

        <span class="cov0" title="0">select </span>{
        case result := &lt;-resultChan:<span class="cov0" title="0">
                r.logger.WithFields(logrus.Fields{
                        "generator":    generatorName,
                        "content_type": contentType,
                }).Info("Content generation completed successfully")
                return result, nil</span>

        case err := &lt;-errorChan:<span class="cov0" title="0">
                r.logger.WithFields(logrus.Fields{
                        "generator":    generatorName,
                        "content_type": contentType,
                        "error":        err.Error(),
                }).Error("Content generation failed")
                return nil, err</span>

        case &lt;-ctx.Done():<span class="cov0" title="0">
                r.logger.WithFields(logrus.Fields{
                        "generator":    generatorName,
                        "content_type": contentType,
                }).Warn("Content generation cancelled or timed out")
                return nil, ctx.Err()</span>
        }
}

// Factory provides convenient factory methods for content generation
type Factory struct {
        registry *Registry
        logger   *logrus.Logger
}

// NewFactory creates a new factory instance
func NewFactory(registry *Registry, logger *logrus.Logger) *Factory <span class="cov0" title="0">{
        return &amp;Factory{
                registry: registry,
                logger:   logger,
        }
}</span>

// GenerateTerrain generates terrain using the specified generator
func (f *Factory) GenerateTerrain(ctx context.Context, generatorName string, params TerrainParams) (*game.GameMap, error) <span class="cov0" title="0">{
        result, err := f.registry.GenerateContent(ctx, ContentTypeTerrain, generatorName, params.GenerationParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">gameMap, ok := result.(*game.GameMap)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("terrain generator returned unexpected type: %T", result)
        }</span>

        <span class="cov0" title="0">return gameMap, nil</span>
}

// GenerateItems generates items using the specified generator
func (f *Factory) GenerateItems(ctx context.Context, generatorName string, params ItemParams) ([]*game.Item, error) <span class="cov0" title="0">{
        result, err := f.registry.GenerateContent(ctx, ContentTypeItems, generatorName, params.GenerationParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Handle both single items and item arrays
        <span class="cov0" title="0">switch v := result.(type) </span>{
        case *game.Item:<span class="cov0" title="0">
                return []*game.Item{v}, nil</span>
        case []*game.Item:<span class="cov0" title="0">
                return v, nil</span>
        case []game.Item:<span class="cov0" title="0">
                items := make([]*game.Item, len(v))
                for i := range v </span><span class="cov0" title="0">{
                        items[i] = &amp;v[i]
                }</span>
                <span class="cov0" title="0">return items, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("item generator returned unexpected type: %T", result)</span>
        }
}

// GenerateLevel generates a level using the specified generator
func (f *Factory) GenerateLevel(ctx context.Context, generatorName string, params LevelParams) (*game.Level, error) <span class="cov0" title="0">{
        result, err := f.registry.GenerateContent(ctx, ContentTypeLevels, generatorName, params.GenerationParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">level, ok := result.(*game.Level)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("level generator returned unexpected type: %T", result)
        }</span>

        <span class="cov0" title="0">return level, nil</span>
}

// GenerateQuest generates a quest using the specified generator
func (f *Factory) GenerateQuest(ctx context.Context, generatorName string, params QuestParams) (*game.Quest, error) <span class="cov0" title="0">{
        result, err := f.registry.GenerateContent(ctx, ContentTypeQuests, generatorName, params.GenerationParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">quest, ok := result.(*game.Quest)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("quest generator returned unexpected type: %T", result)
        }</span>

        <span class="cov0" title="0">return quest, nil</span>
}

// GetDefaultRegistry returns a registry with default generators registered
func GetDefaultRegistry(logger *logrus.Logger) *Registry <span class="cov0" title="0">{
        registry := NewRegistry(logger)

        // Register default generators (these would be implemented in their respective packages)
        // This demonstrates the registration pattern

        return registry
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package pcg

import (
        "crypto/sha256"
        "encoding/binary"
        "fmt"
        "math/rand"
        "time"
)

// SeedManager provides deterministic seeding for reproducible content generation
// Follows the established deterministic patterns in the existing dice system
type SeedManager struct {
        baseSeed     int64
        contextSeeds map[string]int64
}

// NewSeedManager creates a new seed manager with a base seed
func NewSeedManager(baseSeed int64) *SeedManager <span class="cov8" title="1">{
        if baseSeed == 0 </span><span class="cov8" title="1">{
                baseSeed = time.Now().UnixNano()
        }</span>

        <span class="cov8" title="1">return &amp;SeedManager{
                baseSeed:     baseSeed,
                contextSeeds: make(map[string]int64),
        }</span>
}

// GetBaseSeed returns the base seed used for all generation
func (sm *SeedManager) GetBaseSeed() int64 <span class="cov8" title="1">{
        return sm.baseSeed
}</span>

// DeriveContextSeed creates a deterministic seed for a specific context
// This ensures that the same content type/name combination always produces
// the same seed, enabling reproducible generation across sessions
func (sm *SeedManager) DeriveContextSeed(contentType ContentType, name string) int64 <span class="cov8" title="1">{
        context := fmt.Sprintf("%s:%s", contentType, name)

        if seed, exists := sm.contextSeeds[context]; exists </span><span class="cov8" title="1">{
                return seed
        }</span>

        // Create deterministic seed by hashing base seed + context
        <span class="cov8" title="1">hasher := sha256.New()
        hasher.Write([]byte(fmt.Sprintf("%d:%s", sm.baseSeed, context)))
        hash := hasher.Sum(nil)

        // Convert first 8 bytes of hash to int64
        seed := int64(binary.BigEndian.Uint64(hash[:8]))

        sm.contextSeeds[context] = seed
        return seed</span>
}

// DeriveParameterSeed creates a seed based on generation parameters
// This allows for controlled variation within the same generator context
func (sm *SeedManager) DeriveParameterSeed(baseSeed int64, params GenerationParams) int64 <span class="cov8" title="1">{
        hasher := sha256.New()

        // Include critical parameters that should affect generation
        paramString := fmt.Sprintf("%d:%d:%d",
                baseSeed,
                params.Difficulty,
                params.PlayerLevel)

        // Include any additional constraints that should affect seeding
        for key, value := range params.Constraints </span><span class="cov0" title="0">{
                paramString += fmt.Sprintf(":%s=%v", key, value)
        }</span>

        <span class="cov8" title="1">hasher.Write([]byte(paramString))
        hash := hasher.Sum(nil)

        return int64(binary.BigEndian.Uint64(hash[:8]))</span>
}

// CreateRNG creates a new random number generator with the derived seed
// This provides the same pattern as the existing DiceRoller system
func (sm *SeedManager) CreateRNG(contentType ContentType, name string, params GenerationParams) *rand.Rand <span class="cov8" title="1">{
        contextSeed := sm.DeriveContextSeed(contentType, name)
        finalSeed := sm.DeriveParameterSeed(contextSeed, params)

        return rand.New(rand.NewSource(finalSeed))
}</span>

// CreateSubRNG creates a child RNG for a specific generation phase
// This allows deterministic sub-generation within a larger generation process
func (sm *SeedManager) CreateSubRNG(parentRNG *rand.Rand, phase string) *rand.Rand <span class="cov8" title="1">{
        // Use the parent RNG to get a deterministic seed for the sub-phase
        subSeed := parentRNG.Int63()

        // Hash the phase name with the sub-seed for determinism
        hasher := sha256.New()
        hasher.Write([]byte(fmt.Sprintf("%d:%s", subSeed, phase)))
        hash := hasher.Sum(nil)

        finalSeed := int64(binary.BigEndian.Uint64(hash[:8]))
        return rand.New(rand.NewSource(finalSeed))
}</span>

// SaveableState represents the state that can be saved/loaded for reproducibility
type SaveableState struct {
        BaseSeed     int64            `yaml:"base_seed"`
        ContextSeeds map[string]int64 `yaml:"context_seeds"`
}

// GetSaveableState returns the current state for persistence
func (sm *SeedManager) GetSaveableState() SaveableState <span class="cov8" title="1">{
        return SaveableState{
                BaseSeed:     sm.baseSeed,
                ContextSeeds: sm.contextSeeds,
        }
}</span>

// LoadState restores the seed manager from saved state
func (sm *SeedManager) LoadState(state SaveableState) <span class="cov8" title="1">{
        sm.baseSeed = state.BaseSeed
        sm.contextSeeds = make(map[string]int64)

        for context, seed := range state.ContextSeeds </span><span class="cov8" title="1">{
                sm.contextSeeds[context] = seed
        }</span>
}

// GenerationContext provides context and seeded RNG for generators
type GenerationContext struct {
        RNG     *rand.Rand
        Seed    int64
        Phase   string
        SeedMgr *SeedManager
        SubRNGs map[string]*rand.Rand
}

// NewGenerationContext creates a new generation context
func NewGenerationContext(seedMgr *SeedManager, contentType ContentType, name string, params GenerationParams) *GenerationContext <span class="cov8" title="1">{
        rng := seedMgr.CreateRNG(contentType, name, params)

        return &amp;GenerationContext{
                RNG:     rng,
                Seed:    seedMgr.DeriveContextSeed(contentType, name),
                Phase:   "main",
                SeedMgr: seedMgr,
                SubRNGs: make(map[string]*rand.Rand),
        }
}</span>

// GetSubRNG returns a deterministic sub-RNG for the specified phase
func (gc *GenerationContext) GetSubRNG(phase string) *rand.Rand <span class="cov8" title="1">{
        if subRNG, exists := gc.SubRNGs[phase]; exists </span><span class="cov8" title="1">{
                return subRNG
        }</span>

        <span class="cov8" title="1">subRNG := gc.SeedMgr.CreateSubRNG(gc.RNG, phase)
        gc.SubRNGs[phase] = subRNG
        return subRNG</span>
}

// RollDice provides dice rolling functionality using the context's RNG
// This integrates with the existing dice system patterns
func (gc *GenerationContext) RollDice(sides int) int <span class="cov8" title="1">{
        if sides &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return gc.RNG.Intn(sides) + 1</span>
}

// RollMultipleDice rolls multiple dice and returns individual results
func (gc *GenerationContext) RollMultipleDice(count, sides int) []int <span class="cov8" title="1">{
        results := make([]int, count)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                results[i] = gc.RollDice(sides)
        }</span>
        <span class="cov8" title="1">return results</span>
}

// RollDiceSum rolls multiple dice and returns the sum
func (gc *GenerationContext) RollDiceSum(count, sides int) int <span class="cov8" title="1">{
        total := 0
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                total += gc.RollDice(sides)
        }</span>
        <span class="cov8" title="1">return total</span>
}

// RandomChoice selects a random element from a slice
func (gc *GenerationContext) RandomChoice(choices []string) string <span class="cov8" title="1">{
        if len(choices) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return choices[gc.RNG.Intn(len(choices))]</span>
}

// RandomFloat returns a random float64 between 0.0 and 1.0
func (gc *GenerationContext) RandomFloat() float64 <span class="cov8" title="1">{
        return gc.RNG.Float64()
}</span>

// RandomFloatRange returns a random float64 between min and max
func (gc *GenerationContext) RandomFloatRange(min, max float64) float64 <span class="cov8" title="1">{
        return min + gc.RNG.Float64()*(max-min)
}</span>

// RandomIntRange returns a random int between min and max (inclusive)
func (gc *GenerationContext) RandomIntRange(min, max int) int <span class="cov8" title="1">{
        if min &gt;= max </span><span class="cov8" title="1">{
                return min
        }</span>
        <span class="cov8" title="1">return min + gc.RNG.Intn(max-min+1)</span>
}

// WeightedChoice selects from choices based on weights
func (gc *GenerationContext) WeightedChoice(choices []string, weights []float64) string <span class="cov8" title="1">{
        if len(choices) == 0 || len(choices) != len(weights) </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Calculate total weight
        <span class="cov8" title="1">totalWeight := 0.0
        for _, weight := range weights </span><span class="cov8" title="1">{
                totalWeight += weight
        }</span>

        <span class="cov8" title="1">if totalWeight &lt;= 0 </span><span class="cov8" title="1">{
                return gc.RandomChoice(choices)
        }</span>

        // Random value between 0 and total weight
        <span class="cov8" title="1">randomValue := gc.RNG.Float64() * totalWeight

        // Find the selected choice
        currentWeight := 0.0
        for i, weight := range weights </span><span class="cov8" title="1">{
                currentWeight += weight
                if randomValue &lt;= currentWeight </span><span class="cov8" title="1">{
                        return choices[i]
                }</span>
        }

        // Fallback to last choice
        <span class="cov0" title="0">return choices[len(choices)-1]</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package pcg

import "goldbox-rpg/pkg/game"

// BiomeType represents different terrain biomes for generation
type BiomeType string

const (
        BiomeForest    BiomeType = "forest"
        BiomeMountain  BiomeType = "mountain"
        BiomeDesert    BiomeType = "desert"
        BiomeSwamp     BiomeType = "swamp"
        BiomeCave      BiomeType = "cave"
        BiomeDungeon   BiomeType = "dungeon"
        BiomeCoastal   BiomeType = "coastal"
        BiomeUrban     BiomeType = "urban"
        BiomeWasteland BiomeType = "wasteland"
)

// RarityTier represents item rarity levels
type RarityTier string

const (
        RarityCommon    RarityTier = "common"
        RarityUncommon  RarityTier = "uncommon"
        RarityRare      RarityTier = "rare"
        RarityEpic      RarityTier = "epic"
        RarityLegendary RarityTier = "legendary"
        RarityArtifact  RarityTier = "artifact"
)

// RoomType represents different types of rooms in generated levels
type RoomType string

const (
        RoomTypeEntrance RoomType = "entrance"
        RoomTypeExit     RoomType = "exit"
        RoomTypeCombat   RoomType = "combat"
        RoomTypeTreasure RoomType = "treasure"
        RoomTypePuzzle   RoomType = "puzzle"
        RoomTypeBoss     RoomType = "boss"
        RoomTypeSecret   RoomType = "secret"
        RoomTypeShop     RoomType = "shop"
        RoomTypeRest     RoomType = "rest"
        RoomTypeTrap     RoomType = "trap"
        RoomTypeStory    RoomType = "story"
)

// CorridorStyle represents different corridor generation approaches
type CorridorStyle string

const (
        CorridorStraight CorridorStyle = "straight"
        CorridorWindy    CorridorStyle = "windy"
        CorridorMaze     CorridorStyle = "maze"
        CorridorOrganic  CorridorStyle = "organic"
        CorridorMinimal  CorridorStyle = "minimal"
)

// LevelTheme represents thematic constraints for level generation
type LevelTheme string

const (
        ThemeClassic    LevelTheme = "classic"
        ThemeHorror     LevelTheme = "horror"
        ThemeNatural    LevelTheme = "natural"
        ThemeMechanical LevelTheme = "mechanical"
        ThemeMagical    LevelTheme = "magical"
        ThemeUndead     LevelTheme = "undead"
        ThemeElemental  LevelTheme = "elemental"
)

// QuestType represents different categories of quests
type QuestType string

const (
        QuestTypeFetch    QuestType = "fetch"
        QuestTypeKill     QuestType = "kill"
        QuestTypeEscort   QuestType = "escort"
        QuestTypeExplore  QuestType = "explore"
        QuestTypeDefend   QuestType = "defend"
        QuestTypePuzzle   QuestType = "puzzle"
        QuestTypeDelivery QuestType = "delivery"
        QuestTypeSurvival QuestType = "survival"
        QuestTypeStory    QuestType = "story"
)

// NarrativeType represents different story generation styles
type NarrativeType string

const (
        NarrativeLinear    NarrativeType = "linear"
        NarrativeBranching NarrativeType = "branching"
        NarrativeOpen      NarrativeType = "open"
        NarrativeEpisodic  NarrativeType = "episodic"
)

// ConnectivityLevel represents how connected terrain features should be
type ConnectivityLevel string

const (
        ConnectivityNone     ConnectivityLevel = "none"
        ConnectivityLow      ConnectivityLevel = "low"
        ConnectivityMinimal  ConnectivityLevel = "minimal"
        ConnectivityModerate ConnectivityLevel = "moderate"
        ConnectivityHigh     ConnectivityLevel = "high"
        ConnectivityComplete ConnectivityLevel = "complete"
)

// TerrainFeature represents special features that can be included in terrain
type TerrainFeature string

const (
        FeatureWater            TerrainFeature = "water"
        FeatureMountain         TerrainFeature = "mountain"
        FeatureForest           TerrainFeature = "forest"
        FeatureCave             TerrainFeature = "cave"
        FeatureRuins            TerrainFeature = "ruins"
        FeatureRoad             TerrainFeature = "road"
        FeatureBridge           TerrainFeature = "bridge"
        FeatureTown             TerrainFeature = "town"
        FeatureShrine           TerrainFeature = "shrine"
        FeatureStalactites      TerrainFeature = "stalactites"
        FeatureUndergroundRiver TerrainFeature = "underground_river"
        FeatureSecretDoors      TerrainFeature = "secret_doors"
        FeatureTraps            TerrainFeature = "traps"
        FeatureTrees            TerrainFeature = "trees"
        FeatureStreams          TerrainFeature = "streams"
        FeatureCliffs           TerrainFeature = "cliffs"
        FeatureCrevasses        TerrainFeature = "crevasses"
        FeatureBogs             TerrainFeature = "bogs"
        FeatureVines            TerrainFeature = "vines"
        FeatureDunes            TerrainFeature = "dunes"
        FeatureOasis            TerrainFeature = "oasis"
)

// ItemSetType represents collections of related items
type ItemSetType string

const (
        ItemSetArmor    ItemSetType = "armor"
        ItemSetWeapons  ItemSetType = "weapons"
        ItemSetJewelry  ItemSetType = "jewelry"
        ItemSetTools    ItemSetType = "tools"
        ItemSetConsumab ItemSetType = "consumables"
        ItemSetMagical  ItemSetType = "magical"
        ItemSetCrafting ItemSetType = "crafting"
)

// Rectangle represents a rectangular area for spatial operations
type Rectangle struct {
        X, Y          int // Top-left corner coordinates
        Width, Height int // Dimensions
}

// Contains checks if a position is within the rectangle
func (r Rectangle) Contains(x, y int) bool <span class="cov0" title="0">{
        return x &gt;= r.X &amp;&amp; x &lt; r.X+r.Width &amp;&amp; y &gt;= r.Y &amp;&amp; y &lt; r.Y+r.Height
}</span>

// Intersects checks if this rectangle intersects with another
func (r Rectangle) Intersects(other Rectangle) bool <span class="cov0" title="0">{
        return r.X &lt; other.X+other.Width &amp;&amp;
                r.X+r.Width &gt; other.X &amp;&amp;
                r.Y &lt; other.Y+other.Height &amp;&amp;
                r.Y+r.Height &gt; other.Y
}</span>

// RoomLayout represents the layout of a generated room
type RoomLayout struct {
        ID         string                 `yaml:"id"`         // Unique room identifier
        Type       RoomType               `yaml:"type"`       // Room type classification
        Bounds     Rectangle              `yaml:"bounds"`     // Room dimensions and position
        Tiles      [][]game.Tile          `yaml:"tiles"`      // Room tile data
        Doors      []game.Position        `yaml:"doors"`      // Door/entrance positions
        Features   []RoomFeature          `yaml:"features"`   // Special room features
        Difficulty int                    `yaml:"difficulty"` // Challenge rating
        Properties map[string]interface{} `yaml:"properties"` // Additional room data
        Connected  []string               `yaml:"connected"`  // IDs of connected rooms
}

// Corridor represents a connection between rooms
type Corridor struct {
        ID       string            `yaml:"id"`       // Unique corridor identifier
        Start    game.Position     `yaml:"start"`    // Starting position
        End      game.Position     `yaml:"end"`      // Ending position
        Path     []game.Position   `yaml:"path"`     // Corridor path tiles
        Width    int               `yaml:"width"`    // Corridor width
        Style    CorridorStyle     `yaml:"style"`    // Generation style used
        Features []CorridorFeature `yaml:"features"` // Special corridor features
}

// RoomFeature represents special features within rooms
type RoomFeature struct {
        Type       string                 `yaml:"type"`       // Feature type (chest, altar, etc.)
        Position   game.Position          `yaml:"position"`   // Location within room
        Properties map[string]interface{} `yaml:"properties"` // Feature-specific data
}

// CorridorFeature represents special features within corridors
type CorridorFeature struct {
        Type       string                 `yaml:"type"`       // Feature type (trap, secret door, etc.)
        Position   game.Position          `yaml:"position"`   // Location within corridor
        Properties map[string]interface{} `yaml:"properties"` // Feature-specific data
}

// ItemTemplate represents a template for procedural item generation
type ItemTemplate struct {
        BaseType   string                `yaml:"base_type"`   // Base item type (sword, armor, etc.)
        NameParts  []string              `yaml:"name_parts"`  // Name generation components
        StatRanges map[string]StatRange  `yaml:"stat_ranges"` // Stat generation ranges
        Properties []string              `yaml:"properties"`  // Possible item properties
        Enchants   []EnchantmentTemplate `yaml:"enchants"`    // Available enchantments
        Materials  []string              `yaml:"materials"`   // Possible materials
        Rarities   []RarityTier          `yaml:"rarities"`    // Applicable rarity tiers
}

// StatRange represents a range for procedural stat generation
type StatRange struct {
        Min     int     `yaml:"min"`     // Minimum value
        Max     int     `yaml:"max"`     // Maximum value
        Scaling float64 `yaml:"scaling"` // Level scaling factor
}

// EnchantmentTemplate represents a template for procedural enchantments
type EnchantmentTemplate struct {
        Name         string                 `yaml:"name"`         // Enchantment name
        Type         string                 `yaml:"type"`         // Enchantment type
        MinLevel     int                    `yaml:"min_level"`    // Minimum required level
        MaxLevel     int                    `yaml:"max_level"`    // Maximum applicable level
        Effects      []game.Effect          `yaml:"effects"`      // Enchantment effects
        Restrictions map[string]interface{} `yaml:"restrictions"` // Usage restrictions
}

// QuestObjective represents a single quest objective
type QuestObjective struct {
        ID          string                 `yaml:"id"`          // Unique objective ID
        Type        string                 `yaml:"type"`        // Objective type
        Description string                 `yaml:"description"` // Human-readable description
        Target      string                 `yaml:"target"`      // Target entity/location
        Quantity    int                    `yaml:"quantity"`    // Required quantity
        Progress    int                    `yaml:"progress"`    // Current progress
        Complete    bool                   `yaml:"complete"`    // Completion status
        Optional    bool                   `yaml:"optional"`    // Whether objective is optional
        Conditions  map[string]interface{} `yaml:"conditions"`  // Completion conditions
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package pcg

import (
        "fmt"
        "strings"

        "goldbox-rpg/pkg/game"
)

// ValidationResult represents the result of content validation
type ValidationResult struct {
        Valid    bool     `yaml:"valid"`
        Errors   []string `yaml:"errors"`
        Warnings []string `yaml:"warnings"`
}

// IsValid returns true if validation passed without errors
func (vr *ValidationResult) IsValid() bool <span class="cov0" title="0">{
        return vr.Valid &amp;&amp; len(vr.Errors) == 0
}</span>

// HasWarnings returns true if there are validation warnings
func (vr *ValidationResult) HasWarnings() bool <span class="cov0" title="0">{
        return len(vr.Warnings) &gt; 0
}</span>

// AddError adds an error to the validation result
func (vr *ValidationResult) AddError(message string) <span class="cov0" title="0">{
        vr.Errors = append(vr.Errors, message)
        vr.Valid = false
}</span>

// AddWarning adds a warning to the validation result
func (vr *ValidationResult) AddWarning(message string) <span class="cov0" title="0">{
        vr.Warnings = append(vr.Warnings, message)
}</span>

// Merge combines another validation result into this one
func (vr *ValidationResult) Merge(other *ValidationResult) <span class="cov0" title="0">{
        vr.Errors = append(vr.Errors, other.Errors...)
        vr.Warnings = append(vr.Warnings, other.Warnings...)
        if !other.Valid </span><span class="cov0" title="0">{
                vr.Valid = false
        }</span>
}

// Validator provides validation for generated content
type Validator struct {
        strictMode bool
}

// NewValidator creates a new content validator
func NewValidator(strictMode bool) *Validator <span class="cov0" title="0">{
        return &amp;Validator{
                strictMode: strictMode,
        }
}</span>

// ValidateGenerationParams validates common generation parameters
func (v *Validator) ValidateGenerationParams(params GenerationParams) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        // Validate seed (any int64 value is acceptable)

        // Validate difficulty range
        if params.Difficulty &lt; 1 || params.Difficulty &gt; 20 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("difficulty must be between 1 and 20, got %d", params.Difficulty))
        }</span>

        // Validate player level
        <span class="cov0" title="0">if params.PlayerLevel &lt; 1 || params.PlayerLevel &gt; 20 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("player level must be between 1 and 20, got %d", params.PlayerLevel))
        }</span>

        // Validate timeout
        <span class="cov0" title="0">if params.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                result.AddWarning("timeout not specified or invalid, generation may run indefinitely")
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateTerrainParams validates terrain-specific parameters
func (v *Validator) ValidateTerrainParams(params TerrainParams) *ValidationResult <span class="cov0" title="0">{
        result := v.ValidateGenerationParams(params.GenerationParams)

        // Validate biome type
        validBiomes := []BiomeType{
                BiomeForest, BiomeMountain, BiomeDesert, BiomeSwamp,
                BiomeCave, BiomeDungeon, BiomeCoastal, BiomeUrban, BiomeWasteland,
        }

        valid := false
        for _, validBiome := range validBiomes </span><span class="cov0" title="0">{
                if params.BiomeType == validBiome </span><span class="cov0" title="0">{
                        valid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid biome type: %s", params.BiomeType))
        }</span>

        // Validate density
        <span class="cov0" title="0">if params.Density &lt; 0.0 || params.Density &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("density must be between 0.0 and 1.0, got %f", params.Density))
        }</span>

        // Validate water level
        <span class="cov0" title="0">if params.WaterLevel &lt; 0.0 || params.WaterLevel &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("water level must be between 0.0 and 1.0, got %f", params.WaterLevel))
        }</span>

        // Validate roughness
        <span class="cov0" title="0">if params.Roughness &lt; 0.0 || params.Roughness &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("roughness must be between 0.0 and 1.0, got %f", params.Roughness))
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateItemParams validates item-specific parameters
func (v *Validator) ValidateItemParams(params ItemParams) *ValidationResult <span class="cov0" title="0">{
        result := v.ValidateGenerationParams(params.GenerationParams)

        // Validate rarity tiers
        validRarities := []RarityTier{
                RarityCommon, RarityUncommon, RarityRare,
                RarityEpic, RarityLegendary, RarityArtifact,
        }

        // Check minimum rarity
        minValid := false
        for _, validRarity := range validRarities </span><span class="cov0" title="0">{
                if params.MinRarity == validRarity </span><span class="cov0" title="0">{
                        minValid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !minValid </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid minimum rarity: %s", params.MinRarity))
        }</span>

        // Check maximum rarity
        <span class="cov0" title="0">maxValid := false
        for _, validRarity := range validRarities </span><span class="cov0" title="0">{
                if params.MaxRarity == validRarity </span><span class="cov0" title="0">{
                        maxValid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !maxValid </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid maximum rarity: %s", params.MaxRarity))
        }</span>

        // Validate enchantment rate
        <span class="cov0" title="0">if params.EnchantmentRate &lt; 0.0 || params.EnchantmentRate &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("enchantment rate must be between 0.0 and 1.0, got %f", params.EnchantmentRate))
        }</span>

        // Validate unique chance
        <span class="cov0" title="0">if params.UniqueChance &lt; 0.0 || params.UniqueChance &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("unique chance must be between 0.0 and 1.0, got %f", params.UniqueChance))
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateLevelParams validates level-specific parameters
func (v *Validator) ValidateLevelParams(params LevelParams) *ValidationResult <span class="cov0" title="0">{
        result := v.ValidateGenerationParams(params.GenerationParams)

        // Validate room counts
        if params.MinRooms &lt; 1 </span><span class="cov0" title="0">{
                result.AddError("minimum rooms must be at least 1")
        }</span>

        <span class="cov0" title="0">if params.MaxRooms &lt; params.MinRooms </span><span class="cov0" title="0">{
                result.AddError("maximum rooms must be greater than or equal to minimum rooms")
        }</span>

        <span class="cov0" title="0">if params.MaxRooms &gt; 100 </span><span class="cov0" title="0">{
                result.AddWarning("maximum rooms is very high, generation may be slow")
        }</span>

        // Validate secret rooms
        <span class="cov0" title="0">if params.SecretRooms &lt; 0 </span><span class="cov0" title="0">{
                result.AddError("secret rooms cannot be negative")
        }</span>

        <span class="cov0" title="0">if params.SecretRooms &gt; params.MaxRooms/2 </span><span class="cov0" title="0">{
                result.AddWarning("high number of secret rooms relative to total rooms")
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateGameMap validates a generated game map
func (v *Validator) ValidateGameMap(gameMap *game.GameMap) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        if gameMap == nil </span><span class="cov0" title="0">{
                result.AddError("game map is nil")
                return result
        }</span>

        // Validate dimensions
        <span class="cov0" title="0">if gameMap.Width &lt;= 0 || gameMap.Height &lt;= 0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid map dimensions: %dx%d", gameMap.Width, gameMap.Height))
        }</span>

        // Validate tiles array
        <span class="cov0" title="0">if len(gameMap.Tiles) != gameMap.Height </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("tiles array height mismatch: expected %d, got %d", gameMap.Height, len(gameMap.Tiles)))
        }</span>

        <span class="cov0" title="0">for y, row := range gameMap.Tiles </span><span class="cov0" title="0">{
                if len(row) != gameMap.Width </span><span class="cov0" title="0">{
                        result.AddError(fmt.Sprintf("tiles array width mismatch at row %d: expected %d, got %d", y, gameMap.Width, len(row)))
                }</span>
        }

        // Check for walkable path connectivity if in strict mode
        <span class="cov0" title="0">if v.strictMode </span><span class="cov0" title="0">{
                if !v.validateMapConnectivity(gameMap) </span><span class="cov0" title="0">{
                        result.AddError("map lacks proper connectivity between walkable areas")
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ValidateItem validates a generated item
func (v *Validator) ValidateItem(item *game.Item) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        if item == nil </span><span class="cov0" title="0">{
                result.AddError("item is nil")
                return result
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if strings.TrimSpace(item.ID) == "" </span><span class="cov0" title="0">{
                result.AddError("item ID cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(item.Name) == "" </span><span class="cov0" title="0">{
                result.AddError("item name cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(item.Type) == "" </span><span class="cov0" title="0">{
                result.AddError("item type cannot be empty")
        }</span>

        // Validate value
        <span class="cov0" title="0">if item.Value &lt; 0 </span><span class="cov0" title="0">{
                result.AddError("item value cannot be negative")
        }</span>

        // Validate weight
        <span class="cov0" title="0">if item.Weight &lt; 0 </span><span class="cov0" title="0">{
                result.AddError("item weight cannot be negative")
        }</span>

        // Validate armor class for armor items
        <span class="cov0" title="0">if item.Type == "armor" &amp;&amp; item.AC &lt;= 0 </span><span class="cov0" title="0">{
                result.AddWarning("armor item has zero or negative AC")
        }</span>

        // Validate damage for weapon items
        <span class="cov0" title="0">if item.Type == "weapon" &amp;&amp; strings.TrimSpace(item.Damage) == "" </span><span class="cov0" title="0">{
                result.AddWarning("weapon item has no damage specification")
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateLevel validates a generated level
func (v *Validator) ValidateLevel(level *game.Level) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        if level == nil </span><span class="cov0" title="0">{
                result.AddError("level is nil")
                return result
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if strings.TrimSpace(level.ID) == "" </span><span class="cov0" title="0">{
                result.AddError("level ID cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(level.Name) == "" </span><span class="cov0" title="0">{
                result.AddError("level name cannot be empty")
        }</span>

        // Validate dimensions
        <span class="cov0" title="0">if level.Width &lt;= 0 || level.Height &lt;= 0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid level dimensions: %dx%d", level.Width, level.Height))
        }</span>

        // Validate tiles array
        <span class="cov0" title="0">if len(level.Tiles) != level.Height </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("tiles array height mismatch: expected %d, got %d", level.Height, len(level.Tiles)))
        }</span>

        <span class="cov0" title="0">for y, row := range level.Tiles </span><span class="cov0" title="0">{
                if len(row) != level.Width </span><span class="cov0" title="0">{
                        result.AddError(fmt.Sprintf("tiles array width mismatch at row %d: expected %d, got %d", y, level.Width, len(row)))
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ValidateQuest validates a generated quest
func (v *Validator) ValidateQuest(quest *game.Quest) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        if quest == nil </span><span class="cov0" title="0">{
                result.AddError("quest is nil")
                return result
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if strings.TrimSpace(quest.ID) == "" </span><span class="cov0" title="0">{
                result.AddError("quest ID cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(quest.Title) == "" </span><span class="cov0" title="0">{
                result.AddError("quest title cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(quest.Description) == "" </span><span class="cov0" title="0">{
                result.AddError("quest description cannot be empty")
        }</span>

        // Validate status
        <span class="cov0" title="0">validStatuses := []game.QuestStatus{
                game.QuestNotStarted, game.QuestActive,
                game.QuestCompleted, game.QuestFailed,
        }

        statusValid := false
        for _, validStatus := range validStatuses </span><span class="cov0" title="0">{
                if quest.Status == validStatus </span><span class="cov0" title="0">{
                        statusValid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !statusValid </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid quest status: %v", quest.Status))
        }</span>

        // Validate objectives (at least one objective should be present)
        <span class="cov0" title="0">if len(quest.Objectives) == 0 </span><span class="cov0" title="0">{
                result.AddWarning("quest has no objectives")
        }</span>

        // Validate rewards (at least one reward is recommended)
        <span class="cov0" title="0">if len(quest.Rewards) == 0 </span><span class="cov0" title="0">{
                result.AddWarning("quest has no rewards")
        }</span>

        <span class="cov0" title="0">return result</span>
}

// validateMapConnectivity checks if walkable areas in the map are properly connected
func (v *Validator) validateMapConnectivity(gameMap *game.GameMap) bool <span class="cov0" title="0">{
        if !v.isValidMapDimensions(gameMap) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">walkableTiles := v.findWalkableTiles(gameMap)
        if len(walkableTiles) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">reachableCount := v.performConnectivityFloodFill(gameMap, walkableTiles[0])
        return reachableCount == len(walkableTiles)</span>
}

// isValidMapDimensions checks if the game map has valid dimensions
func (v *Validator) isValidMapDimensions(gameMap *game.GameMap) bool <span class="cov0" title="0">{
        return gameMap.Width &gt; 0 &amp;&amp; gameMap.Height &gt; 0
}</span>

// findWalkableTiles discovers all walkable positions in the game map
func (v *Validator) findWalkableTiles(gameMap *game.GameMap) []game.Position <span class="cov0" title="0">{
        walkableTiles := make([]game.Position, 0)
        for y := 0; y &lt; gameMap.Height; y++ </span><span class="cov0" title="0">{
                for x := 0; x &lt; gameMap.Width; x++ </span><span class="cov0" title="0">{
                        if gameMap.Tiles[y][x].Walkable </span><span class="cov0" title="0">{
                                walkableTiles = append(walkableTiles, game.Position{X: x, Y: y})
                        }</span>
                }
        }
        <span class="cov0" title="0">return walkableTiles</span>
}

// performConnectivityFloodFill uses flood fill algorithm to count reachable walkable tiles
func (v *Validator) performConnectivityFloodFill(gameMap *game.GameMap, startPos game.Position) int <span class="cov0" title="0">{
        visited := make(map[game.Position]bool)
        queue := []game.Position{startPos}
        visited[startPos] = true
        reachableCount := 1

        directions := v.getCardinalDirections()

        for len(queue) &gt; 0 </span><span class="cov0" title="0">{
                current := queue[0]
                queue = queue[1:]

                adjacentPositions := v.getAdjacentWalkablePositions(gameMap, current, directions, visited)
                for _, pos := range adjacentPositions </span><span class="cov0" title="0">{
                        visited[pos] = true
                        queue = append(queue, pos)
                        reachableCount++
                }</span>
        }

        <span class="cov0" title="0">return reachableCount</span>
}

// getCardinalDirections returns the four cardinal movement directions
func (v *Validator) getCardinalDirections() []game.Position <span class="cov0" title="0">{
        return []game.Position{
                {X: 0, Y: -1}, // North
                {X: 1, Y: 0},  // East
                {X: 0, Y: 1},  // South
                {X: -1, Y: 0}, // West
        }
}</span>

// getAdjacentWalkablePositions finds all unvisited walkable positions adjacent to current position
func (v *Validator) getAdjacentWalkablePositions(gameMap *game.GameMap, current game.Position, directions []game.Position, visited map[game.Position]bool) []game.Position <span class="cov0" title="0">{
        var adjacent []game.Position

        for _, dir := range directions </span><span class="cov0" title="0">{
                next := game.Position{
                        X: current.X + dir.X,
                        Y: current.Y + dir.Y,
                }

                if v.isValidPosition(gameMap, next) &amp;&amp; !visited[next] &amp;&amp; gameMap.Tiles[next.Y][next.X].Walkable </span><span class="cov0" title="0">{
                        adjacent = append(adjacent, next)
                }</span>
        }

        <span class="cov0" title="0">return adjacent</span>
}

// isValidPosition checks if a position is within the map boundaries
func (v *Validator) isValidPosition(gameMap *game.GameMap, pos game.Position) bool <span class="cov0" title="0">{
        return pos.X &gt;= 0 &amp;&amp; pos.X &lt; gameMap.Width &amp;&amp; pos.Y &gt;= 0 &amp;&amp; pos.Y &lt; gameMap.Height
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
