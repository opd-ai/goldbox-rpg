
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>pcg: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">goldbox-rpg/pkg/pcg/character.go (85.2%)</option>
				
				<option value="file1">goldbox-rpg/pkg/pcg/dungeon.go (89.7%)</option>
				
				<option value="file2">goldbox-rpg/pkg/pcg/faction.go (91.3%)</option>
				
				<option value="file3">goldbox-rpg/pkg/pcg/manager.go (0.0%)</option>
				
				<option value="file4">goldbox-rpg/pkg/pcg/metrics.go (100.0%)</option>
				
				<option value="file5">goldbox-rpg/pkg/pcg/narrative.go (92.6%)</option>
				
				<option value="file6">goldbox-rpg/pkg/pcg/quest.go (96.6%)</option>
				
				<option value="file7">goldbox-rpg/pkg/pcg/registry.go (0.0%)</option>
				
				<option value="file8">goldbox-rpg/pkg/pcg/seed.go (98.6%)</option>
				
				<option value="file9">goldbox-rpg/pkg/pcg/types.go (100.0%)</option>
				
				<option value="file10">goldbox-rpg/pkg/pcg/validation.go (0.0%)</option>
				
				<option value="file11">goldbox-rpg/pkg/pcg/world.go (92.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package pcg

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// NPCGenerator creates NPCs with procedural personalities and motivations
// Generates cohesive character profiles that enhance narrative depth and world immersion
type NPCGenerator struct {
        version string
        logger  *logrus.Logger
        rng     *rand.Rand
}

// NewNPCGenerator creates a new character generator instance
func NewNPCGenerator(logger *logrus.Logger) *NPCGenerator <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                logger = logrus.New()
        }</span>

        <span class="cov8" title="1">return &amp;NPCGenerator{
                version: "1.0.0",
                logger:  logger,
                rng:     rand.New(rand.NewSource(time.Now().UnixNano())),
        }</span>
}

// Generate creates characters based on the provided parameters
// Returns generated NPCs with complete personality profiles
func (cg *NPCGenerator) Generate(ctx context.Context, params GenerationParams) (interface{}, error) <span class="cov8" title="1">{
        if err := cg.Validate(params); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid parameters: %w", err)
        }</span>

        // Use seed for deterministic generation
        <span class="cov8" title="1">rng := rand.New(rand.NewSource(params.Seed))
        cg.rng = rng

        characterParams, ok := params.Constraints["character_params"].(CharacterParams)
        if !ok </span><span class="cov8" title="1">{
                // Use default parameters
                characterParams = CharacterParams{
                        GenerationParams: params,
                        CharacterType:    CharacterTypeGeneric,
                        PersonalityDepth: 3,
                        MotivationCount:  rng.Intn(3) + 1, // 1-3 motivations
                        BackgroundType:   BackgroundUrban,
                        SocialClass:      SocialClassPeasant,
                        AgeRange:         AgeRangeAdult,
                        UniqueTraits:     rng.Intn(3) + 2, // 2-4 traits
                }
        }</span> else<span class="cov8" title="1"> {
                // Apply defaults for unset values
                if len(characterParams.Alignment) == 0 </span><span class="cov8" title="1">{
                        characterParams.Alignment = cg.generateAlignment(rng)
                }</span>
                <span class="cov8" title="1">if characterParams.PersonalityDepth == 0 </span><span class="cov0" title="0">{
                        characterParams.PersonalityDepth = 3
                }</span>
                <span class="cov8" title="1">if characterParams.MotivationCount == 0 </span><span class="cov0" title="0">{
                        characterParams.MotivationCount = rng.Intn(3) + 1
                }</span>
                <span class="cov8" title="1">if characterParams.UniqueTraits == 0 </span><span class="cov0" title="0">{
                        characterParams.UniqueTraits = rng.Intn(3) + 2
                }</span>
        }

        <span class="cov8" title="1">cg.logger.WithFields(logrus.Fields{
                "seed":              params.Seed,
                "character_type":    characterParams.CharacterType,
                "personality_depth": characterParams.PersonalityDepth,
                "background":        characterParams.BackgroundType,
        }).Info("generating character")

        start := time.Now()

        // Generate the character
        npc, err := cg.GenerateNPC(ctx, characterParams.CharacterType, characterParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate character: %w", err)
        }</span>

        <span class="cov8" title="1">duration := time.Since(start)
        cg.logger.WithFields(logrus.Fields{
                "duration":  duration,
                "character": npc.Character.Name,
                "generated": "success",
        }).Info("character generation completed")

        return npc, nil</span>
}

// GenerateNPC creates a single NPC with personality and motivations
func (cg *NPCGenerator) GenerateNPC(ctx context.Context, characterType CharacterType, params CharacterParams) (*game.NPC, error) <span class="cov8" title="1">{
        // Use seed for deterministic generation
        rng := rand.New(rand.NewSource(params.Seed))
        cg.rng = rng

        // Generate base character attributes
        baseChar, err := cg.generateBaseCharacter(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate base character: %w", err)
        }</span>

        // Generate personality profile
        <span class="cov8" title="1">personality, err := cg.GeneratePersonality(ctx, baseChar, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate personality: %w", err)
        }</span>

        // Create NPC with behavior and faction
        // Note: We'll store personality in Dialog metadata for now until we extend Character
        <span class="cov8" title="1">npc := &amp;game.NPC{
                Character: *baseChar.Clone(), // Use Clone to avoid mutex copy issues
                Behavior:  cg.generateBehavior(characterType, params),
                Faction:   params.Faction,
                Dialog:    cg.generateDialog(personality, params),
                LootTable: cg.generateLootTable(characterType, params),
        }

        return npc, nil</span>
}

// GenerateNPCGroup creates a collection of related NPCs
func (cg *NPCGenerator) GenerateNPCGroup(ctx context.Context, groupType NPCGroupType, params CharacterParams) ([]*game.NPC, error) <span class="cov8" title="1">{
        var npcs []*game.NPC
        var groupSize int

        // Determine group size based on type
        switch groupType </span>{
        case NPCGroupFamily:<span class="cov8" title="1">
                groupSize = cg.rng.Intn(5) + 2</span> // 2-6 family members
        case NPCGroupGuards:<span class="cov8" title="1">
                groupSize = cg.rng.Intn(6) + 3</span> // 3-8 guards
        case NPCGroupMerchants:<span class="cov8" title="1">
                groupSize = cg.rng.Intn(4) + 2</span> // 2-5 merchants
        case NPCGroupCultists:<span class="cov0" title="0">
                groupSize = cg.rng.Intn(8) + 4</span> // 4-11 cultists
        case NPCGroupBandits:<span class="cov0" title="0">
                groupSize = cg.rng.Intn(7) + 3</span> // 3-9 bandits
        case NPCGroupScholars:<span class="cov0" title="0">
                groupSize = cg.rng.Intn(4) + 2</span> // 2-5 scholars
        case NPCGroupCrafters:<span class="cov0" title="0">
                groupSize = cg.rng.Intn(5) + 3</span> // 3-7 crafters
        default:<span class="cov0" title="0">
                groupSize = cg.rng.Intn(4) + 2</span> // 2-5 default
        }
        // Generate related characters
        <span class="cov8" title="1">for i := 0; i &lt; groupSize; i++ </span><span class="cov8" title="1">{
                // Adjust character type based on group and position
                charType := cg.selectCharacterTypeForGroup(groupType, i, groupSize)

                // Create modified parameters for group coherence
                groupParams := params
                groupParams.CharacterType = charType
                groupParams.Seed = params.Seed + int64(i*1000) // Ensure unique seed for each group member
                if i == 0 </span><span class="cov8" title="1">{
                        // Leader gets higher social class and more complex personality
                        groupParams.SocialClass = cg.elevatedSocialClass(params.SocialClass)
                        groupParams.PersonalityDepth = params.PersonalityDepth + 1
                }</span>

                <span class="cov8" title="1">npc, err := cg.GenerateNPC(ctx, charType, groupParams)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate group member %d: %w", i, err)
                }</span>

                <span class="cov8" title="1">npcs = append(npcs, npc)</span>
        }

        // Add group relationships and connections
        <span class="cov8" title="1">cg.establishGroupRelationships(npcs, groupType)

        return npcs, nil</span>
}

// GeneratePersonality creates personality traits and motivations
func (cg *NPCGenerator) GeneratePersonality(ctx context.Context, character *game.Character, params CharacterParams) (*PersonalityProfile, error) <span class="cov8" title="1">{
        profile := &amp;PersonalityProfile{
                Alignment:   params.Alignment,
                Temperament: cg.generateTemperament(),
                Values:      cg.generateValues(params),
                Fears:       cg.generateFears(params),
                Speech:      cg.generateSpeechPattern(params),
        }

        // Generate personality traits
        traits, err := cg.generatePersonalityTraits(params.UniqueTraits, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate personality traits: %w", err)
        }</span>
        <span class="cov8" title="1">profile.Traits = traits

        // Generate motivations
        motivations, err := cg.generateMotivations(params.MotivationCount, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate motivations: %w", err)
        }</span>
        <span class="cov8" title="1">profile.Motivations = motivations

        return profile, nil</span>
}

// GetType returns the content type for character generation
func (cg *NPCGenerator) GetType() ContentType <span class="cov8" title="1">{
        return ContentTypeCharacters
}</span>

// GetVersion returns the generator version
func (cg *NPCGenerator) GetVersion() string <span class="cov8" title="1">{
        return cg.version
}</span>

// Validate checks if the provided parameters are valid
func (cg *NPCGenerator) Validate(params GenerationParams) error <span class="cov8" title="1">{
        if params.Seed == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("seed cannot be zero")
        }</span>

        <span class="cov8" title="1">if params.Difficulty &lt; 1 || params.Difficulty &gt; 20 </span><span class="cov8" title="1">{
                return fmt.Errorf("difficulty must be between 1 and 20, got %d", params.Difficulty)
        }</span>

        <span class="cov8" title="1">if params.PlayerLevel &lt; 1 || params.PlayerLevel &gt; 20 </span><span class="cov8" title="1">{
                return fmt.Errorf("player level must be between 1 and 20, got %d", params.PlayerLevel)
        }</span>

        // Validate character-specific constraints if present
        <span class="cov8" title="1">if characterParams, ok := params.Constraints["character_params"].(CharacterParams); ok </span><span class="cov8" title="1">{
                if characterParams.PersonalityDepth &lt; 1 || characterParams.PersonalityDepth &gt; 5 </span><span class="cov8" title="1">{
                        return fmt.Errorf("personality depth must be between 1 and 5, got %d", characterParams.PersonalityDepth)
                }</span>

                <span class="cov8" title="1">if characterParams.MotivationCount &lt; 0 || characterParams.MotivationCount &gt; 10 </span><span class="cov8" title="1">{
                        return fmt.Errorf("motivation count must be between 0 and 10, got %d", characterParams.MotivationCount)
                }</span>

                <span class="cov8" title="1">if characterParams.UniqueTraits &lt; 1 || characterParams.UniqueTraits &gt; 10 </span><span class="cov8" title="1">{
                        return fmt.Errorf("unique traits must be between 1 and 10, got %d", characterParams.UniqueTraits)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// generateBaseCharacter creates the fundamental character attributes
func (cg *NPCGenerator) generateBaseCharacter(params CharacterParams) (*game.Character, error) <span class="cov8" title="1">{
        // Generate basic attributes based on character type and social class
        stats := cg.generateAttributesByType(params.CharacterType, params.SocialClass)

        // Generate name based on background and gender
        name := cg.generateName(params.BackgroundType, params.Gender)

        // Generate description
        description := cg.generateDescription(params)

        // Create character with generated attributes
        character := &amp;game.Character{
                ID:           fmt.Sprintf("npc_%d", cg.rng.Int63()),
                Name:         name,
                Description:  description,
                Class:        cg.selectCharacterClass(params.CharacterType),
                Strength:     stats.Strength,
                Dexterity:    stats.Dexterity,
                Constitution: stats.Constitution,
                Intelligence: stats.Intelligence,
                Wisdom:       stats.Wisdom,
                Charisma:     stats.Charisma,
                Level:        cg.generateLevel(params),
                Gold:         cg.generateStartingGold(params.SocialClass),
                Equipment:    make(map[game.EquipmentSlot]game.Item),
                Inventory:    []game.Item{},
        }

        // Calculate derived stats
        character.MaxHP = cg.calculateMaxHP(character)
        character.HP = character.MaxHP
        character.ArmorClass = cg.calculateArmorClass(character)
        character.THAC0 = cg.calculateTHAC0(character)
        character.MaxActionPoints = cg.calculateActionPoints(character)
        character.ActionPoints = character.MaxActionPoints

        return character, nil
}</span>

// Helper functions for character generation
func (cg *NPCGenerator) generateAlignment(rng *rand.Rand) string <span class="cov8" title="1">{
        alignments := []string{
                "Lawful Good", "Neutral Good", "Chaotic Good",
                "Lawful Neutral", "True Neutral", "Chaotic Neutral",
                "Lawful Evil", "Neutral Evil", "Chaotic Evil",
        }
        return alignments[rng.Intn(len(alignments))]
}</span>

func (cg *NPCGenerator) generateTemperament() string <span class="cov8" title="1">{
        temperaments := []string{
                "sanguine", "choleric", "melancholic", "phlegmatic",
                "optimistic", "pessimistic", "stoic", "passionate",
                "cautious", "bold", "gentle", "fierce",
        }
        return temperaments[cg.rng.Intn(len(temperaments))]
}</span>

func (cg *NPCGenerator) generateValues(params CharacterParams) []string <span class="cov8" title="1">{
        allValues := []string{
                "honor", "wealth", "power", "knowledge", "family",
                "freedom", "justice", "beauty", "tradition", "progress",
                "loyalty", "independence", "compassion", "strength", "wisdom",
        }

        // Select 2-4 values based on personality depth
        numValues := params.PersonalityDepth + cg.rng.Intn(2)
        if numValues &gt; len(allValues) </span><span class="cov0" title="0">{
                numValues = len(allValues)
        }</span>

        <span class="cov8" title="1">values := make([]string, 0, numValues)
        used := make(map[int]bool)

        for len(values) &lt; numValues </span><span class="cov8" title="1">{
                idx := cg.rng.Intn(len(allValues))
                if !used[idx] </span><span class="cov8" title="1">{
                        values = append(values, allValues[idx])
                        used[idx] = true
                }</span>
        }

        <span class="cov8" title="1">return values</span>
}

func (cg *NPCGenerator) generateFears(params CharacterParams) []string <span class="cov8" title="1">{
        allFears := []string{
                "death", "failure", "betrayal", "abandonment", "powerlessness",
                "poverty", "ignorance", "chaos", "authority", "magic",
                "undead", "heights", "water", "fire", "darkness",
        }

        // Select 1-3 fears
        numFears := cg.rng.Intn(3) + 1
        fears := make([]string, 0, numFears)
        used := make(map[int]bool)

        for len(fears) &lt; numFears </span><span class="cov8" title="1">{
                idx := cg.rng.Intn(len(allFears))
                if !used[idx] </span><span class="cov8" title="1">{
                        fears = append(fears, allFears[idx])
                        used[idx] = true
                }</span>
        }

        <span class="cov8" title="1">return fears</span>
}

func (cg *NPCGenerator) generateSpeechPattern(params CharacterParams) SpeechPattern <span class="cov8" title="1">{
        formalities := []string{"formal", "casual", "crude", "archaic", "pompous"}
        vocabularies := []string{"simple", "moderate", "complex", "technical", "poetic"}
        accents := []string{"none", "regional", "foreign", "aristocratic", "rural"}

        pattern := SpeechPattern{
                Formality:  formalities[cg.rng.Intn(len(formalities))],
                Vocabulary: vocabularies[cg.rng.Intn(len(vocabularies))],
                Accent:     accents[cg.rng.Intn(len(accents))],
                Mannerisms: cg.generateSpeechMannerisms(),
        }

        // Sometimes add a catchphrase
        if cg.rng.Float64() &lt; 0.3 </span><span class="cov8" title="1">{
                pattern.Catchphrase = cg.generateCatchphrase(params)
        }</span>

        <span class="cov8" title="1">return pattern</span>
}

func (cg *NPCGenerator) generateSpeechMannerisms() []string <span class="cov8" title="1">{
        allMannerisms := []string{
                "repeats key words", "speaks quickly", "speaks slowly",
                "uses elaborate gestures", "avoids eye contact", "speaks loudly",
                "whispers often", "clears throat frequently", "pauses dramatically",
                "uses archaic terms", "mixes languages", "speaks in rhyme occasionally",
        }

        numMannerisms := cg.rng.Intn(3) + 1 // 1-3 mannerisms
        mannerisms := make([]string, 0, numMannerisms)
        used := make(map[int]bool)

        for len(mannerisms) &lt; numMannerisms </span><span class="cov8" title="1">{
                idx := cg.rng.Intn(len(allMannerisms))
                if !used[idx] </span><span class="cov8" title="1">{
                        mannerisms = append(mannerisms, allMannerisms[idx])
                        used[idx] = true
                }</span>
        }

        <span class="cov8" title="1">return mannerisms</span>
}

func (cg *NPCGenerator) generateCatchphrase(params CharacterParams) string <span class="cov8" title="1">{
        catchphrases := []string{
                "By my honor!", "Mark my words!", "As sure as sunrise!",
                "Trust me on this!", "You can count on it!", "Without a doubt!",
                "I swear by the gods!", "As I live and breathe!", "Upon my soul!",
        }
        return catchphrases[cg.rng.Intn(len(catchphrases))]
}</span>

func (cg *NPCGenerator) generatePersonalityTraits(count int, params CharacterParams) ([]PersonalityTrait, error) <span class="cov8" title="1">{
        allTraits := []string{
                "brave", "cowardly", "honest", "deceitful", "generous", "greedy",
                "patient", "impatient", "wise", "foolish", "kind", "cruel",
                "ambitious", "lazy", "loyal", "treacherous", "humble", "arrogant",
                "creative", "mundane", "curious", "incurious", "optimistic", "pessimistic",
        }

        traits := make([]PersonalityTrait, 0, count)
        used := make(map[int]bool)

        for len(traits) &lt; count &amp;&amp; len(traits) &lt; len(allTraits) </span><span class="cov8" title="1">{
                idx := cg.rng.Intn(len(allTraits))
                if !used[idx] </span><span class="cov8" title="1">{
                        trait := PersonalityTrait{
                                Name:        allTraits[idx],
                                Intensity:   cg.rng.Float64()*0.7 + 0.3, // 0.3-1.0
                                Description: fmt.Sprintf("Character displays %s behavior", allTraits[idx]),
                        }
                        traits = append(traits, trait)
                        used[idx] = true
                }</span>
        }

        <span class="cov8" title="1">return traits, nil</span>
}

func (cg *NPCGenerator) generateMotivations(count int, params CharacterParams) ([]Motivation, error) <span class="cov8" title="1">{
        motivationTypes := []string{
                "power", "wealth", "knowledge", "love", "revenge", "redemption",
                "survival", "family", "honor", "freedom", "justice", "fame",
        }

        motivations := make([]Motivation, 0, count)
        used := make(map[int]bool)

        for len(motivations) &lt; count &amp;&amp; len(motivations) &lt; len(motivationTypes) </span><span class="cov8" title="1">{
                idx := cg.rng.Intn(len(motivationTypes))
                if !used[idx] </span><span class="cov8" title="1">{
                        mType := motivationTypes[idx]
                        motivation := Motivation{
                                Type:        mType,
                                Target:      cg.generateMotivationTarget(mType),
                                Intensity:   cg.rng.Float64()*0.6 + 0.4, // 0.4-1.0
                                Description: fmt.Sprintf("Driven by desire for %s", mType),
                        }
                        motivations = append(motivations, motivation)
                        used[idx] = true
                }</span>
        }

        <span class="cov8" title="1">return motivations, nil</span>
}

func (cg *NPCGenerator) generateMotivationTarget(motivationType string) string <span class="cov8" title="1">{
        targets := map[string][]string{
                "power":      {"political control", "magical ability", "influence over others"},
                "wealth":     {"gold and treasure", "valuable items", "profitable business"},
                "knowledge":  {"ancient secrets", "magical lore", "historical truth"},
                "love":       {"romantic partner", "family member", "lost friend"},
                "revenge":    {"past enemy", "corrupt official", "betrayer"},
                "redemption": {"past mistakes", "family honor", "personal guilt"},
                "survival":   {"personal safety", "family protection", "clan preservation"},
                "family":     {"children's future", "family legacy", "ancestral home"},
                "honor":      {"reputation", "code of conduct", "sworn oath"},
                "freedom":    {"personal liberty", "oppressed people", "enslaved kin"},
                "justice":    {"wronged innocent", "corrupt system", "fair treatment"},
                "fame":       {"legendary status", "heroic recognition", "artistic acclaim"},
        }

        if typeTargets, exists := targets[motivationType]; exists </span><span class="cov8" title="1">{
                return typeTargets[cg.rng.Intn(len(typeTargets))]
        }</span>
        <span class="cov0" title="0">return "unknown goal"</span>
}

// Placeholder implementations for remaining methods
func (cg *NPCGenerator) generateBehavior(characterType CharacterType, params CharacterParams) string <span class="cov8" title="1">{
        behaviors := map[CharacterType][]string{
                CharacterTypeGuard:    {"patrol", "guard_post", "challenge_strangers"},
                CharacterTypeMerchant: {"haggle", "advertise_wares", "count_coins"},
                CharacterTypeNoble:    {"command", "judge", "social_gathering"},
                CharacterTypePeasant:  {"work", "gossip", "simple_tasks"},
                CharacterTypeCrafter:  {"craft", "teach", "perfectionist"},
        }

        if behaviorList, exists := behaviors[characterType]; exists </span><span class="cov8" title="1">{
                return behaviorList[cg.rng.Intn(len(behaviorList))]
        }</span>
        <span class="cov8" title="1">return "generic_npc"</span>
}

func (cg *NPCGenerator) generateDialog(personality *PersonalityProfile, params CharacterParams) []game.DialogEntry <span class="cov8" title="1">{
        // Generate basic dialog entries based on personality
        // This would be expanded with more sophisticated dialog generation
        return []game.DialogEntry{
                {
                        ID:   "greeting",
                        Text: cg.generateGreeting(personality),
                        Responses: []game.DialogResponse{
                                {Text: "Hello", NextDialog: "conversation", Action: ""},
                        },
                },
        }
}</span>

func (cg *NPCGenerator) generateGreeting(personality *PersonalityProfile) string <span class="cov8" title="1">{
        greetings := []string{
                "Well met, traveler!", "Good day to you!", "What brings you here?",
                "Greetings, stranger.", "Welcome!", "State your business.",
        }
        return greetings[cg.rng.Intn(len(greetings))]
}</span>

func (cg *NPCGenerator) generateLootTable(characterType CharacterType, params CharacterParams) []game.LootEntry <span class="cov8" title="1">{
        // Generate appropriate loot based on character type
        return []game.LootEntry{} // Placeholder
}</span>

// Additional helper methods for character generation
func (cg *NPCGenerator) generateAttributesByType(charType CharacterType, socialClass SocialClass) CharacterAttributes <span class="cov8" title="1">{
        // Base attributes
        base := CharacterAttributes{
                Strength:     10,
                Dexterity:    10,
                Constitution: 10,
                Intelligence: 10,
                Wisdom:       10,
                Charisma:     10,
        }

        // Modify based on character type
        switch charType </span>{
        case CharacterTypeGuard:<span class="cov8" title="1">
                base.Strength += cg.rng.Intn(4) + 2     // +2 to +5
                base.Constitution += cg.rng.Intn(3) + 1</span> // +1 to +3
        case CharacterTypeMerchant:<span class="cov8" title="1">
                base.Charisma += cg.rng.Intn(4) + 2     // +2 to +5
                base.Intelligence += cg.rng.Intn(3) + 1</span> // +1 to +3
        case CharacterTypeMage:<span class="cov8" title="1">
                base.Intelligence += cg.rng.Intn(6) + 3 // +3 to +8
                base.Wisdom += cg.rng.Intn(3) + 1</span>       // +1 to +3
        case CharacterTypeNoble:<span class="cov8" title="1">
                base.Charisma += cg.rng.Intn(4) + 3     // +3 to +6
                base.Intelligence += cg.rng.Intn(3) + 2</span> // +2 to +4
        }

        // Modify based on social class
        <span class="cov8" title="1">switch socialClass </span>{
        case SocialClassNoble, SocialClassRoyalty:<span class="cov8" title="1">
                base.Charisma += cg.rng.Intn(3) + 1
                base.Intelligence += cg.rng.Intn(2) + 1</span>
        case SocialClassSlave, SocialClassSerf:<span class="cov0" title="0">
                base.Constitution += cg.rng.Intn(2) + 1</span> // Hardy from hard work
        }

        <span class="cov8" title="1">return base</span>
}

// CharacterAttributes helper struct
type CharacterAttributes struct {
        Strength     int
        Dexterity    int
        Constitution int
        Intelligence int
        Wisdom       int
        Charisma     int
}

// More helper methods
func (cg *NPCGenerator) generateName(background BackgroundType, gender string) string <span class="cov8" title="1">{
        // Simple name generation - could be expanded with more sophisticated systems
        firstNames := []string{"Aiden", "Bella", "Connor", "Diana", "Ethan", "Fiona", "Gareth", "Helen"}
        lastNames := []string{"Smith", "Johnson", "Williams", "Brown", "Jones", "Miller", "Davis", "Garcia"}

        first := firstNames[cg.rng.Intn(len(firstNames))]
        last := lastNames[cg.rng.Intn(len(lastNames))]

        return fmt.Sprintf("%s %s", first, last)
}</span>

func (cg *NPCGenerator) generateDescription(params CharacterParams) string <span class="cov8" title="1">{
        age := cg.ageRangeToDescription(params.AgeRange)
        background := string(params.BackgroundType)
        socialClass := string(params.SocialClass)

        return fmt.Sprintf("A %s %s from a %s background", age, socialClass, background)
}</span>

func (cg *NPCGenerator) ageRangeToDescription(ageRange AgeRange) string <span class="cov8" title="1">{
        switch ageRange </span>{
        case AgeRangeChild:<span class="cov0" title="0">
                return "young"</span>
        case AgeRangeAdolescent:<span class="cov0" title="0">
                return "teenage"</span>
        case AgeRangeYoungAdult:<span class="cov0" title="0">
                return "young adult"</span>
        case AgeRangeAdult:<span class="cov8" title="1">
                return "middle-aged"</span>
        case AgeRangeMiddleAged:<span class="cov8" title="1">
                return "mature"</span>
        case AgeRangeElderly:<span class="cov0" title="0">
                return "elderly"</span>
        case AgeRangeAncient:<span class="cov0" title="0">
                return "ancient"</span>
        default:<span class="cov8" title="1">
                return "adult"</span>
        }
}

func (cg *NPCGenerator) selectCharacterClass(charType CharacterType) game.CharacterClass <span class="cov8" title="1">{
        switch charType </span>{
        case CharacterTypeGuard:<span class="cov8" title="1">
                return game.ClassFighter</span>
        case CharacterTypeMage:<span class="cov8" title="1">
                return game.ClassMage</span>
        case CharacterTypeCleric:<span class="cov0" title="0">
                return game.ClassCleric</span>
        case CharacterTypeRogue:<span class="cov0" title="0">
                return game.ClassThief</span>
        case CharacterTypeMerchant:<span class="cov8" title="1">
                return game.ClassFighter</span> // Merchants often need to defend themselves
        case CharacterTypeNoble:<span class="cov8" title="1">
                return game.ClassFighter</span> // Nobles often have military training
        case CharacterTypeBard:<span class="cov0" title="0">
                return game.ClassThief</span> // Bards use thief-like skills
        case CharacterTypeCrafter:<span class="cov0" title="0">
                return game.ClassFighter</span> // Crafters need physical strength
        default:<span class="cov8" title="1">
                // For generic characters, use a deterministic selection based on RNG
                classes := []game.CharacterClass{
                        game.ClassFighter, game.ClassMage, game.ClassCleric, game.ClassThief,
                }
                return classes[cg.rng.Intn(len(classes))]</span>
        }
}

// Additional methods for group generation and relationship management
func (cg *NPCGenerator) selectCharacterTypeForGroup(groupType NPCGroupType, position, groupSize int) CharacterType <span class="cov8" title="1">{
        switch groupType </span>{
        case NPCGroupGuards:<span class="cov8" title="1">
                if position == 0 </span><span class="cov8" title="1">{
                        return CharacterTypeGuard // Captain is also a guard, not noble
                }</span>
                <span class="cov8" title="1">return CharacterTypeGuard</span>
        case NPCGroupMerchants:<span class="cov8" title="1">
                return CharacterTypeMerchant</span>
        case NPCGroupScholars:<span class="cov0" title="0">
                if position == 0 </span><span class="cov0" title="0">{
                        return CharacterTypeMage // Lead scholar
                }</span>
                <span class="cov0" title="0">return CharacterTypeGeneric</span>
        case NPCGroupCrafters:<span class="cov0" title="0">
                return CharacterTypeCrafter</span>
        case NPCGroupFamily:<span class="cov8" title="1">
                // Mix of character types for family diversity
                if position == 0 </span><span class="cov8" title="1">{
                        return CharacterTypeGeneric // Family head
                }</span>
                <span class="cov8" title="1">return CharacterTypeGeneric</span>
        default:<span class="cov0" title="0">
                return CharacterTypeGeneric</span>
        }
}

func (cg *NPCGenerator) elevatedSocialClass(current SocialClass) SocialClass <span class="cov8" title="1">{
        switch current </span>{
        case SocialClassSlave:<span class="cov0" title="0">
                return SocialClassSerf</span>
        case SocialClassSerf:<span class="cov0" title="0">
                return SocialClassPeasant</span>
        case SocialClassPeasant:<span class="cov8" title="1">
                return SocialClassCrafter</span>
        case SocialClassCrafter:<span class="cov0" title="0">
                return SocialClassMerchant</span>
        case SocialClassMerchant:<span class="cov8" title="1">
                return SocialClassGentry</span>
        case SocialClassGentry:<span class="cov0" title="0">
                return SocialClassNoble</span>
        case SocialClassNoble:<span class="cov0" title="0">
                return SocialClassRoyalty</span>
        default:<span class="cov0" title="0">
                return current</span>
        }
}

func (cg *NPCGenerator) establishGroupRelationships(npcs []*game.NPC, groupType NPCGroupType) {<span class="cov8" title="1">
        // Add logic to establish relationships between group members
        // This could include setting up dialog references, shared motivations, etc.
        // Implementation would depend on the specific relationship system
}</span>

// Remaining calculation methods
func (cg *NPCGenerator) generateLevel(params CharacterParams) int <span class="cov8" title="1">{
        // Base level on difficulty and social class
        baseLevel := params.Difficulty / 4 // 1-5 base level
        if baseLevel &lt; 1 </span><span class="cov8" title="1">{
                baseLevel = 1
        }</span>

        // Add variation
        <span class="cov8" title="1">return baseLevel + cg.rng.Intn(3)</span> // +0 to +2
}

func (cg *NPCGenerator) generateStartingGold(socialClass SocialClass) int <span class="cov8" title="1">{
        base := map[SocialClass]int{
                SocialClassSlave:    10,
                SocialClassSerf:     25,
                SocialClassPeasant:  50,
                SocialClassCrafter:  100,
                SocialClassMerchant: 200,
                SocialClassGentry:   500,
                SocialClassNoble:    1000,
                SocialClassRoyalty:  2000,
        }

        if amount, exists := base[socialClass]; exists </span><span class="cov8" title="1">{
                // Add random variation ±50%
                variation := int(float64(amount) * 0.5)
                return amount + cg.rng.Intn(variation*2) - variation
        }</span>
        <span class="cov0" title="0">return 50</span> // Default
}

func (cg *NPCGenerator) calculateMaxHP(char *game.Character) int <span class="cov8" title="1">{
        // Simple HP calculation based on level and constitution
        baseHP := 4 + cg.getModifier(char.Constitution) // Base 4 HP
        levelHP := char.Level * (2 + cg.getModifier(char.Constitution))
        return baseHP + levelHP
}</span>

func (cg *NPCGenerator) calculateArmorClass(char *game.Character) int <span class="cov8" title="1">{
        // Base AC 10, modified by dexterity
        return 10 - cg.getModifier(char.Dexterity)
}</span>

func (cg *NPCGenerator) calculateTHAC0(char *game.Character) int <span class="cov8" title="1">{
        // Classic D&amp;D THAC0 calculation
        baseTHAC0 := 20 - char.Level
        strMod := cg.getModifier(char.Strength)
        return baseTHAC0 - strMod
}</span>

func (cg *NPCGenerator) calculateActionPoints(char *game.Character) int <span class="cov8" title="1">{
        // Base action points modified by dexterity
        base := 3 + cg.getModifier(char.Dexterity)
        if base &lt; 1 </span><span class="cov0" title="0">{
                base = 1
        }</span>
        <span class="cov8" title="1">return base</span>
}

func (cg *NPCGenerator) getModifier(attribute int) int <span class="cov8" title="1">{
        // Standard D&amp;D attribute modifier calculation
        return (attribute - 10) / 2
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package pcg

import (
        "context"
        "fmt"
        "math/rand"
        "sort"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// DungeonComplex represents a multi-level dungeon structure
// Manages interconnected levels with proper progression and connectivity
type DungeonComplex struct {
        ID          string                 `json:"id"`
        Name        string                 `json:"name"`
        Levels      map[int]*DungeonLevel  `json:"levels"`
        Connections []LevelConnection      `json:"connections"`
        Theme       LevelTheme             `json:"theme"`
        Difficulty  DifficultyProgression  `json:"difficulty"`
        Metadata    map[string]interface{} `json:"metadata"`
        Generated   time.Time              `json:"generated"`
}

// DungeonLevel represents a single level within a dungeon complex
type DungeonLevel struct {
        Level       int                    `json:"level"`
        Map         *game.GameMap          `json:"map"`
        Rooms       []*RoomLayout          `json:"rooms"`
        Connections []ConnectionPoint      `json:"connections"`
        Theme       LevelTheme             `json:"theme"`
        Difficulty  int                    `json:"difficulty"`
        Properties  map[string]interface{} `json:"properties"`
}

// LevelConnection represents connections between dungeon levels
type LevelConnection struct {
        FromLevel    int                    `json:"from_level"`
        ToLevel      int                    `json:"to_level"`
        FromPosition game.Position          `json:"from_position"`
        ToPosition   game.Position          `json:"to_position"`
        Type         ConnectionType         `json:"type"`
        Properties   map[string]interface{} `json:"properties"`
}

// ConnectionPoint represents a connection point within a level
type ConnectionPoint struct {
        Position    game.Position          `json:"position"`
        Type        ConnectionType         `json:"type"`
        TargetLevel int                    `json:"target_level"`
        Properties  map[string]interface{} `json:"properties"`
}

// ConnectionType represents different types of level connections
type ConnectionType string

const (
        ConnectionStairs   ConnectionType = "stairs"
        ConnectionElevator ConnectionType = "elevator"
        ConnectionPortal   ConnectionType = "portal"
        ConnectionPit      ConnectionType = "pit"
        ConnectionLadder   ConnectionType = "ladder"
        ConnectionTunnel   ConnectionType = "tunnel"
)

// DifficultyProgression defines how difficulty scales across levels
type DifficultyProgression struct {
        BaseDifficulty  int     `json:"base_difficulty"`
        ScalingFactor   float64 `json:"scaling_factor"`
        MaxDifficulty   int     `json:"max_difficulty"`
        ProgressionType string  `json:"progression_type"`
}

// DungeonGenerator creates multi-level dungeon complexes
// Uses existing level generation as foundation for complex structures
type DungeonGenerator struct {
        version string
        logger  *logrus.Logger
        rng     *rand.Rand
}

// NewDungeonGenerator creates a new dungeon complex generator
func NewDungeonGenerator(logger *logrus.Logger) *DungeonGenerator <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                logger = logrus.New()
        }</span>

        <span class="cov8" title="1">return &amp;DungeonGenerator{
                version: "1.0.0",
                logger:  logger,
                rng:     rand.New(rand.NewSource(time.Now().UnixNano())),
        }</span>
}

// Generate creates a complete multi-level dungeon complex
// Implements Generator interface for PCG system integration
func (dg *DungeonGenerator) Generate(ctx context.Context, params GenerationParams) (interface{}, error) <span class="cov8" title="1">{
        dungeonParams, ok := params.Constraints["dungeon_params"].(DungeonParams)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid parameters for dungeon generation: expected dungeon_params in constraints")
        }</span>

        // Validate parameters before generation
        <span class="cov8" title="1">if err := dg.Validate(params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parameter validation failed: %w", err)
        }</span>

        // Initialize RNG with provided seed for deterministic generation
        <span class="cov8" title="1">dg.rng = rand.New(rand.NewSource(params.Seed))

        dg.logger.WithFields(logrus.Fields{
                "levels":     dungeonParams.LevelCount,
                "theme":      dungeonParams.Theme,
                "difficulty": dungeonParams.Difficulty.BaseDifficulty,
        }).Info("generating multi-level dungeon complex")

        dungeon, err := dg.generateDungeonComplex(ctx, params, dungeonParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dungeon generation failed: %w", err)
        }</span>

        <span class="cov8" title="1">dg.logger.WithField("dungeon_id", dungeon.ID).Info("dungeon complex generation completed")
        return dungeon, nil</span>
}

// generateDungeonComplex creates the complete dungeon structure
func (dg *DungeonGenerator) generateDungeonComplex(ctx context.Context, params GenerationParams, dungeonParams DungeonParams) (*DungeonComplex, error) <span class="cov8" title="1">{
        dungeon := &amp;DungeonComplex{
                ID:          fmt.Sprintf("dungeon_%d", dg.rng.Int63()),
                Name:        dg.generateDungeonName(dungeonParams.Theme),
                Levels:      make(map[int]*DungeonLevel),
                Connections: make([]LevelConnection, 0),
                Theme:       dungeonParams.Theme,
                Difficulty:  dungeonParams.Difficulty,
                Metadata:    make(map[string]interface{}),
                Generated:   time.Now(),
        }

        // Generate individual levels
        for level := 1; level &lt;= dungeonParams.LevelCount; level++ </span><span class="cov8" title="1">{
                levelDifficulty := dg.calculateLevelDifficulty(level, dungeonParams.Difficulty)

                dungeonLevel, err := dg.generateDungeonLevel(ctx, level, levelDifficulty, params, dungeonParams)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate level %d: %w", level, err)
                }</span>

                <span class="cov8" title="1">dungeon.Levels[level] = dungeonLevel</span>
        }

        // Create connections between levels
        <span class="cov8" title="1">if err := dg.createLevelConnections(dungeon, dungeonParams); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create level connections: %w", err)
        }</span>

        // Add metadata for debugging and validation
        <span class="cov8" title="1">dungeon.Metadata["total_rooms"] = dg.countTotalRooms(dungeon)
        dungeon.Metadata["connection_count"] = len(dungeon.Connections)
        dungeon.Metadata["generation_seed"] = params.Seed

        return dungeon, nil</span>
}

// generateDungeonLevel creates a single level with basic room layout
func (dg *DungeonGenerator) generateDungeonLevel(ctx context.Context, levelNum, difficulty int, params GenerationParams, dungeonParams DungeonParams) (*DungeonLevel, error) <span class="cov8" title="1">{
        // Create a basic game map for this level
        gameMap := &amp;game.GameMap{
                Width:  dungeonParams.LevelWidth,
                Height: dungeonParams.LevelHeight,
                Tiles:  make([][]game.MapTile, dungeonParams.LevelHeight),
        }

        // Initialize map tiles
        for y := 0; y &lt; dungeonParams.LevelHeight; y++ </span><span class="cov8" title="1">{
                gameMap.Tiles[y] = make([]game.MapTile, dungeonParams.LevelWidth)
                for x := 0; x &lt; dungeonParams.LevelWidth; x++ </span><span class="cov8" title="1">{
                        gameMap.Tiles[y][x] = game.MapTile{
                                SpriteX:     1, // Wall sprite
                                SpriteY:     1,
                                Walkable:    false,
                                Transparent: false,
                        }
                }</span>
        }

        // Generate rooms using a simplified approach to avoid import cycle
        <span class="cov8" title="1">rooms := dg.generateRoomsForLevel(gameMap, dungeonParams, difficulty)

        // Connect rooms with basic corridors
        dg.connectRoomsWithCorridors(gameMap, rooms)

        // Convert to DungeonLevel structure
        dungeonLevel := &amp;DungeonLevel{
                Level:       levelNum,
                Map:         gameMap,
                Rooms:       rooms,
                Connections: make([]ConnectionPoint, 0),
                Theme:       dungeonParams.Theme,
                Difficulty:  difficulty,
                Properties:  make(map[string]interface{}),
        }

        // Add level-specific properties
        dungeonLevel.Properties["room_count"] = len(rooms)
        dungeonLevel.Properties["generated_at"] = time.Now()
        dungeonLevel.Properties["level_seed"] = params.Seed + int64(levelNum)

        return dungeonLevel, nil</span>
}

// generateRoomsForLevel creates rooms for a dungeon level
func (dg *DungeonGenerator) generateRoomsForLevel(gameMap *game.GameMap, dungeonParams DungeonParams, difficulty int) []*RoomLayout <span class="cov8" title="1">{
        rooms := make([]*RoomLayout, 0, dungeonParams.RoomsPerLevel)

        // Calculate room sizes based on map dimensions
        minRoomSize := 5
        maxRoomSize := 12

        // Place rooms with basic non-overlapping algorithm
        attempts := 0
        maxAttempts := dungeonParams.RoomsPerLevel * 10

        for len(rooms) &lt; dungeonParams.RoomsPerLevel &amp;&amp; attempts &lt; maxAttempts </span><span class="cov8" title="1">{
                attempts++

                // Random room dimensions
                roomWidth := minRoomSize + dg.rng.Intn(maxRoomSize-minRoomSize+1)
                roomHeight := minRoomSize + dg.rng.Intn(maxRoomSize-minRoomSize+1)

                // Random position with padding
                x := 2 + dg.rng.Intn(gameMap.Width-roomWidth-4)
                y := 2 + dg.rng.Intn(gameMap.Height-roomHeight-4)

                newRoom := Rectangle{
                        X:      x,
                        Y:      y,
                        Width:  roomWidth,
                        Height: roomHeight,
                }

                // Check for overlaps with existing rooms
                overlaps := false
                for _, existingRoom := range rooms </span><span class="cov8" title="1">{
                        if newRoom.Intersects(existingRoom.Bounds) </span><span class="cov8" title="1">{
                                overlaps = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !overlaps </span><span class="cov8" title="1">{
                        room := dg.createRoom(newRoom, len(rooms), dungeonParams.Theme, difficulty)
                        rooms = append(rooms, room)
                        dg.carveRoom(gameMap, room)
                }</span>
        }

        <span class="cov8" title="1">return rooms</span>
}

// createRoom creates a room layout with the specified bounds
func (dg *DungeonGenerator) createRoom(bounds Rectangle, index int, theme LevelTheme, difficulty int) *RoomLayout <span class="cov8" title="1">{
        // Determine room type based on index and theme
        roomType := dg.determineRoomType(index, theme)

        room := &amp;RoomLayout{
                ID:         fmt.Sprintf("room_%d", index),
                Type:       roomType,
                Bounds:     bounds,
                Tiles:      make([][]game.Tile, bounds.Height),
                Doors:      make([]game.Position, 0),
                Features:   make([]RoomFeature, 0),
                Difficulty: difficulty,
                Properties: make(map[string]interface{}),
                Connected:  make([]string, 0),
        }

        // Initialize room tiles as floor
        for y := 0; y &lt; bounds.Height; y++ </span><span class="cov8" title="1">{
                room.Tiles[y] = make([]game.Tile, bounds.Width)
                for x := 0; x &lt; bounds.Width; x++ </span><span class="cov8" title="1">{
                        room.Tiles[y][x] = game.Tile{
                                Type:        game.TileFloor,
                                Walkable:    true,
                                Transparent: true,
                                Properties:  make(map[string]interface{}),
                                Sprite:      "floor",
                                Color:       game.RGB{R: 128, G: 128, B: 128},
                        }
                }</span>
        }

        <span class="cov8" title="1">return room</span>
}

// carveRoom carves the room into the game map
func (dg *DungeonGenerator) carveRoom(gameMap *game.GameMap, room *RoomLayout) <span class="cov8" title="1">{
        for y := room.Bounds.Y; y &lt; room.Bounds.Y+room.Bounds.Height; y++ </span><span class="cov8" title="1">{
                for x := room.Bounds.X; x &lt; room.Bounds.X+room.Bounds.Width; x++ </span><span class="cov8" title="1">{
                        if y &gt;= 0 &amp;&amp; y &lt; gameMap.Height &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; gameMap.Width </span><span class="cov8" title="1">{
                                gameMap.Tiles[y][x] = game.MapTile{
                                        SpriteX:     0, // Floor sprite
                                        SpriteY:     0,
                                        Walkable:    true,
                                        Transparent: true,
                                }
                        }</span>
                }
        }
}

// connectRoomsWithCorridors creates simple L-shaped corridors between rooms
func (dg *DungeonGenerator) connectRoomsWithCorridors(gameMap *game.GameMap, rooms []*RoomLayout) <span class="cov8" title="1">{
        for i := 0; i &lt; len(rooms)-1; i++ </span><span class="cov8" title="1">{
                room1 := rooms[i]
                room2 := rooms[i+1]

                // Get center points of rooms
                x1 := room1.Bounds.X + room1.Bounds.Width/2
                y1 := room1.Bounds.Y + room1.Bounds.Height/2
                x2 := room2.Bounds.X + room2.Bounds.Width/2
                y2 := room2.Bounds.Y + room2.Bounds.Height/2

                // Create L-shaped corridor
                dg.carveCorridor(gameMap, x1, y1, x2, y1) // Horizontal
                dg.carveCorridor(gameMap, x2, y1, x2, y2) // Vertical

                // Update connections
                room1.Connected = append(room1.Connected, room2.ID)
                room2.Connected = append(room2.Connected, room1.ID)
        }</span>
}

// carveCorridor carves a corridor between two points
func (dg *DungeonGenerator) carveCorridor(gameMap *game.GameMap, x1, y1, x2, y2 int) <span class="cov8" title="1">{
        // Ensure we're carving in the right direction
        if x1 &gt; x2 </span><span class="cov8" title="1">{
                x1, x2 = x2, x1
        }</span>
        <span class="cov8" title="1">if y1 &gt; y2 </span><span class="cov8" title="1">{
                y1, y2 = y2, y1
        }</span>

        <span class="cov8" title="1">for x := x1; x &lt;= x2; x++ </span><span class="cov8" title="1">{
                if x &gt;= 0 &amp;&amp; x &lt; gameMap.Width &amp;&amp; y1 &gt;= 0 &amp;&amp; y1 &lt; gameMap.Height </span><span class="cov8" title="1">{
                        gameMap.Tiles[y1][x] = game.MapTile{
                                SpriteX:     0, // Floor sprite
                                SpriteY:     0,
                                Walkable:    true,
                                Transparent: true,
                        }
                }</span>
        }

        <span class="cov8" title="1">for y := y1; y &lt;= y2; y++ </span><span class="cov8" title="1">{
                if x2 &gt;= 0 &amp;&amp; x2 &lt; gameMap.Width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; gameMap.Height </span><span class="cov8" title="1">{
                        gameMap.Tiles[y][x2] = game.MapTile{
                                SpriteX:     0, // Floor sprite
                                SpriteY:     0,
                                Walkable:    true,
                                Transparent: true,
                        }
                }</span>
        }
}

// determineRoomType determines the type of room based on index and theme
func (dg *DungeonGenerator) determineRoomType(index int, theme LevelTheme) RoomType <span class="cov8" title="1">{
        if index == 0 </span><span class="cov8" title="1">{
                return RoomTypeEntrance
        }</span>

        // Use weighted random selection for other room types
        <span class="cov8" title="1">weights := map[RoomType]int{
                RoomTypeCombat:   40,
                RoomTypeTreasure: 15,
                RoomTypePuzzle:   10,
                RoomTypeShop:     5,
                RoomTypeRest:     5,
                RoomTypeTrap:     10,
                RoomTypeStory:    10,
                RoomTypeSecret:   5,
        }

        // Adjust weights based on theme
        switch theme </span>{
        case ThemeHorror:<span class="cov8" title="1">
                weights[RoomTypeTrap] = 20
                weights[RoomTypeCombat] = 50</span>
        case ThemeMagical:<span class="cov0" title="0">
                weights[RoomTypePuzzle] = 20
                weights[RoomTypeShop] = 10</span>
        }

        <span class="cov8" title="1">return dg.weightedRandomRoomType(weights)</span>
}

// weightedRandomRoomType selects a room type using weighted random selection
func (dg *DungeonGenerator) weightedRandomRoomType(weights map[RoomType]int) RoomType <span class="cov8" title="1">{
        totalWeight := 0
        for _, weight := range weights </span><span class="cov8" title="1">{
                totalWeight += weight
        }</span>

        <span class="cov8" title="1">randomValue := dg.rng.Intn(totalWeight)
        currentWeight := 0

        for roomType, weight := range weights </span><span class="cov8" title="1">{
                currentWeight += weight
                if randomValue &lt; currentWeight </span><span class="cov8" title="1">{
                        return roomType
                }</span>
        }

        <span class="cov0" title="0">return RoomTypeCombat</span> // fallback
}

// createLevelConnections establishes connections between dungeon levels
func (dg *DungeonGenerator) createLevelConnections(dungeon *DungeonComplex, params DungeonParams) error <span class="cov8" title="1">{
        levels := make([]int, 0, len(dungeon.Levels))
        for levelNum := range dungeon.Levels </span><span class="cov8" title="1">{
                levels = append(levels, levelNum)
        }</span>
        <span class="cov8" title="1">sort.Ints(levels)

        // Create connections between adjacent levels
        for i := 0; i &lt; len(levels)-1; i++ </span><span class="cov8" title="1">{
                fromLevel := levels[i]
                toLevel := levels[i+1]

                connection, err := dg.createLevelConnection(dungeon.Levels[fromLevel], dungeon.Levels[toLevel], params)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create connection from level %d to %d: %w", fromLevel, toLevel, err)
                }</span>

                <span class="cov8" title="1">dungeon.Connections = append(dungeon.Connections, *connection)</span>
        }

        // Add occasional skip connections for complexity (e.g., level 1 to level 3)
        <span class="cov8" title="1">if len(levels) &gt; 3 &amp;&amp; dg.rng.Float64() &lt; 0.3 </span><span class="cov0" title="0">{
                skipConnection, err := dg.createSkipConnection(dungeon, levels, params)
                if err == nil </span><span class="cov0" title="0">{
                        dungeon.Connections = append(dungeon.Connections, *skipConnection)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// createLevelConnection creates a connection between two adjacent levels
func (dg *DungeonGenerator) createLevelConnection(fromLevel, toLevel *DungeonLevel, params DungeonParams) (*LevelConnection, error) <span class="cov8" title="1">{
        // Find suitable positions for connections in both levels
        fromPos, err := dg.findConnectionPosition(fromLevel, ConnectionStairs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find connection position in level %d: %w", fromLevel.Level, err)
        }</span>

        <span class="cov8" title="1">toPos, err := dg.findConnectionPosition(toLevel, ConnectionStairs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find connection position in level %d: %w", toLevel.Level, err)
        }</span>

        // Choose connection type based on theme and level difference
        <span class="cov8" title="1">connectionType := dg.chooseConnectionType(fromLevel, toLevel, params.Theme)

        connection := &amp;LevelConnection{
                FromLevel:    fromLevel.Level,
                ToLevel:      toLevel.Level,
                FromPosition: fromPos,
                ToPosition:   toPos,
                Type:         connectionType,
                Properties:   make(map[string]interface{}),
        }

        // Add connection points to the levels
        fromLevel.Connections = append(fromLevel.Connections, ConnectionPoint{
                Position:    fromPos,
                Type:        connectionType,
                TargetLevel: toLevel.Level,
                Properties:  make(map[string]interface{}),
        })

        toLevel.Connections = append(toLevel.Connections, ConnectionPoint{
                Position:    toPos,
                Type:        connectionType,
                TargetLevel: fromLevel.Level,
                Properties:  make(map[string]interface{}),
        })

        return connection, nil</span>
}

// findConnectionPosition finds a suitable position for a level connection
func (dg *DungeonGenerator) findConnectionPosition(level *DungeonLevel, connType ConnectionType) (game.Position, error) <span class="cov8" title="1">{
        // Look for rooms that can accommodate connections
        suitableRooms := make([]*RoomLayout, 0)

        for _, room := range level.Rooms </span><span class="cov8" title="1">{
                // Avoid boss rooms and secret rooms for main connections
                if room.Type != RoomTypeBoss &amp;&amp; room.Type != RoomTypeSecret </span><span class="cov8" title="1">{
                        suitableRooms = append(suitableRooms, room)
                }</span>
        }

        <span class="cov8" title="1">if len(suitableRooms) == 0 </span><span class="cov0" title="0">{
                return game.Position{}, fmt.Errorf("no suitable rooms found for connection")
        }</span>

        // Choose a random suitable room
        <span class="cov8" title="1">room := suitableRooms[dg.rng.Intn(len(suitableRooms))]

        // Find a floor tile within the room for the connection
        attempts := 0
        maxAttempts := 50

        for attempts &lt; maxAttempts </span><span class="cov8" title="1">{
                // Use relative coordinates within the room bounds
                relativeX := 1 + dg.rng.Intn(room.Bounds.Width-2)
                relativeY := 1 + dg.rng.Intn(room.Bounds.Height-2)

                // Convert to absolute map coordinates
                absoluteX := room.Bounds.X + relativeX
                absoluteY := room.Bounds.Y + relativeY

                // Check if the relative coordinates are valid for the room tiles array
                if relativeY &lt; len(room.Tiles) &amp;&amp; relativeX &lt; len(room.Tiles[relativeY]) </span><span class="cov8" title="1">{
                        if room.Tiles[relativeY][relativeX].Type == game.TileFloor &amp;&amp; room.Tiles[relativeY][relativeX].Walkable </span><span class="cov8" title="1">{
                                return game.Position{X: absoluteX, Y: absoluteY}, nil
                        }</span>
                }
                <span class="cov0" title="0">attempts++</span>
        }

        <span class="cov0" title="0">return game.Position{}, fmt.Errorf("failed to find valid connection position after %d attempts", maxAttempts)</span>
}

// Helper methods

// generateDungeonName creates a thematic name for the dungeon
func (dg *DungeonGenerator) generateDungeonName(theme LevelTheme) string <span class="cov8" title="1">{
        prefixes := map[LevelTheme][]string{
                ThemeClassic:    {"Ancient", "Forgotten", "Lost", "Hidden"},
                ThemeHorror:     {"Cursed", "Haunted", "Nightmare", "Shadow"},
                ThemeNatural:    {"Living", "Verdant", "Root", "Grove"},
                ThemeMechanical: {"Clockwork", "Steam", "Gear", "Iron"},
                ThemeMagical:    {"Arcane", "Crystal", "Ethereal", "Mystic"},
                ThemeUndead:     {"Bone", "Death", "Tomb", "Crypt"},
                ThemeElemental:  {"Elemental", "Primal", "Storm", "Flame"},
        }

        suffixes := []string{"Depths", "Chambers", "Caverns", "Halls", "Passages", "Tunnels", "Labyrinth", "Dungeon"}

        prefix := prefixes[theme][dg.rng.Intn(len(prefixes[theme]))]
        suffix := suffixes[dg.rng.Intn(len(suffixes))]

        return fmt.Sprintf("%s %s", prefix, suffix)
}</span>

// calculateLevelDifficulty computes difficulty for a specific level
func (dg *DungeonGenerator) calculateLevelDifficulty(level int, progression DifficultyProgression) int <span class="cov8" title="1">{
        baseDiff := float64(progression.BaseDifficulty)
        scaledDiff := baseDiff + (float64(level-1) * progression.ScalingFactor)

        difficulty := int(scaledDiff)
        if difficulty &gt; progression.MaxDifficulty </span><span class="cov8" title="1">{
                difficulty = progression.MaxDifficulty
        }</span>

        <span class="cov8" title="1">return difficulty</span>
}

// chooseConnectionType selects appropriate connection type based on context
func (dg *DungeonGenerator) chooseConnectionType(fromLevel, toLevel *DungeonLevel, theme LevelTheme) ConnectionType <span class="cov8" title="1">{
        // Default to stairs for most themes
        weights := map[ConnectionType]int{
                ConnectionStairs: 60,
                ConnectionLadder: 20,
                ConnectionPit:    10,
                ConnectionTunnel: 5,
        }

        // Adjust weights based on theme
        switch theme </span>{
        case ThemeMechanical:<span class="cov8" title="1">
                weights[ConnectionElevator] = 30
                weights[ConnectionStairs] = 40</span>
        case ThemeMagical:<span class="cov8" title="1">
                weights[ConnectionPortal] = 25
                weights[ConnectionStairs] = 45</span>
        case ThemeNatural:<span class="cov8" title="1">
                weights[ConnectionLadder] = 40
                weights[ConnectionTunnel] = 20</span>
        }

        <span class="cov8" title="1">return dg.weightedRandomConnection(weights)</span>
}

// weightedRandomConnection selects a connection type using weighted random selection
func (dg *DungeonGenerator) weightedRandomConnection(weights map[ConnectionType]int) ConnectionType <span class="cov8" title="1">{
        totalWeight := 0
        for _, weight := range weights </span><span class="cov8" title="1">{
                totalWeight += weight
        }</span>

        <span class="cov8" title="1">randomValue := dg.rng.Intn(totalWeight)
        currentWeight := 0

        for connType, weight := range weights </span><span class="cov8" title="1">{
                currentWeight += weight
                if randomValue &lt; currentWeight </span><span class="cov8" title="1">{
                        return connType
                }</span>
        }

        <span class="cov0" title="0">return ConnectionStairs</span> // fallback
}

// createSkipConnection creates optional skip connections between non-adjacent levels
func (dg *DungeonGenerator) createSkipConnection(dungeon *DungeonComplex, levels []int, params DungeonParams) (*LevelConnection, error) <span class="cov0" title="0">{
        if len(levels) &lt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient levels for skip connection")
        }</span>

        // Create connection from level 1 to level 3 (or similar pattern)
        <span class="cov0" title="0">fromLevel := levels[0]
        toLevel := levels[2]

        return dg.createLevelConnection(dungeon.Levels[fromLevel], dungeon.Levels[toLevel], params)</span>
}

// countTotalRooms counts total rooms across all levels
func (dg *DungeonGenerator) countTotalRooms(dungeon *DungeonComplex) int <span class="cov8" title="1">{
        total := 0
        for _, level := range dungeon.Levels </span><span class="cov8" title="1">{
                total += len(level.Rooms)
        }</span>
        <span class="cov8" title="1">return total</span>
}

// Interface compliance methods

// GetType returns the content type this generator produces
func (dg *DungeonGenerator) GetType() ContentType <span class="cov8" title="1">{
        return ContentTypeDungeon
}</span>

// GetVersion returns the generator version for compatibility
func (dg *DungeonGenerator) GetVersion() string <span class="cov8" title="1">{
        return dg.version
}</span>

// Validate checks if the provided parameters are valid
func (dg *DungeonGenerator) Validate(params GenerationParams) error <span class="cov8" title="1">{
        dungeonParams, ok := params.Constraints["dungeon_params"].(DungeonParams)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid parameters: expected dungeon_params in constraints")
        }</span>

        <span class="cov8" title="1">if dungeonParams.LevelCount &lt; 1 || dungeonParams.LevelCount &gt; 20 </span><span class="cov8" title="1">{
                return fmt.Errorf("level count must be between 1 and 20, got %d", dungeonParams.LevelCount)
        }</span>

        <span class="cov8" title="1">if dungeonParams.LevelWidth &lt; 20 || dungeonParams.LevelWidth &gt; 200 </span><span class="cov8" title="1">{
                return fmt.Errorf("level width must be between 20 and 200, got %d", dungeonParams.LevelWidth)
        }</span>

        <span class="cov8" title="1">if dungeonParams.LevelHeight &lt; 20 || dungeonParams.LevelHeight &gt; 200 </span><span class="cov8" title="1">{
                return fmt.Errorf("level height must be between 20 and 200, got %d", dungeonParams.LevelHeight)
        }</span>

        <span class="cov8" title="1">if dungeonParams.RoomsPerLevel &lt; 3 || dungeonParams.RoomsPerLevel &gt; 50 </span><span class="cov8" title="1">{
                return fmt.Errorf("rooms per level must be between 3 and 50, got %d", dungeonParams.RoomsPerLevel)
        }</span>

        <span class="cov8" title="1">if dungeonParams.Difficulty.ScalingFactor &lt; 0 || dungeonParams.Difficulty.ScalingFactor &gt; 10 </span><span class="cov8" title="1">{
                return fmt.Errorf("scaling factor must be between 0 and 10, got %f", dungeonParams.Difficulty.ScalingFactor)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package pcg

import (
        "context"
        "fmt"
        "math"
        "math/rand"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// FactionGenerator creates political entities, relationships, and conflicts
// Generates cohesive faction systems that influence world politics and economics
type FactionGenerator struct {
        version string
        logger  *logrus.Logger
        rng     *rand.Rand
}

// NewFactionGenerator creates a new faction generator instance
func NewFactionGenerator(logger *logrus.Logger) *FactionGenerator <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                logger = logrus.New()
        }</span>

        <span class="cov8" title="1">return &amp;FactionGenerator{
                version: "1.0.0",
                logger:  logger,
                rng:     rand.New(rand.NewSource(time.Now().UnixNano())),
        }</span>
}

// Generate creates faction systems based on the provided parameters
// Returns GeneratedFactionSystem containing all political entities and relationships
func (fg *FactionGenerator) Generate(ctx context.Context, params GenerationParams) (interface{}, error) <span class="cov8" title="1">{
        if err := fg.Validate(params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid parameters: %w", err)
        }</span>

        // Use seed for deterministic generation
        <span class="cov8" title="1">rng := rand.New(rand.NewSource(params.Seed))
        fg.rng = rng

        factionParams, ok := params.Constraints["faction_params"].(FactionParams)
        if !ok </span><span class="cov8" title="1">{
                // Use default parameters
                factionParams = FactionParams{
                        GenerationParams: params,
                        FactionCount:     rng.Intn(8) + 3, // 3-10 factions
                        MinPower:         1,
                        MaxPower:         10,
                        ConflictLevel:    0.3,
                        EconomicFocus:    0.5,
                        MilitaryFocus:    0.4,
                        CulturalFocus:    0.3,
                }
        }</span> else<span class="cov8" title="1"> {
                // Apply defaults for unset values
                if factionParams.MinPower == 0 </span><span class="cov8" title="1">{
                        factionParams.MinPower = 1
                }</span>
                <span class="cov8" title="1">if factionParams.MaxPower == 0 </span><span class="cov8" title="1">{
                        factionParams.MaxPower = 10
                }</span>
                <span class="cov8" title="1">if factionParams.FactionCount == 0 </span><span class="cov0" title="0">{
                        factionParams.FactionCount = rng.Intn(8) + 3
                }</span>
        }

        <span class="cov8" title="1">fg.logger.WithFields(logrus.Fields{
                "seed":           params.Seed,
                "faction_count":  factionParams.FactionCount,
                "conflict_level": factionParams.ConflictLevel,
        }).Info("generating faction system")

        start := time.Now()

        // Generate the faction system
        factionSystem, err := fg.generateFactionSystem(ctx, factionParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate faction system: %w", err)
        }</span>

        <span class="cov8" title="1">duration := time.Since(start)
        fg.logger.WithFields(logrus.Fields{
                "duration":      duration,
                "factions":      len(factionSystem.Factions),
                "relationships": len(factionSystem.Relationships),
        }).Info("faction system generation completed")

        return factionSystem, nil</span>
}

// GetType returns the content type for faction generation
func (fg *FactionGenerator) GetType() ContentType <span class="cov8" title="1">{
        return ContentTypeFactions
}</span>

// GetVersion returns the generator version
func (fg *FactionGenerator) GetVersion() string <span class="cov8" title="1">{
        return fg.version
}</span>

// Validate checks if the provided parameters are valid for faction generation
func (fg *FactionGenerator) Validate(params GenerationParams) error <span class="cov8" title="1">{
        if params.Seed == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("seed cannot be zero")
        }</span>

        <span class="cov8" title="1">if params.Difficulty &lt; 1 || params.Difficulty &gt; 20 </span><span class="cov8" title="1">{
                return fmt.Errorf("difficulty must be between 1 and 20, got %d", params.Difficulty)
        }</span>

        // Validate faction-specific constraints if provided
        <span class="cov8" title="1">if factionConstraints, exists := params.Constraints["faction_params"]; exists </span><span class="cov8" title="1">{
                if factionParams, ok := factionConstraints.(FactionParams); ok </span><span class="cov8" title="1">{
                        if factionParams.FactionCount &lt; 1 || factionParams.FactionCount &gt; 20 </span><span class="cov8" title="1">{
                                return fmt.Errorf("faction count must be between 1 and 20, got %d", factionParams.FactionCount)
                        }</span>

                        <span class="cov8" title="1">if factionParams.ConflictLevel &lt; 0.0 || factionParams.ConflictLevel &gt; 1.0 </span><span class="cov8" title="1">{
                                return fmt.Errorf("conflict level must be between 0.0 and 1.0, got %f", factionParams.ConflictLevel)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// generateFactionSystem creates a complete faction system with relationships
func (fg *FactionGenerator) generateFactionSystem(ctx context.Context, params FactionParams) (*GeneratedFactionSystem, error) <span class="cov8" title="1">{
        system := &amp;GeneratedFactionSystem{
                ID:            fg.generateID("faction_system"),
                Name:          fg.generateSystemName(),
                Factions:      make([]*Faction, 0, params.FactionCount),
                Relationships: make([]*FactionRelationship, 0),
                Territories:   make([]*Territory, 0),
                TradeDeals:    make([]*TradeDeal, 0),
                Conflicts:     make([]*Conflict, 0),
                Metadata:      make(map[string]interface{}),
                Generated:     time.Now(),
        }

        // Generate individual factions
        for i := 0; i &lt; params.FactionCount; i++ </span><span class="cov8" title="1">{
                faction, err := fg.generateFaction(ctx, i, params)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate faction %d: %w", i, err)
                }</span>
                <span class="cov8" title="1">system.Factions = append(system.Factions, faction)</span>
        }

        // Generate relationships between factions
        <span class="cov8" title="1">if err := fg.generateRelationships(ctx, system, params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate relationships: %w", err)
        }</span>

        // Generate territories and assign to factions
        <span class="cov8" title="1">if err := fg.generateTerritories(ctx, system, params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate territories: %w", err)
        }</span>

        // Generate trade deals based on economic interests
        <span class="cov8" title="1">if err := fg.generateTradeDeals(ctx, system, params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate trade deals: %w", err)
        }</span>

        // Generate active conflicts based on relationships
        <span class="cov8" title="1">if err := fg.generateConflicts(ctx, system, params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate conflicts: %w", err)
        }</span>

        // Add metadata about the generation
        <span class="cov8" title="1">system.Metadata["generation_seed"] = params.Seed
        system.Metadata["conflict_level"] = params.ConflictLevel
        system.Metadata["economic_focus"] = params.EconomicFocus
        system.Metadata["military_focus"] = params.MilitaryFocus

        return system, nil</span>
}

// generateFaction creates a single faction with characteristics and goals
func (fg *FactionGenerator) generateFaction(ctx context.Context, index int, params FactionParams) (*Faction, error) <span class="cov8" title="1">{
        faction := &amp;Faction{
                ID:         fg.generateID("faction"),
                Name:       fg.generateFactionName(),
                Type:       fg.selectFactionType(),
                Government: fg.selectGovernmentType(),
                Ideology:   fg.generateIdeology(),
                Power:      fg.rng.Intn(params.MaxPower-params.MinPower+1) + params.MinPower,
                Wealth:     fg.rng.Intn(params.MaxPower-params.MinPower+1) + params.MinPower,
                Military:   fg.rng.Intn(params.MaxPower-params.MinPower+1) + params.MinPower,
                Influence:  fg.rng.Intn(params.MaxPower-params.MinPower+1) + params.MinPower,
                Stability:  fg.rng.Float64(),
                Goals:      fg.generateFactionGoals(),
                Resources:  fg.generateControlledResources(),
                Leaders:    fg.generateLeadership(),
                Properties: make(map[string]interface{}),
        }

        // Add faction-specific properties based on type
        fg.addFactionTypeProperties(faction)

        // Adjust attributes based on faction focus areas
        fg.adjustFactionAttributes(faction, params)

        fg.logger.WithFields(logrus.Fields{
                "faction_id":   faction.ID,
                "faction_name": faction.Name,
                "faction_type": faction.Type,
                "power":        faction.Power,
        }).Debug("generated faction")

        return faction, nil
}</span>

// generateRelationships creates diplomatic relationships between all factions
func (fg *FactionGenerator) generateRelationships(ctx context.Context, system *GeneratedFactionSystem, params FactionParams) error <span class="cov8" title="1">{
        factions := system.Factions

        for i := 0; i &lt; len(factions); i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(factions); j++ </span><span class="cov8" title="1">{
                        relationship := fg.generateRelationship(factions[i], factions[j], params)
                        system.Relationships = append(system.Relationships, relationship)
                }</span>
        }

        // Ensure relationship consistency (if A likes B, B should have some opinion of A)
        <span class="cov8" title="1">fg.balanceRelationships(system.Relationships)

        return nil</span>
}

// generateRelationship creates a diplomatic relationship between two factions
func (fg *FactionGenerator) generateRelationship(faction1, faction2 *Faction, params FactionParams) *FactionRelationship <span class="cov8" title="1">{
        // Base relationship influenced by faction types and ideologies
        baseRelation := fg.calculateBaseRelation(faction1, faction2)

        // Add random variation
        variation := (fg.rng.Float64() - 0.5) * 0.4 // ±0.2 variation
        finalRelation := math.Max(-1.0, math.Min(1.0, baseRelation+variation))

        status := fg.determineRelationshipStatus(finalRelation)

        return &amp;FactionRelationship{
                ID:          fg.generateID("relationship"),
                Faction1ID:  faction1.ID,
                Faction2ID:  faction2.ID,
                Status:      status,
                Opinion:     finalRelation,
                TrustLevel:  fg.rng.Float64(),
                TradeLevel:  fg.calculateTradeLevel(finalRelation, faction1, faction2),
                Hostility:   fg.calculateHostility(finalRelation, params.ConflictLevel),
                History:     fg.generateRelationshipHistory(),
                LastChanged: time.Now().AddDate(0, 0, -fg.rng.Intn(365)),
                Properties:  make(map[string]interface{}),
        }
}</span>

// Helper methods for faction generation

func (fg *FactionGenerator) generateSystemName() string <span class="cov8" title="1">{
        prefixes := []string{"The", "Greater", "United", "Free", "Allied", "Independent"}
        middles := []string{"Kingdoms", "Realms", "States", "Territories", "Provinces", "Lands"}
        suffixes := []string{"Coalition", "Alliance", "Federation", "Union", "League", "Assembly"}

        if fg.rng.Float32() &lt; 0.3 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s %s",
                        prefixes[fg.rng.Intn(len(prefixes))],
                        middles[fg.rng.Intn(len(middles))])
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%s %s %s",
                prefixes[fg.rng.Intn(len(prefixes))],
                middles[fg.rng.Intn(len(middles))],
                suffixes[fg.rng.Intn(len(suffixes))])</span>
}

func (fg *FactionGenerator) generateFactionName() string <span class="cov8" title="1">{
        prefixes := []string{"Order of", "House", "Clan", "Guild of", "Brotherhood of", "Circle of", "Council of"}
        names := []string{"Iron", "Gold", "Silver", "Storm", "Shadow", "Light", "Fire", "Stone", "Steel", "Crystal"}
        suffixes := []string{"Keepers", "Guardians", "Warriors", "Merchants", "Scholars", "Mages", "Knights", "Rangers"}

        prefix := prefixes[fg.rng.Intn(len(prefixes))]
        name := names[fg.rng.Intn(len(names))]
        suffix := suffixes[fg.rng.Intn(len(suffixes))]

        return fmt.Sprintf("%s %s %s", prefix, name, suffix)
}</span>

func (fg *FactionGenerator) selectFactionType() FactionType <span class="cov8" title="1">{
        types := []FactionType{
                FactionTypeMilitary, FactionTypeEconomic, FactionTypeReligious,
                FactionTypeCriminal, FactionTypeScholarly, FactionTypePolitical,
                FactionTypeMercenary, FactionTypeMagical,
        }
        return types[fg.rng.Intn(len(types))]
}</span>

func (fg *FactionGenerator) selectGovernmentType() GovernmentType <span class="cov8" title="1">{
        types := []GovernmentType{
                GovernmentMonarchy, GovernmentRepublic, GovernmentTheocracy,
                GovernmentMilitary, GovernmentTribal, GovernmentAnarchy,
        }
        return types[fg.rng.Intn(len(types))]
}</span>

func (fg *FactionGenerator) generateIdeology() string <span class="cov8" title="1">{
        ideologies := []string{
                "Expansionist", "Isolationist", "Traditionalist", "Progressive",
                "Militaristic", "Pacifist", "Mercantile", "Religious",
                "Scholarly", "Pragmatic", "Idealistic", "Nationalist",
        }
        return ideologies[fg.rng.Intn(len(ideologies))]
}</span>

func (fg *FactionGenerator) generateFactionGoals() []string <span class="cov8" title="1">{
        possibleGoals := []string{
                "territorial_expansion", "economic_dominance", "religious_conversion",
                "knowledge_acquisition", "political_influence", "military_supremacy",
                "trade_monopoly", "cultural_preservation", "magical_research",
                "resource_control", "alliance_building", "enemy_destruction",
        }

        goalCount := fg.rng.Intn(3) + 2 // 2-4 goals
        goals := make([]string, 0, goalCount)

        // Select unique goals
        selected := make(map[int]bool)
        for len(goals) &lt; goalCount </span><span class="cov8" title="1">{
                index := fg.rng.Intn(len(possibleGoals))
                if !selected[index] </span><span class="cov8" title="1">{
                        goals = append(goals, possibleGoals[index])
                        selected[index] = true
                }</span>
        }

        <span class="cov8" title="1">return goals</span>
}

func (fg *FactionGenerator) generateControlledResources() []ResourceType <span class="cov8" title="1">{
        resources := []ResourceType{
                ResourceGold, ResourceIron, ResourceFood,
                ResourceWood, ResourceStone, ResourceMagicite,
        }

        resourceCount := fg.rng.Intn(4) + 1 // 1-4 resources
        controlled := make([]ResourceType, 0, resourceCount)

        selected := make(map[int]bool)
        for len(controlled) &lt; resourceCount </span><span class="cov8" title="1">{
                index := fg.rng.Intn(len(resources))
                if !selected[index] </span><span class="cov8" title="1">{
                        controlled = append(controlled, resources[index])
                        selected[index] = true
                }</span>
        }

        <span class="cov8" title="1">return controlled</span>
}

func (fg *FactionGenerator) generateLeadership() []*FactionLeader <span class="cov8" title="1">{
        leaderCount := fg.rng.Intn(3) + 1 // 1-3 leaders
        leaders := make([]*FactionLeader, 0, leaderCount)

        titles := []string{"Lord", "Commander", "High Priest", "Guildmaster", "Archmage", "Chief", "President", "General"}
        traits := []string{"Ambitious", "Cunning", "Wise", "Ruthless", "Charismatic", "Strategic", "Diplomatic", "Fierce"}

        for i := 0; i &lt; leaderCount; i++ </span><span class="cov8" title="1">{
                leader := &amp;FactionLeader{
                        ID:         fg.generateID("leader"),
                        Name:       fg.generateLeaderName(),
                        Title:      titles[fg.rng.Intn(len(titles))],
                        Age:        fg.rng.Intn(40) + 25, // 25-65 years old
                        Traits:     []string{traits[fg.rng.Intn(len(traits))]},
                        Loyalty:    fg.rng.Float64(),
                        Competence: fg.rng.Float64(),
                        Influence:  fg.rng.Float64(),
                        Properties: make(map[string]interface{}),
                }
                leaders = append(leaders, leader)
        }</span>

        <span class="cov8" title="1">return leaders</span>
}

func (fg *FactionGenerator) generateLeaderName() string <span class="cov8" title="1">{
        firstNames := []string{"Aldric", "Vera", "Marcus", "Elena", "Gareth", "Lyra", "Theron", "Mira"}
        lastNames := []string{"Ironforge", "Goldweaver", "Stormwind", "Shadowbane", "Lightbringer", "Darkbane"}

        return fmt.Sprintf("%s %s",
                firstNames[fg.rng.Intn(len(firstNames))],
                lastNames[fg.rng.Intn(len(lastNames))])
}</span>

// generateID creates a unique identifier with a prefix
func (fg *FactionGenerator) generateID(prefix string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s_%d", prefix, fg.rng.Int63())
}</span>

// Helper methods for generating missing functionality

func (fg *FactionGenerator) addFactionTypeProperties(faction *Faction) <span class="cov8" title="1">{
        // Add type-specific properties based on faction type
        switch faction.Type </span>{
        case FactionTypeMilitary:<span class="cov8" title="1">
                faction.Properties["unit_types"] = []string{"infantry", "cavalry", "archers"}
                faction.Military += 2</span> // Military factions get bonus military power
        case FactionTypeEconomic:<span class="cov8" title="1">
                faction.Properties["trade_routes"] = fg.rng.Intn(5) + 3
                faction.Wealth += 2</span> // Economic factions get bonus wealth
        case FactionTypeReligious:<span class="cov8" title="1">
                faction.Properties["temples"] = fg.rng.Intn(3) + 1
                faction.Influence += 2</span> // Religious factions get bonus influence
        case FactionTypeMagical:<span class="cov8" title="1">
                faction.Properties["mage_towers"] = fg.rng.Intn(2) + 1
                faction.Properties["magical_knowledge"] = fg.rng.Intn(100) + 50</span>
        }
}

func (fg *FactionGenerator) adjustFactionAttributes(faction *Faction, params FactionParams) <span class="cov8" title="1">{
        // Adjust attributes based on focus parameters
        if params.MilitaryFocus &gt; 0.5 </span><span class="cov0" title="0">{
                faction.Military = int(float64(faction.Military) * (1.0 + params.MilitaryFocus))
        }</span>
        <span class="cov8" title="1">if params.EconomicFocus &gt; 0.5 </span><span class="cov8" title="1">{
                faction.Wealth = int(float64(faction.Wealth) * (1.0 + params.EconomicFocus))
        }</span>
}

func (fg *FactionGenerator) calculateBaseRelation(faction1, faction2 *Faction) float64 <span class="cov8" title="1">{
        // Calculate base relationship based on faction characteristics
        relation := 0.0

        // Same government types tend to get along better
        if faction1.Government == faction2.Government </span><span class="cov8" title="1">{
                relation += 0.2
        }</span>

        // Same ideology creates affinity
        <span class="cov8" title="1">if faction1.Ideology == faction2.Ideology </span><span class="cov8" title="1">{
                relation += 0.3
        }</span>

        // Military factions tend to be suspicious of each other
        <span class="cov8" title="1">if faction1.Type == FactionTypeMilitary &amp;&amp; faction2.Type == FactionTypeMilitary </span><span class="cov8" title="1">{
                relation -= 0.2
        }</span>

        // Economic factions often cooperate
        <span class="cov8" title="1">if faction1.Type == FactionTypeEconomic &amp;&amp; faction2.Type == FactionTypeEconomic </span><span class="cov0" title="0">{
                relation += 0.1
        }</span>

        // Criminal factions are generally disliked
        <span class="cov8" title="1">if faction1.Type == FactionTypeCriminal || faction2.Type == FactionTypeCriminal </span><span class="cov8" title="1">{
                relation -= 0.3
        }</span>

        <span class="cov8" title="1">return relation</span>
}

func (fg *FactionGenerator) determineRelationshipStatus(opinion float64) RelationshipStatus <span class="cov8" title="1">{
        if opinion &gt;= 0.7 </span><span class="cov8" title="1">{
                return RelationStatusAllied
        }</span> else<span class="cov8" title="1"> if opinion &gt;= 0.3 </span><span class="cov8" title="1">{
                return RelationStatusFriendly
        }</span> else<span class="cov8" title="1"> if opinion &gt;= -0.3 </span><span class="cov8" title="1">{
                return RelationStatusNeutral
        }</span> else<span class="cov8" title="1"> if opinion &gt;= -0.7 </span><span class="cov8" title="1">{
                return RelationStatusTense
        }</span> else<span class="cov8" title="1"> if opinion &gt;= -0.9 </span><span class="cov8" title="1">{
                return RelationStatusHostile
        }</span>
        <span class="cov8" title="1">return RelationStatusWar</span>
}

func (fg *FactionGenerator) calculateTradeLevel(opinion float64, faction1, faction2 *Faction) float64 <span class="cov8" title="1">{
        baseTradeLevel := (opinion + 1.0) / 2.0 // Convert -1:1 to 0:1

        // Economic factions trade more
        if faction1.Type == FactionTypeEconomic || faction2.Type == FactionTypeEconomic </span><span class="cov8" title="1">{
                baseTradeLevel *= 1.3
        }</span>

        // Criminal factions trade less legitimately
        <span class="cov8" title="1">if faction1.Type == FactionTypeCriminal || faction2.Type == FactionTypeCriminal </span><span class="cov8" title="1">{
                baseTradeLevel *= 0.5
        }</span>

        <span class="cov8" title="1">return math.Min(1.0, baseTradeLevel)</span>
}

func (fg *FactionGenerator) calculateHostility(opinion float64, conflictLevel float64) float64 <span class="cov8" title="1">{
        // Convert opinion to hostility (inverse relationship)
        hostility := (1.0 - opinion) / 2.0

        // Scale by overall conflict level
        hostility *= conflictLevel

        return math.Max(0.0, math.Min(1.0, hostility))
}</span>

func (fg *FactionGenerator) generateRelationshipHistory() []string <span class="cov8" title="1">{
        historyEvents := []string{
                "trade_agreement", "border_dispute", "alliance_formation", "betrayal",
                "military_cooperation", "diplomatic_incident", "succession_crisis",
                "resource_conflict", "territorial_exchange", "marriage_alliance",
        }

        eventCount := fg.rng.Intn(3) + 1 // 1-3 historical events
        history := make([]string, 0, eventCount)

        for i := 0; i &lt; eventCount; i++ </span><span class="cov8" title="1">{
                event := historyEvents[fg.rng.Intn(len(historyEvents))]
                history = append(history, event)
        }</span>

        <span class="cov8" title="1">return history</span>
}

func (fg *FactionGenerator) balanceRelationships(relationships []*FactionRelationship) <span class="cov8" title="1">{
        // Ensure relationship consistency and realistic political dynamics
        for _, rel := range relationships </span><span class="cov8" title="1">{
                // Add some mutual opinion influence (relationships aren't perfectly one-sided)
                if fg.rng.Float64() &lt; 0.3 </span><span class="cov8" title="1">{
                        // Small chance for asymmetric relationships
                        variation := (fg.rng.Float64() - 0.5) * 0.2
                        rel.Opinion = math.Max(-1.0, math.Min(1.0, rel.Opinion+variation))
                }</span>
        }
}

// Placeholder methods for complete implementation
func (fg *FactionGenerator) generateTerritories(ctx context.Context, system *GeneratedFactionSystem, params FactionParams) error <span class="cov8" title="1">{
        // TODO: Implement territory generation based on faction power and world geography
        // For now, create basic territories for each faction
        for _, faction := range system.Factions </span><span class="cov8" title="1">{
                territoryCount := fg.rng.Intn(3) + 1 // 1-3 territories per faction
                for j := 0; j &lt; territoryCount; j++ </span><span class="cov8" title="1">{
                        territory := &amp;Territory{
                                ID:           fg.generateID("territory"),
                                Name:         fmt.Sprintf("%s Territory %d", faction.Name, j+1),
                                Type:         fg.selectTerritoryType(),
                                ControllerID: faction.ID,
                                Position:     game.Position{X: fg.rng.Intn(100), Y: fg.rng.Intn(100)},
                                Size:         fg.rng.Intn(50) + 10,
                                Population:   fg.rng.Intn(10000) + 1000,
                                Defenses:     faction.Military + fg.rng.Intn(5),
                                Resources:    faction.Resources,
                                Strategic:    fg.rng.Float64() &lt; 0.3,
                                Properties:   make(map[string]interface{}),
                        }
                        system.Territories = append(system.Territories, territory)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (fg *FactionGenerator) generateTradeDeals(ctx context.Context, system *GeneratedFactionSystem, params FactionParams) error <span class="cov8" title="1">{
        // Generate trade deals between friendly factions
        for _, rel := range system.Relationships </span><span class="cov8" title="1">{
                if rel.TradeLevel &gt; 0.5 &amp;&amp; fg.rng.Float64() &lt; params.EconomicFocus </span><span class="cov8" title="1">{
                        deal := &amp;TradeDeal{
                                ID:         fg.generateID("trade"),
                                Name:       fmt.Sprintf("Trade Agreement %s", fg.generateID("agreement")),
                                Faction1ID: rel.Faction1ID,
                                Faction2ID: rel.Faction2ID,
                                Resource1:  fg.selectTradeResource(),
                                Resource2:  fg.selectTradeResource(),
                                Volume1:    fg.rng.Intn(1000) + 100,
                                Volume2:    fg.rng.Intn(1000) + 100,
                                Duration:   fg.rng.Intn(365) + 90, // 90-455 days
                                Profit1:    fg.rng.Intn(500) + 50,
                                Profit2:    fg.rng.Intn(500) + 50,
                                Active:     true,
                                Properties: make(map[string]interface{}),
                        }
                        system.TradeDeals = append(system.TradeDeals, deal)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (fg *FactionGenerator) generateConflicts(ctx context.Context, system *GeneratedFactionSystem, params FactionParams) error <span class="cov8" title="1">{
        // Generate active conflicts based on hostile relationships
        for _, rel := range system.Relationships </span><span class="cov8" title="1">{
                if rel.Hostility &gt; 0.7 &amp;&amp; fg.rng.Float64() &lt; params.ConflictLevel </span><span class="cov0" title="0">{
                        conflict := &amp;Conflict{
                                ID:         fg.generateID("conflict"),
                                Name:       fmt.Sprintf("Conflict of %s", fg.generateConflictName()),
                                Type:       fg.selectConflictType(),
                                Factions:   []string{rel.Faction1ID, rel.Faction2ID},
                                Cause:      fg.generateConflictCause(),
                                Intensity:  rel.Hostility,
                                Duration:   fg.rng.Intn(180) + 30, // 30-210 days
                                Territory:  "",                    // Would be populated if territory system is more advanced
                                Resolution: "",
                                Active:     true,
                                Properties: make(map[string]interface{}),
                        }
                        system.Conflicts = append(system.Conflicts, conflict)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Additional helper methods

func (fg *FactionGenerator) selectTerritoryType() TerritoryType <span class="cov8" title="1">{
        types := []TerritoryType{
                TerritoryTypeCapital, TerritoryTypeCity, TerritoryTypeOutpost,
                TerritoryTypeFortress, TerritoryTypeTradingPost, TerritoryTypeResource,
        }
        return types[fg.rng.Intn(len(types))]
}</span>

func (fg *FactionGenerator) selectTradeResource() ResourceType <span class="cov8" title="1">{
        resources := []ResourceType{
                ResourceIron, ResourceGold, ResourceGems, ResourceWood,
                ResourceStone, ResourceMagicite, ResourceFood, ResourceWater,
        }
        return resources[fg.rng.Intn(len(resources))]
}</span>

func (fg *FactionGenerator) selectConflictType() ConflictType <span class="cov0" title="0">{
        types := []ConflictType{
                ConflictTypeTrade, ConflictTypeTerritory, ConflictTypeReligious,
                ConflictTypeResource, ConflictTypeSuccession, ConflictTypeRevenge,
        }
        return types[fg.rng.Intn(len(types))]
}</span>

func (fg *FactionGenerator) generateConflictName() string <span class="cov0" title="0">{
        names := []string{
                "the Iron Crown", "Disputed Territories", "Sacred Relics",
                "Trade Route Control", "Succession Rights", "Ancient Grievances",
                "Resource Claims", "Border Demarcation", "Religious Differences",
        }
        return names[fg.rng.Intn(len(names))]
}</span>

func (fg *FactionGenerator) generateConflictCause() string <span class="cov0" title="0">{
        causes := []string{
                "territorial_expansion", "resource_competition", "succession_dispute",
                "trade_route_control", "religious_differences", "historical_grievance",
                "border_incident", "diplomatic_insult", "alliance_betrayal",
        }
        return causes[fg.rng.Intn(len(causes))]
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package pcg

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// PCGManager is the main coordinator for procedural content generation
// Integrates with existing game systems and manages the generation lifecycle
type PCGManager struct {
        registry    *Registry
        factory     *Factory
        validator   *Validator
        logger      *logrus.Logger
        world       *game.World
        seedManager *SeedManager
        metrics     *GenerationMetrics
}

// NewPCGManager creates a new PCG manager instance
func NewPCGManager(world *game.World, logger *logrus.Logger) *PCGManager <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = logrus.New()
        }</span>

        <span class="cov0" title="0">registry := NewRegistry(logger)
        factory := NewFactory(registry, logger)
        validator := NewValidator(false)
        seedManager := NewSeedManager(0) // Will be set by game initialization
        metrics := NewGenerationMetrics()

        return &amp;PCGManager{
                registry:    registry,
                factory:     factory,
                validator:   validator,
                logger:      logger,
                world:       world,
                seedManager: seedManager,
                metrics:     metrics,
        }</span>
}

// InitializeWithSeed sets the base seed for all generation
func (pcg *PCGManager) InitializeWithSeed(seed int64) <span class="cov0" title="0">{
        pcg.seedManager = NewSeedManager(seed)
        pcg.logger.WithField("seed", seed).Info("PCG manager initialized with seed")
}</span>

// RegisterDefaultGenerators registers the built-in generators
func (pcg *PCGManager) RegisterDefaultGenerators() error <span class="cov0" title="0">{
        pcg.logger.Info("Registering default PCG generators")

        // Register the faction generator
        factionGenerator := NewFactionGenerator(pcg.logger)
        if err := pcg.registry.RegisterGenerator("default", factionGenerator); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register faction generator: %w", err)
        }</span>

        // Register the character generator
        <span class="cov0" title="0">characterGenerator := NewNPCGenerator(pcg.logger)
        if err := pcg.registry.RegisterGenerator("default", characterGenerator); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register character generator: %w", err)
        }</span>

        // Register the quest generator
        <span class="cov0" title="0">questGenerator := NewQuestGenerator(pcg.logger)
        if err := pcg.registry.RegisterGenerator("default", questGenerator); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register quest generator: %w", err)
        }</span>

        // Note: Actual generators are registered by the server initialization
        // to avoid import cycles. This method serves as a placeholder for
        // future expansion and is called to ensure the system is ready.

        <span class="cov0" title="0">return nil</span>
}

// GenerateTerrainForLevel generates terrain for a specific game level
func (pcg *PCGManager) GenerateTerrainForLevel(ctx context.Context, levelID string, width, height int, biome BiomeType, difficulty int) (*game.GameMap, error) <span class="cov0" title="0">{
        startTime := time.Now()
        defer func() </span><span class="cov0" title="0">{
                duration := time.Since(startTime)
                pcg.metrics.RecordGeneration(ContentTypeTerrain, duration)
                pcg.logger.WithFields(logrus.Fields{
                        "content_type": ContentTypeTerrain,
                        "level_id":     levelID,
                        "duration":     duration,
                }).Debug("terrain generation completed")
        }</span>()

        <span class="cov0" title="0">params := TerrainParams{
                GenerationParams: GenerationParams{
                        Seed:        pcg.seedManager.DeriveContextSeed(ContentTypeTerrain, levelID),
                        Difficulty:  difficulty,
                        PlayerLevel: 1, // Could be derived from world state
                        WorldState:  pcg.world,
                        Timeout:     30 * time.Second,
                        Constraints: make(map[string]interface{}),
                },
                BiomeType:    biome,
                Density:      0.45,
                Connectivity: ConnectivityModerate,
                WaterLevel:   0.1,
                Roughness:    0.5,
        }

        // Add terrain-specific constraints
        params.Constraints["width"] = width
        params.Constraints["height"] = height
        params.Constraints["terrain_params"] = params

        gameMap, err := pcg.factory.GenerateTerrain(ctx, "cellular_automata", params)
        if err != nil </span><span class="cov0" title="0">{
                pcg.metrics.RecordError(ContentTypeTerrain)
        }</span>

        <span class="cov0" title="0">return gameMap, err</span>
}

// GenerateItemsForLocation generates items appropriate for a specific location
func (pcg *PCGManager) GenerateItemsForLocation(ctx context.Context, locationID string, itemCount int, minRarity, maxRarity RarityTier, playerLevel int) ([]*game.Item, error) <span class="cov0" title="0">{
        startTime := time.Now()
        defer func() </span><span class="cov0" title="0">{
                duration := time.Since(startTime)
                pcg.metrics.RecordGeneration(ContentTypeItems, duration)
                pcg.logger.WithFields(logrus.Fields{
                        "content_type": ContentTypeItems,
                        "location_id":  locationID,
                        "item_count":   itemCount,
                        "duration":     duration,
                }).Debug("item generation completed")
        }</span>()

        <span class="cov0" title="0">params := ItemParams{
                GenerationParams: GenerationParams{
                        Seed:        pcg.seedManager.DeriveContextSeed(ContentTypeItems, locationID),
                        Difficulty:  pcg.calculateLocationDifficulty(locationID),
                        PlayerLevel: playerLevel,
                        WorldState:  pcg.world,
                        Timeout:     10 * time.Second,
                        Constraints: make(map[string]interface{}),
                },
                MinRarity:       minRarity,
                MaxRarity:       maxRarity,
                EnchantmentRate: 0.2,
                UniqueChance:    0.05,
                LevelScaling:    true,
        }

        // Add item count constraint
        params.Constraints["item_count"] = itemCount

        items, err := pcg.factory.GenerateItems(ctx, "template_based", params)
        if err != nil </span><span class="cov0" title="0">{
                pcg.metrics.RecordError(ContentTypeItems)
        }</span>

        <span class="cov0" title="0">return items, err</span>
}

// GenerateDungeonLevel generates a complete dungeon level
func (pcg *PCGManager) GenerateDungeonLevel(ctx context.Context, levelID string, minRooms, maxRooms int, theme LevelTheme, difficulty int) (*game.Level, error) <span class="cov0" title="0">{
        params := LevelParams{
                GenerationParams: GenerationParams{
                        Seed:        pcg.seedManager.DeriveContextSeed(ContentTypeLevels, levelID),
                        Difficulty:  difficulty,
                        PlayerLevel: pcg.getAveragePartyLevel(),
                        WorldState:  pcg.world,
                        Timeout:     60 * time.Second,
                        Constraints: make(map[string]interface{}),
                },
                MinRooms:      minRooms,
                MaxRooms:      maxRooms,
                RoomTypes:     []RoomType{RoomTypeEntrance, RoomTypeExit, RoomTypeCombat, RoomTypeTreasure},
                CorridorStyle: CorridorWindy,
                LevelTheme:    theme,
                HasBoss:       difficulty &gt;= 10,
                SecretRooms:   maxRooms / 10,
        }

        return pcg.factory.GenerateLevel(ctx, "room_corridor", params)
}</span>

// GenerateQuestForArea generates a quest appropriate for a specific area
func (pcg *PCGManager) GenerateQuestForArea(ctx context.Context, areaID string, questType QuestType, playerLevel int) (*game.Quest, error) <span class="cov0" title="0">{
        params := QuestParams{
                GenerationParams: GenerationParams{
                        Seed:        pcg.seedManager.DeriveContextSeed(ContentTypeQuests, areaID),
                        Difficulty:  pcg.calculateAreaDifficulty(areaID),
                        PlayerLevel: playerLevel,
                        WorldState:  pcg.world,
                        Timeout:     15 * time.Second,
                        Constraints: make(map[string]interface{}),
                },
                QuestType:     questType,
                MinObjectives: 1,
                MaxObjectives: 3,
                RewardTier:    RarityRare,
                Narrative:     NarrativeLinear,
        }

        return pcg.factory.GenerateQuest(ctx, "objective_based", params)
}</span>

// ValidateGeneratedContent validates content before integration into the world
func (pcg *PCGManager) ValidateGeneratedContent(content interface{}) (*ValidationResult, error) <span class="cov0" title="0">{
        switch v := content.(type) </span>{
        case *game.GameMap:<span class="cov0" title="0">
                return pcg.validator.ValidateGameMap(v), nil</span>
        case *game.Item:<span class="cov0" title="0">
                return pcg.validator.ValidateItem(v), nil</span>
        case *game.Level:<span class="cov0" title="0">
                return pcg.validator.ValidateLevel(v), nil</span>
        case *game.Quest:<span class="cov0" title="0">
                return pcg.validator.ValidateQuest(v), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported content type for validation: %T", content)</span>
        }
}

// IntegrateContentIntoWorld integrates generated content into the game world
func (pcg *PCGManager) IntegrateContentIntoWorld(content interface{}, locationID string) error <span class="cov0" title="0">{
        // Validate content before integration
        validationResult, err := pcg.ValidateGeneratedContent(content)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if !validationResult.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("content validation failed: %v", validationResult.Errors)
        }</span>

        // Log warnings if present
        <span class="cov0" title="0">if validationResult.HasWarnings() </span><span class="cov0" title="0">{
                pcg.logger.WithFields(logrus.Fields{
                        "location": locationID,
                        "warnings": validationResult.Warnings,
                }).Warn("Generated content has validation warnings")
        }</span>

        // Integrate based on content type
        <span class="cov0" title="0">switch v := content.(type) </span>{
        case *game.Level:<span class="cov0" title="0">
                return pcg.integrateLevelIntoWorld(v, locationID)</span>
        case *game.Item:<span class="cov0" title="0">
                return pcg.integrateItemIntoWorld(v, locationID)</span>
        case []*game.Item:<span class="cov0" title="0">
                for _, item := range v </span><span class="cov0" title="0">{
                        if err := pcg.integrateItemIntoWorld(item, locationID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported content type for integration: %T", content)</span>
        }
}

// RegenerateContentForLocation regenerates content for a specific location
func (pcg *PCGManager) RegenerateContentForLocation(ctx context.Context, locationID string, contentType ContentType) (interface{}, error) <span class="cov0" title="0">{
        pcg.logger.WithFields(logrus.Fields{
                "location":     locationID,
                "content_type": contentType,
        }).Info("Regenerating content for location")

        // Get current world state for context
        difficulty := pcg.calculateLocationDifficulty(locationID)
        playerLevel := pcg.getAveragePartyLevel()

        switch contentType </span>{
        case ContentTypeTerrain:<span class="cov0" title="0">
                return pcg.GenerateTerrainForLevel(ctx, locationID, 50, 50, BiomeDungeon, difficulty)</span>
        case ContentTypeItems:<span class="cov0" title="0">
                return pcg.GenerateItemsForLocation(ctx, locationID, 3, RarityCommon, RarityRare, playerLevel)</span>
        case ContentTypeLevels:<span class="cov0" title="0">
                return pcg.GenerateDungeonLevel(ctx, locationID, 5, 15, ThemeClassic, difficulty)</span>
        case ContentTypeQuests:<span class="cov0" title="0">
                return pcg.GenerateQuestForArea(ctx, locationID, QuestTypeFetch, playerLevel)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported content type for regeneration: %s", contentType)</span>
        }
}

// GetGenerationStatistics returns statistics about generation activity
func (pcg *PCGManager) GetGenerationStatistics() map[string]interface{} <span class="cov0" title="0">{
        stats := make(map[string]interface{})

        // Get available generators
        stats["available_generators"] = pcg.registry.ListAllGenerators()

        // Get seed information
        stats["base_seed"] = pcg.seedManager.GetBaseSeed()

        // Include generation metrics
        stats["performance_metrics"] = pcg.metrics.GetStats()

        return stats
}</span>

// GetRegistry returns the generator registry for external registration
func (pcg *PCGManager) GetRegistry() *Registry <span class="cov0" title="0">{
        return pcg.registry
}</span>

// GetMetrics returns the generation metrics instance
func (pcg *PCGManager) GetMetrics() *GenerationMetrics <span class="cov0" title="0">{
        return pcg.metrics
}</span>

// ResetMetrics clears all generation metrics
func (pcg *PCGManager) ResetMetrics() <span class="cov0" title="0">{
        pcg.metrics.Reset()
        pcg.logger.Info("PCG generation metrics reset")
}</span>

// Helper methods for integration

func (pcg *PCGManager) integrateLevelIntoWorld(level *game.Level, locationID string) error <span class="cov0" title="0">{
        // Add level to world - World should provide thread-safe methods for this
        // For now, we'll use a direct approach assuming World has proper synchronization
        pcg.world.Levels = append(pcg.world.Levels, *level)

        pcg.logger.WithFields(logrus.Fields{
                "level_id": level.ID,
                "location": locationID,
                "width":    level.Width,
                "height":   level.Height,
        }).Info("Integrated generated level into world")

        return nil
}</span>

func (pcg *PCGManager) integrateItemIntoWorld(item *game.Item, locationID string) error <span class="cov0" title="0">{
        // Add item to world objects - World should provide thread-safe methods for this
        if pcg.world.Objects == nil </span><span class="cov0" title="0">{
                pcg.world.Objects = make(map[string]game.GameObject)
        }</span>

        <span class="cov0" title="0">pcg.world.Objects[item.ID] = item

        // Update spatial index if available
        if pcg.world.SpatialIndex != nil </span><span class="cov0" title="0">{
                if err := pcg.world.SpatialIndex.Insert(item); err != nil </span><span class="cov0" title="0">{
                        pcg.logger.WithFields(logrus.Fields{
                                "item_id": item.ID,
                                "error":   err.Error(),
                        }).Warn("Failed to add item to spatial index")
                }</span>
        }

        <span class="cov0" title="0">pcg.logger.WithFields(logrus.Fields{
                "item_id":  item.ID,
                "location": locationID,
                "type":     item.Type,
                "value":    item.Value,
        }).Info("Integrated generated item into world")

        return nil</span>
}

// Helper methods for world state analysis

func (pcg *PCGManager) calculateLocationDifficulty(locationID string) int <span class="cov0" title="0">{
        // Analyze world state to determine appropriate difficulty
        // This would examine factors like:
        // - Player party levels
        // - Location depth/progression
        // - Existing challenges in the area
        // - World difficulty curve

        // Simplified implementation
        return 5 // Default moderate difficulty
}</span>

func (pcg *PCGManager) calculateAreaDifficulty(areaID string) int <span class="cov0" title="0">{
        // Similar to location difficulty but for larger areas
        return pcg.calculateLocationDifficulty(areaID)
}</span>

func (pcg *PCGManager) getAveragePartyLevel() int <span class="cov0" title="0">{
        if pcg.world == nil </span><span class="cov0" title="0">{
                return 1
        }</span>

        // Note: In a real implementation, World should provide thread-safe accessors
        <span class="cov0" title="0">if len(pcg.world.Players) == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov0" title="0">totalLevel := 0
        count := 0

        for _, player := range pcg.world.Players </span><span class="cov0" title="0">{
                // Note: Character is a struct, not a pointer, so we check Level directly
                if player.Character.Level &gt; 0 </span><span class="cov0" title="0">{
                        totalLevel += player.Character.Level
                        count++
                }</span>
        }

        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov0" title="0">return totalLevel / count</span>
}

// convertMapContent attempts to convert map[string]interface{} content to appropriate struct types
func (pcg *PCGManager) convertMapContent(content map[string]interface{}, contentType string) (interface{}, error) <span class="cov0" title="0">{
        // Convert map back to JSON, then unmarshal to the correct type
        jsonData, err := json.Marshal(content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal content: %w", err)
        }</span>

        <span class="cov0" title="0">switch contentType </span>{
        case "quests":<span class="cov0" title="0">
                var quest game.Quest
                if err := json.Unmarshal(jsonData, &amp;quest); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal quest content: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;quest, nil</span>
        case "items":<span class="cov0" title="0">
                var item game.Item
                if err := json.Unmarshal(jsonData, &amp;item); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal item content: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;item, nil</span>
        case "levels":<span class="cov0" title="0">
                var level game.Level
                if err := json.Unmarshal(jsonData, &amp;level); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal level content: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;level, nil</span>
        case "maps":<span class="cov0" title="0">
                var gameMap game.GameMap
                if err := json.Unmarshal(jsonData, &amp;gameMap); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal map content: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;gameMap, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported content type for conversion: %s", contentType)</span>
        }
}

// ValidateGeneratedContentWithType validates content with explicit type information
func (pcg *PCGManager) ValidateGeneratedContentWithType(content interface{}, contentType string) (*ValidationResult, error) <span class="cov0" title="0">{
        // Handle map[string]interface{} content by converting to proper types
        if mapContent, ok := content.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                convertedContent, err := pcg.convertMapContent(mapContent, contentType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert map content: %w", err)
                }</span>
                <span class="cov0" title="0">content = convertedContent</span>
        }

        <span class="cov0" title="0">return pcg.ValidateGeneratedContent(content)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package pcg

import (
        "sync"
        "time"
)

// GenerationMetrics tracks performance statistics
type GenerationMetrics struct {
        mu               sync.RWMutex
        GenerationCounts map[ContentType]int64         `json:"generation_counts"`
        AverageTimings   map[ContentType]time.Duration `json:"average_timings"`
        ErrorCounts      map[ContentType]int64         `json:"error_counts"`
        CacheHits        int64                         `json:"cache_hits"`
        CacheMisses      int64                         `json:"cache_misses"`
        TotalGenerations int64                         `json:"total_generations"`
}

// NewGenerationMetrics creates a new metrics tracker
func NewGenerationMetrics() *GenerationMetrics <span class="cov8" title="1">{
        return &amp;GenerationMetrics{
                GenerationCounts: make(map[ContentType]int64),
                AverageTimings:   make(map[ContentType]time.Duration),
                ErrorCounts:      make(map[ContentType]int64),
        }
}</span>

// RecordGeneration records a successful generation
func (gm *GenerationMetrics) RecordGeneration(contentType ContentType, duration time.Duration) <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.GenerationCounts[contentType]++
        gm.TotalGenerations++

        // Update rolling average
        if current, exists := gm.AverageTimings[contentType]; exists </span><span class="cov8" title="1">{
                count := gm.GenerationCounts[contentType]
                gm.AverageTimings[contentType] = (current*time.Duration(count-1) + duration) / time.Duration(count)
        }</span> else<span class="cov8" title="1"> {
                gm.AverageTimings[contentType] = duration
        }</span>
}

// RecordError records a generation error
func (gm *GenerationMetrics) RecordError(contentType ContentType) <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.ErrorCounts[contentType]++
}</span>

// RecordCacheHit records a cache hit
func (gm *GenerationMetrics) RecordCacheHit() <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.CacheHits++
}</span>

// RecordCacheMiss records a cache miss
func (gm *GenerationMetrics) RecordCacheMiss() <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.CacheMisses++
}</span>

// GetStats returns current performance statistics
func (gm *GenerationMetrics) GetStats() map[string]interface{} <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        return map[string]interface{}{
                "generation_counts": gm.GenerationCounts,
                "average_timings":   gm.AverageTimings,
                "error_counts":      gm.ErrorCounts,
                "cache_hits":        gm.CacheHits,
                "cache_misses":      gm.CacheMisses,
                "total_generations": gm.TotalGenerations,
        }
}</span>

// GetGenerationCount returns the total generation count for a content type
func (gm *GenerationMetrics) GetGenerationCount(contentType ContentType) int64 <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        return gm.GenerationCounts[contentType]
}</span>

// GetAverageTiming returns the average generation time for a content type
func (gm *GenerationMetrics) GetAverageTiming(contentType ContentType) time.Duration <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        return gm.AverageTimings[contentType]
}</span>

// GetErrorCount returns the total error count for a content type
func (gm *GenerationMetrics) GetErrorCount(contentType ContentType) int64 <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        return gm.ErrorCounts[contentType]
}</span>

// GetCacheHitRatio returns the cache hit ratio as a percentage
func (gm *GenerationMetrics) GetCacheHitRatio() float64 <span class="cov8" title="1">{
        gm.mu.RLock()
        defer gm.mu.RUnlock()

        total := gm.CacheHits + gm.CacheMisses
        if total == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        <span class="cov8" title="1">return float64(gm.CacheHits) / float64(total) * 100.0</span>
}

// Reset clears all metrics data
func (gm *GenerationMetrics) Reset() <span class="cov8" title="1">{
        gm.mu.Lock()
        defer gm.mu.Unlock()

        gm.GenerationCounts = make(map[ContentType]int64)
        gm.AverageTimings = make(map[ContentType]time.Duration)
        gm.ErrorCounts = make(map[ContentType]int64)
        gm.CacheHits = 0
        gm.CacheMisses = 0
        gm.TotalGenerations = 0
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package pcg

import (
        "context"
        "fmt"
        "math/rand"
        "strings"
        "time"

        "github.com/sirupsen/logrus"
)

// NarrativeGenerator creates overarching storylines and campaign narratives
// Builds on existing quest narratives to create cohesive campaign stories
type NarrativeGenerator struct {
        version             string
        logger              *logrus.Logger
        rng                 *rand.Rand
        storyArchetypes     map[string]*StoryArchetype
        narrativeThemes     map[string]*NarrativeTheme
        characterArchetypes map[string]*CharacterArchetype
}

// CampaignNarrative represents a complete campaign storyline
type CampaignNarrative struct {
        ID           string                 `json:"id"`
        Title        string                 `json:"title"`
        Theme        string                 `json:"theme"`
        Setting      string                 `json:"setting"`
        MainPlotline *Plotline              `json:"main_plotline"`
        Subplots     []*Plotline            `json:"subplots"`
        NPCs         []*NarrativeCharacter  `json:"npcs"`
        KeyLocations []*NarrativeLocation   `json:"key_locations"`
        Timeline     []*StoryEvent          `json:"timeline"`
        Metadata     map[string]interface{} `json:"metadata"`
        Generated    time.Time              `json:"generated"`
}

// Plotline represents a story arc with beginning, middle, and end
type Plotline struct {
        ID         string                 `json:"id"`
        Title      string                 `json:"title"`
        Type       PlotType               `json:"type"`
        Acts       []*StoryAct            `json:"acts"`
        Characters []string               `json:"characters"`
        Locations  []string               `json:"locations"`
        Hooks      []string               `json:"hooks"`
        Climax     string                 `json:"climax"`
        Resolution string                 `json:"resolution"`
        Properties map[string]interface{} `json:"properties"`
}

// StoryAct represents a major section of a plotline
type StoryAct struct {
        ID          string                 `json:"id"`
        Title       string                 `json:"title"`
        Description string                 `json:"description"`
        Events      []*StoryEvent          `json:"events"`
        Objectives  []string               `json:"objectives"`
        Properties  map[string]interface{} `json:"properties"`
}

// StoryEvent represents a significant narrative moment
type StoryEvent struct {
        ID           string                 `json:"id"`
        Title        string                 `json:"title"`
        Description  string                 `json:"description"`
        Type         EventType              `json:"type"`
        Participants []string               `json:"participants"`
        Location     string                 `json:"location"`
        Trigger      string                 `json:"trigger"`
        Consequences []string               `json:"consequences"`
        Properties   map[string]interface{} `json:"properties"`
}

// NarrativeCharacter represents a key story character
type NarrativeCharacter struct {
        ID            string                 `json:"id"`
        Name          string                 `json:"name"`
        Archetype     string                 `json:"archetype"`
        Role          CharacterRole          `json:"role"`
        Motivation    string                 `json:"motivation"`
        Background    string                 `json:"background"`
        Personality   []string               `json:"personality"`
        Relationships map[string]string      `json:"relationships"`
        Arc           *CharacterArc          `json:"arc"`
        Properties    map[string]interface{} `json:"properties"`
}

// NarrativeLocation represents a key story location
type NarrativeLocation struct {
        ID           string                 `json:"id"`
        Name         string                 `json:"name"`
        Type         LocationType           `json:"type"`
        Description  string                 `json:"description"`
        Significance string                 `json:"significance"`
        History      string                 `json:"history"`
        Properties   map[string]interface{} `json:"properties"`
}

// CharacterArc represents a character's journey through the story
type CharacterArc struct {
        StartState     string   `json:"start_state"`
        Developments   []string `json:"developments"`
        Transformation string   `json:"transformation"`
        EndState       string   `json:"end_state"`
}

// Story template types for generation
type StoryArchetype struct {
        Name        string   `yaml:"name"`
        Description string   `yaml:"description"`
        Structure   []string `yaml:"structure"`
        Themes      []string `yaml:"themes"`
        Conflicts   []string `yaml:"conflicts"`
}

type NarrativeTheme struct {
        Name     string   `yaml:"name"`
        Tone     string   `yaml:"tone"`
        Motifs   []string `yaml:"motifs"`
        Symbols  []string `yaml:"symbols"`
        Messages []string `yaml:"messages"`
}

type CharacterArchetype struct {
        Name        string   `yaml:"name"`
        Description string   `yaml:"description"`
        Motivations []string `yaml:"motivations"`
        Traits      []string `yaml:"traits"`
        SpeechStyle []string `yaml:"speech_style"`
}

// Enums for story structure
type PlotType string

const (
        PlotTypeMain      PlotType = "main"
        PlotTypeSubplot   PlotType = "subplot"
        PlotTypeSideQuest PlotType = "side_quest"
        PlotTypePersonal  PlotType = "personal"
)

type EventType string

const (
        EventTypeEncounter  EventType = "encounter"
        EventTypeDiscovery  EventType = "discovery"
        EventTypeBetrayal   EventType = "betrayal"
        EventTypeRevelation EventType = "revelation"
        EventTypeConflict   EventType = "conflict"
        EventTypeResolution EventType = "resolution"
        EventTypeSacrifice  EventType = "sacrifice"
        EventTypeTransition EventType = "transition"
)

type CharacterRole string

const (
        RoleProtagonist  CharacterRole = "protagonist"
        RoleAntagonist   CharacterRole = "antagonist"
        RoleAlly         CharacterRole = "ally"
        RoleMentor       CharacterRole = "mentor"
        RoleGuardian     CharacterRole = "guardian"
        RoleHerald       CharacterRole = "herald"
        RoleTrickster    CharacterRole = "trickster"
        RoleShapeshifter CharacterRole = "shapeshifter"
)

type LocationType string

const (
        LocationHometown   LocationType = "hometown"
        LocationDungeon    LocationType = "dungeon"
        LocationCastle     LocationType = "castle"
        LocationWilderness LocationType = "wilderness"
        LocationCity       LocationType = "city"
        LocationShrine     LocationType = "shrine"
        LocationRuins      LocationType = "ruins"
        LocationPortal     LocationType = "portal"
)

// NewNarrativeGenerator creates a new narrative generator
func NewNarrativeGenerator(logger *logrus.Logger) *NarrativeGenerator <span class="cov8" title="1">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = logrus.New()
        }</span>

        <span class="cov8" title="1">ng := &amp;NarrativeGenerator{
                version:             "1.0.0",
                logger:              logger,
                rng:                 rand.New(rand.NewSource(time.Now().UnixNano())),
                storyArchetypes:     make(map[string]*StoryArchetype),
                narrativeThemes:     make(map[string]*NarrativeTheme),
                characterArchetypes: make(map[string]*CharacterArchetype),
        }

        ng.initializeTemplates()
        return ng</span>
}

// Generate creates a complete campaign narrative
func (ng *NarrativeGenerator) Generate(ctx context.Context, params GenerationParams) (interface{}, error) <span class="cov8" title="1">{
        narrativeParams, ok := params.Constraints["narrative_params"].(NarrativeParams)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid parameters for narrative generation: expected narrative_params in constraints")
        }</span>

        <span class="cov8" title="1">if err := ng.Validate(params); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("parameter validation failed: %w", err)
        }</span>

        // Initialize RNG with seed for deterministic generation
        <span class="cov8" title="1">ng.rng = rand.New(rand.NewSource(params.Seed))

        ng.logger.WithFields(logrus.Fields{
                "narrative_type": narrativeParams.NarrativeType,
                "theme":          narrativeParams.Theme,
                "length":         narrativeParams.CampaignLength,
        }).Info("generating campaign narrative")

        narrative, err := ng.generateCampaignNarrative(ctx, params, narrativeParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("narrative generation failed: %w", err)
        }</span>

        <span class="cov8" title="1">ng.logger.WithField("narrative_id", narrative.ID).Info("campaign narrative generation completed")
        return narrative, nil</span>
}

// generateCampaignNarrative creates the complete campaign story
func (ng *NarrativeGenerator) generateCampaignNarrative(ctx context.Context, params GenerationParams, narrativeParams NarrativeParams) (*CampaignNarrative, error) <span class="cov8" title="1">{
        // Select story archetype based on parameters
        archetype := ng.selectStoryArchetype(narrativeParams.Theme, narrativeParams.NarrativeType)
        theme := ng.selectNarrativeTheme(narrativeParams.Theme)

        narrative := &amp;CampaignNarrative{
                ID:           fmt.Sprintf("narrative_%d", ng.rng.Int63()),
                Title:        ng.generateTitle(archetype, theme),
                Theme:        narrativeParams.Theme,
                Setting:      ng.generateSetting(narrativeParams),
                Subplots:     make([]*Plotline, 0),
                NPCs:         make([]*NarrativeCharacter, 0),
                KeyLocations: make([]*NarrativeLocation, 0),
                Timeline:     make([]*StoryEvent, 0),
                Metadata:     make(map[string]interface{}),
                Generated:    time.Now(),
        }

        // Generate main plotline
        mainPlot, err := ng.generateMainPlotline(archetype, theme, narrativeParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate main plotline: %w", err)
        }</span>
        <span class="cov8" title="1">narrative.MainPlotline = mainPlot

        // Generate key characters
        narrative.NPCs = ng.generateKeyCharacters(mainPlot, narrativeParams)

        // Generate key locations
        narrative.KeyLocations = ng.generateKeyLocations(mainPlot, narrativeParams)

        // Generate subplots
        subplotCount := ng.calculateSubplotCount(narrativeParams.CampaignLength)
        for i := 0; i &lt; subplotCount; i++ </span><span class="cov8" title="1">{
                subplot := ng.generateSubplot(narrative.NPCs, narrative.KeyLocations, theme, narrativeParams)
                narrative.Subplots = append(narrative.Subplots, subplot)
        }</span>

        // Create timeline from all plot events
        <span class="cov8" title="1">narrative.Timeline = ng.createTimeline(narrative.MainPlotline, narrative.Subplots)

        // Add metadata
        narrative.Metadata["character_count"] = len(narrative.NPCs)
        narrative.Metadata["location_count"] = len(narrative.KeyLocations)
        narrative.Metadata["subplot_count"] = len(narrative.Subplots)
        narrative.Metadata["total_events"] = len(narrative.Timeline)

        return narrative, nil</span>
}

// generateMainPlotline creates the central story arc
func (ng *NarrativeGenerator) generateMainPlotline(archetype *StoryArchetype, theme *NarrativeTheme, params NarrativeParams) (*Plotline, error) <span class="cov8" title="1">{
        plotline := &amp;Plotline{
                ID:         "main_plot",
                Title:      ng.generatePlotTitle(archetype),
                Type:       PlotTypeMain,
                Acts:       make([]*StoryAct, 0),
                Characters: make([]string, 0),
                Locations:  make([]string, 0),
                Hooks:      ng.generatePlotHooks(archetype, theme),
                Properties: make(map[string]interface{}),
        }

        // Generate story acts based on campaign length
        actCount := ng.calculateActCount(params.CampaignLength)
        for i := 0; i &lt; actCount; i++ </span><span class="cov8" title="1">{
                act := ng.generateStoryAct(i, actCount, archetype, theme, params)
                plotline.Acts = append(plotline.Acts, act)
        }</span>

        // Generate climax and resolution
        <span class="cov8" title="1">plotline.Climax = ng.generateClimax(archetype, theme)
        plotline.Resolution = ng.generateResolution(archetype, theme)

        return plotline, nil</span>
}

// generateKeyCharacters creates important NPCs for the narrative
func (ng *NarrativeGenerator) generateKeyCharacters(mainPlot *Plotline, params NarrativeParams) []*NarrativeCharacter <span class="cov8" title="1">{
        characters := make([]*NarrativeCharacter, 0)

        // Generate protagonist (if NPC-focused campaign)
        if params.NarrativeType == NarrativeLinear || params.NarrativeType == NarrativeEpisodic </span><span class="cov8" title="1">{
                protagonist := ng.generateCharacter(RoleProtagonist, params)
                characters = append(characters, protagonist)
        }</span>

        // Generate antagonist
        <span class="cov8" title="1">antagonist := ng.generateCharacter(RoleAntagonist, params)
        characters = append(characters, antagonist)

        // Generate supporting characters based on campaign length
        supportingCount := ng.calculateSupportingCharacterCount(params.CampaignLength)
        supportingRoles := []CharacterRole{RoleAlly, RoleMentor, RoleGuardian, RoleHerald, RoleTrickster}

        for i := 0; i &lt; supportingCount; i++ </span><span class="cov8" title="1">{
                role := supportingRoles[i%len(supportingRoles)]
                character := ng.generateCharacter(role, params)
                characters = append(characters, character)
        }</span>

        <span class="cov8" title="1">return characters</span>
}

// generateCharacter creates a single narrative character
func (ng *NarrativeGenerator) generateCharacter(role CharacterRole, params NarrativeParams) *NarrativeCharacter <span class="cov8" title="1">{
        archetype := ng.selectCharacterArchetype(role)

        character := &amp;NarrativeCharacter{
                ID:            fmt.Sprintf("char_%d", ng.rng.Int63()),
                Name:          ng.generateCharacterName(archetype),
                Archetype:     archetype.Name,
                Role:          role,
                Motivation:    ng.selectRandom(archetype.Motivations),
                Background:    ng.generateCharacterBackground(archetype, params),
                Personality:   ng.selectMultipleRandom(archetype.Traits, 2, 4),
                Relationships: make(map[string]string),
                Properties:    make(map[string]interface{}),
        }

        // Generate character arc
        character.Arc = ng.generateCharacterArc(character, params)

        return character
}</span>

// Helper methods for generation

// initializeTemplates sets up the default story templates
func (ng *NarrativeGenerator) initializeTemplates() <span class="cov8" title="1">{
        // Story archetypes
        ng.storyArchetypes["hero_journey"] = &amp;StoryArchetype{
                Name:        "Hero's Journey",
                Description: "Classic hero's journey with call to adventure",
                Structure:   []string{"ordinary_world", "call_to_adventure", "refusal", "mentor", "threshold", "tests", "ordeal", "reward", "road_back", "resurrection", "return"},
                Themes:      []string{"growth", "sacrifice", "destiny"},
                Conflicts:   []string{"good_vs_evil", "order_vs_chaos", "individual_vs_society"},
        }

        ng.storyArchetypes["tragedy"] = &amp;StoryArchetype{
                Name:        "Tragedy",
                Description: "Downfall of protagonist due to fatal flaw",
                Structure:   []string{"exposition", "rising_action", "climax", "falling_action", "catastrophe"},
                Themes:      []string{"hubris", "fate", "justice"},
                Conflicts:   []string{"man_vs_self", "man_vs_fate", "corruption"},
        }

        ng.storyArchetypes["mystery"] = &amp;StoryArchetype{
                Name:        "Mystery",
                Description: "Investigation and revelation of hidden truth",
                Structure:   []string{"incident", "investigation", "clues", "red_herrings", "revelation", "resolution"},
                Themes:      []string{"truth", "justice", "hidden_knowledge"},
                Conflicts:   []string{"truth_vs_deception", "order_vs_chaos"},
        }

        // Narrative themes
        ng.narrativeThemes["classic"] = &amp;NarrativeTheme{
                Name:     "Classic Fantasy",
                Tone:     "heroic",
                Motifs:   []string{"ancient_prophecy", "magical_artifact", "dark_lord", "chosen_one"},
                Symbols:  []string{"sword", "crown", "tower", "dragon"},
                Messages: []string{"good_triumphs", "friendship_matters", "courage_conquers_fear"},
        }

        ng.narrativeThemes["grimdark"] = &amp;NarrativeTheme{
                Name:     "Grimdark",
                Tone:     "dark",
                Motifs:   []string{"corruption", "moral_ambiguity", "pyrrhic_victory", "survival"},
                Symbols:  []string{"broken_crown", "blood", "ravens", "ruins"},
                Messages: []string{"power_corrupts", "survival_at_any_cost", "hope_is_fleeting"},
        }

        // Character archetypes
        ng.characterArchetypes["noble_hero"] = &amp;CharacterArchetype{
                Name:        "Noble Hero",
                Description: "Honorable champion of justice",
                Motivations: []string{"protect_innocent", "uphold_justice", "fulfill_destiny"},
                Traits:      []string{"brave", "honorable", "selfless", "determined"},
                SpeechStyle: []string{"formal", "inspiring", "direct"},
        }

        ng.characterArchetypes["dark_lord"] = &amp;CharacterArchetype{
                Name:        "Dark Lord",
                Description: "Powerful evil ruler seeking dominion",
                Motivations: []string{"conquer_world", "gain_power", "spread_darkness"},
                Traits:      []string{"ruthless", "intelligent", "charismatic", "cruel"},
                SpeechStyle: []string{"commanding", "menacing", "eloquent"},
        }
}</span>

// selectStoryArchetype chooses appropriate story structure
func (ng *NarrativeGenerator) selectStoryArchetype(theme string, narrativeType NarrativeType) *StoryArchetype <span class="cov8" title="1">{
        // Simple selection based on theme - in a full implementation this would be more sophisticated
        switch theme </span>{
        case "classic":<span class="cov8" title="1">
                return ng.storyArchetypes["hero_journey"]</span>
        case "grimdark":<span class="cov8" title="1">
                return ng.storyArchetypes["tragedy"]</span>
        case "mystery":<span class="cov0" title="0">
                return ng.storyArchetypes["mystery"]</span>
        default:<span class="cov0" title="0">
                return ng.storyArchetypes["hero_journey"]</span>
        }
}

// selectNarrativeTheme chooses thematic elements
func (ng *NarrativeGenerator) selectNarrativeTheme(theme string) *NarrativeTheme <span class="cov8" title="1">{
        if narrativeTheme, exists := ng.narrativeThemes[theme]; exists </span><span class="cov8" title="1">{
                return narrativeTheme
        }</span>
        <span class="cov0" title="0">return ng.narrativeThemes["classic"]</span>
}

// selectCharacterArchetype chooses character template based on role
func (ng *NarrativeGenerator) selectCharacterArchetype(role CharacterRole) *CharacterArchetype <span class="cov8" title="1">{
        switch role </span>{
        case RoleProtagonist, RoleAlly:<span class="cov8" title="1">
                return ng.characterArchetypes["noble_hero"]</span>
        case RoleAntagonist:<span class="cov8" title="1">
                return ng.characterArchetypes["dark_lord"]</span>
        default:<span class="cov8" title="1">
                return ng.characterArchetypes["noble_hero"]</span>
        }
}

// Utility methods for random selection and generation
func (ng *NarrativeGenerator) selectRandom(items []string) string <span class="cov8" title="1">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return items[ng.rng.Intn(len(items))]</span>
}

func (ng *NarrativeGenerator) selectMultipleRandom(items []string, min, max int) []string <span class="cov8" title="1">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov8" title="1">count := min + ng.rng.Intn(max-min+1)
        if count &gt; len(items) </span><span class="cov0" title="0">{
                count = len(items)
        }</span>

        // Shuffle and take first count items
        <span class="cov8" title="1">shuffled := make([]string, len(items))
        copy(shuffled, items)

        for i := len(shuffled) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{
                j := ng.rng.Intn(i + 1)
                shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
        }</span>

        <span class="cov8" title="1">return shuffled[:count]</span>
}

// Generation helper methods (simplified implementations)
func (ng *NarrativeGenerator) generateTitle(archetype *StoryArchetype, theme *NarrativeTheme) string <span class="cov8" title="1">{
        prefixes := []string{"The", "Rise of", "Fall of", "Chronicles of", "Legend of"}
        subjects := theme.Symbols

        prefix := ng.selectRandom(prefixes)
        subject := ng.selectRandom(subjects)

        return fmt.Sprintf("%s %s", prefix, strings.Title(subject))
}</span>

func (ng *NarrativeGenerator) generateSetting(params NarrativeParams) string <span class="cov8" title="1">{
        settings := []string{
                "A realm torn by ancient conflicts",
                "A world where magic and technology clash",
                "A dying empire on the edge of collapse",
                "A frontier land full of mysteries",
                "A kingdom threatened by dark forces",
        }
        return ng.selectRandom(settings)
}</span>

func (ng *NarrativeGenerator) generatePlotTitle(archetype *StoryArchetype) string <span class="cov8" title="1">{
        return fmt.Sprintf("The %s", archetype.Name)
}</span>

func (ng *NarrativeGenerator) generatePlotHooks(archetype *StoryArchetype, theme *NarrativeTheme) []string <span class="cov8" title="1">{
        hooks := []string{
                fmt.Sprintf("Ancient %s surfaces with dark purpose", ng.selectRandom(theme.Symbols)),
                fmt.Sprintf("Mysterious events plague the land"),
                fmt.Sprintf("A %s emerges to challenge the status quo", ng.selectRandom(theme.Motifs)),
        }
        return hooks
}</span>

func (ng *NarrativeGenerator) generateClimax(archetype *StoryArchetype, theme *NarrativeTheme) string <span class="cov8" title="1">{
        climaxTemplates := []string{
                "Final confrontation with the %s",
                "Ultimate test of %s",
                "Revelation that changes everything",
        }
        template := ng.selectRandom(climaxTemplates)
        return fmt.Sprintf(template, ng.selectRandom(theme.Motifs))
}</span>

func (ng *NarrativeGenerator) generateResolution(archetype *StoryArchetype, theme *NarrativeTheme) string <span class="cov8" title="1">{
        return fmt.Sprintf("The realm finds %s", ng.selectRandom([]string{"peace", "balance", "new hope", "redemption"}))
}</span>

func (ng *NarrativeGenerator) generateCharacterName(archetype *CharacterArchetype) string <span class="cov8" title="1">{
        // Simple name generation - could be expanded with proper name libraries
        prefixes := []string{"Arath", "Drak", "Eld", "Grim", "Kael", "Mor", "Rath", "Thane", "Vel", "Zar"}
        suffixes := []string{"an", "as", "eth", "ion", "or", "us", "wyn", "dar", "rim", "ok"}

        return ng.selectRandom(prefixes) + ng.selectRandom(suffixes)
}</span>

func (ng *NarrativeGenerator) generateCharacterBackground(archetype *CharacterArchetype, params NarrativeParams) string <span class="cov8" title="1">{
        backgrounds := []string{
                fmt.Sprintf("A %s who seeks to %s", strings.ToLower(archetype.Name), ng.selectRandom(archetype.Motivations)),
                fmt.Sprintf("Born into %s, shaped by %s", "humble origins", "great trials"),
                fmt.Sprintf("Once %s, now %s", "a different person", "transformed by events"),
        }
        return ng.selectRandom(backgrounds)
}</span>

func (ng *NarrativeGenerator) generateCharacterArc(character *NarrativeCharacter, params NarrativeParams) *CharacterArc <span class="cov8" title="1">{
        return &amp;CharacterArc{
                StartState:     fmt.Sprintf("Begins as %s", strings.ToLower(character.Archetype)),
                Developments:   []string{"faces challenges", "learns hard truths", "makes difficult choices"},
                Transformation: "undergoes fundamental change",
                EndState:       "emerges transformed",
        }
}</span>

// Calculation methods
func (ng *NarrativeGenerator) calculateSubplotCount(length string) int <span class="cov8" title="1">{
        switch length </span>{
        case "short":<span class="cov8" title="1">
                return 1 + ng.rng.Intn(2)</span> // 1-2 subplots
        case "medium":<span class="cov8" title="1">
                return 2 + ng.rng.Intn(3)</span> // 2-4 subplots
        case "long":<span class="cov8" title="1">
                return 3 + ng.rng.Intn(4)</span> // 3-6 subplots
        default:<span class="cov0" title="0">
                return 2</span>
        }
}

func (ng *NarrativeGenerator) calculateActCount(length string) int <span class="cov8" title="1">{
        switch length </span>{
        case "short":<span class="cov8" title="1">
                return 3</span> // Classic 3-act structure
        case "medium":<span class="cov8" title="1">
                return 5</span> // Extended structure
        case "long":<span class="cov8" title="1">
                return 7</span> // Epic structure
        default:<span class="cov0" title="0">
                return 3</span>
        }
}

func (ng *NarrativeGenerator) calculateSupportingCharacterCount(length string) int <span class="cov8" title="1">{
        switch length </span>{
        case "short":<span class="cov8" title="1">
                return 2 + ng.rng.Intn(2)</span> // 2-3 characters
        case "medium":<span class="cov8" title="1">
                return 3 + ng.rng.Intn(3)</span> // 3-5 characters
        case "long":<span class="cov8" title="1">
                return 4 + ng.rng.Intn(4)</span> // 4-7 characters
        default:<span class="cov0" title="0">
                return 3</span>
        }
}

// Stub methods that would be fully implemented
func (ng *NarrativeGenerator) generateStoryAct(index, total int, archetype *StoryArchetype, theme *NarrativeTheme, params NarrativeParams) *StoryAct <span class="cov8" title="1">{
        return &amp;StoryAct{
                ID:          fmt.Sprintf("act_%d", index+1),
                Title:       fmt.Sprintf("Act %d", index+1),
                Description: fmt.Sprintf("Story development phase %d", index+1),
                Events:      make([]*StoryEvent, 0),
                Objectives:  []string{fmt.Sprintf("Complete act %d objectives", index+1)},
                Properties:  make(map[string]interface{}),
        }
}</span>

func (ng *NarrativeGenerator) generateKeyLocations(mainPlot *Plotline, params NarrativeParams) []*NarrativeLocation <span class="cov8" title="1">{
        locations := make([]*NarrativeLocation, 0)
        locationTypes := []LocationType{LocationHometown, LocationDungeon, LocationCastle, LocationWilderness}

        for i, locType := range locationTypes </span><span class="cov8" title="1">{
                location := &amp;NarrativeLocation{
                        ID:           fmt.Sprintf("loc_%d", i),
                        Name:         ng.generateLocationName(locType),
                        Type:         locType,
                        Description:  fmt.Sprintf("A significant %s in the story", string(locType)),
                        Significance: "Important to the main plot",
                        History:      "Has a rich and troubled past",
                        Properties:   make(map[string]interface{}),
                }
                locations = append(locations, location)
        }</span>

        <span class="cov8" title="1">return locations</span>
}

func (ng *NarrativeGenerator) generateLocationName(locType LocationType) string <span class="cov8" title="1">{
        prefixes := map[LocationType][]string{
                LocationHometown:   {"Green", "Old", "Fair", "New"},
                LocationDungeon:    {"Dark", "Forgotten", "Ancient", "Lost"},
                LocationCastle:     {"High", "Storm", "Iron", "Golden"},
                LocationWilderness: {"Whispering", "Shadow", "Endless", "Wild"},
        }

        suffixes := map[LocationType][]string{
                LocationHometown:   {"haven", "bridge", "ford", "vale"},
                LocationDungeon:    {"depths", "halls", "caverns", "maze"},
                LocationCastle:     {"keep", "tower", "citadel", "fortress"},
                LocationWilderness: {"woods", "plains", "marsh", "peaks"},
        }

        prefix := ng.selectRandom(prefixes[locType])
        suffix := ng.selectRandom(suffixes[locType])

        return fmt.Sprintf("%s %s", prefix, strings.Title(suffix))
}</span>

func (ng *NarrativeGenerator) generateSubplot(characters []*NarrativeCharacter, locations []*NarrativeLocation, theme *NarrativeTheme, params NarrativeParams) *Plotline <span class="cov8" title="1">{
        return &amp;Plotline{
                ID:         fmt.Sprintf("subplot_%d", ng.rng.Int63()),
                Title:      "Character Subplot",
                Type:       PlotTypeSubplot,
                Acts:       make([]*StoryAct, 0),
                Characters: []string{ng.selectRandom([]string{"character1", "character2"})},
                Locations:  []string{ng.selectRandom([]string{"location1", "location2"})},
                Hooks:      []string{"Personal conflict emerges"},
                Climax:     "Personal resolution",
                Resolution: "Character growth achieved",
                Properties: make(map[string]interface{}),
        }
}</span>

func (ng *NarrativeGenerator) createTimeline(mainPlot *Plotline, subplots []*Plotline) []*StoryEvent <span class="cov8" title="1">{
        events := make([]*StoryEvent, 0)

        // Add main plot events
        for i, act := range mainPlot.Acts </span><span class="cov8" title="1">{
                event := &amp;StoryEvent{
                        ID:           fmt.Sprintf("main_event_%d", i),
                        Title:        act.Title,
                        Description:  act.Description,
                        Type:         EventTypeTransition,
                        Participants: []string{"protagonist"},
                        Location:     "various",
                        Trigger:      "story progression",
                        Consequences: []string{"plot advancement"},
                        Properties:   make(map[string]interface{}),
                }
                events = append(events, event)
        }</span>

        <span class="cov8" title="1">return events</span>
}

// Interface compliance methods

// GetType returns the content type this generator produces
func (ng *NarrativeGenerator) GetType() ContentType <span class="cov8" title="1">{
        return ContentTypeNarrative
}</span>

// GetVersion returns the generator version
func (ng *NarrativeGenerator) GetVersion() string <span class="cov8" title="1">{
        return ng.version
}</span>

// Validate checks if the provided parameters are valid
func (ng *NarrativeGenerator) Validate(params GenerationParams) error <span class="cov8" title="1">{
        narrativeParams, ok := params.Constraints["narrative_params"].(NarrativeParams)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid parameters: expected narrative_params in constraints")
        }</span>

        <span class="cov8" title="1">validLengths := []string{"short", "medium", "long"}
        validLength := false
        for _, length := range validLengths </span><span class="cov8" title="1">{
                if narrativeParams.CampaignLength == length </span><span class="cov8" title="1">{
                        validLength = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !validLength </span><span class="cov8" title="1">{
                return fmt.Errorf("campaign length must be one of: %v, got %s", validLengths, narrativeParams.CampaignLength)
        }</span>

        <span class="cov8" title="1">if narrativeParams.Theme == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("theme cannot be empty")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package pcg

import (
        "context"
        "fmt"
        "math/rand"
        "strings"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// QuestGeneratorImpl implements the QuestGenerator interface for procedural quest creation
// Creates engaging quests with varied objectives, balanced rewards, and meaningful narrative context
type QuestGeneratorImpl struct {
        version string
        logger  *logrus.Logger
        rng     *rand.Rand
}

// NewQuestGenerator creates a new quest generator instance
func NewQuestGenerator(logger *logrus.Logger) *QuestGeneratorImpl <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                logger = logrus.New()
        }</span>

        <span class="cov8" title="1">return &amp;QuestGeneratorImpl{
                version: "1.0.0",
                logger:  logger,
                rng:     rand.New(rand.NewSource(time.Now().UnixNano())),
        }</span>
}

// Generate creates quests based on the provided parameters
// Returns generated quests with complete objectives and balanced rewards
func (qg *QuestGeneratorImpl) Generate(ctx context.Context, params GenerationParams) (interface{}, error) <span class="cov8" title="1">{
        if err := qg.Validate(params); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid parameters: %w", err)
        }</span>

        // Use seed for deterministic generation
        <span class="cov8" title="1">rng := rand.New(rand.NewSource(params.Seed))
        qg.rng = rng

        questParams, ok := params.Constraints["quest_params"].(QuestParams)
        if !ok </span><span class="cov8" title="1">{
                // Use default parameters
                questParams = QuestParams{
                        GenerationParams: params,
                        QuestType:        QuestTypeFetch, // Default to fetch quest
                        MinObjectives:    1,
                        MaxObjectives:    3,
                        RewardTier:       RarityCommon,
                        Narrative:        NarrativeLinear,
                }
        }</span>

        // Generate single quest
        <span class="cov8" title="1">quest, err := qg.GenerateQuest(ctx, questParams.QuestType, questParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate quest: %w", err)
        }</span>

        <span class="cov8" title="1">qg.logger.WithFields(logrus.Fields{
                "quest_id":   quest.ID,
                "quest_type": questParams.QuestType,
                "objectives": len(quest.Objectives),
                "rewards":    len(quest.Rewards),
        }).Info("Generated quest successfully")

        return quest, nil</span>
}

// GenerateQuest creates a single quest with the specified type and parameters
func (qg *QuestGeneratorImpl) GenerateQuest(ctx context.Context, questType QuestType, params QuestParams) (*game.Quest, error) <span class="cov8" title="1">{
        // Validate context
        if ctx.Err() != nil </span><span class="cov8" title="1">{
                return nil, ctx.Err()
        }</span>

        // Generate unique quest ID
        <span class="cov8" title="1">questID := qg.generateQuestID(questType)

        // Generate quest title and description based on type
        title, description := qg.generateQuestNarrative(questType, params)

        // Generate objectives
        objectives, err := qg.GenerateObjectives(ctx, params.WorldState, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate objectives: %w", err)
        }</span>

        // Convert QuestObjective to game.QuestObjective
        <span class="cov8" title="1">gameObjectives := make([]game.QuestObjective, len(objectives))
        for i, obj := range objectives </span><span class="cov8" title="1">{
                gameObjectives[i] = game.QuestObjective{
                        Description: obj.Description,
                        Progress:    obj.Progress,
                        Required:    obj.Quantity,
                        Completed:   obj.Complete,
                }
        }</span>

        // Generate rewards
        <span class="cov8" title="1">rewards := qg.generateRewards(questType, params)

        quest := &amp;game.Quest{
                ID:          questID,
                Title:       title,
                Description: description,
                Status:      game.QuestNotStarted,
                Objectives:  gameObjectives,
                Rewards:     rewards,
        }

        return quest, nil</span>
}

// GenerateQuestChain creates a series of connected quests
func (qg *QuestGeneratorImpl) GenerateQuestChain(ctx context.Context, chainLength int, params QuestParams) ([]*game.Quest, error) <span class="cov8" title="1">{
        if chainLength &lt;= 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("chain length must be positive, got %d", chainLength)
        }</span>

        <span class="cov8" title="1">quests := make([]*game.Quest, 0, chainLength)
        baseParams := params

        for i := 0; i &lt; chainLength; i++ </span><span class="cov8" title="1">{
                // Vary quest types in chain for diversity
                questType := qg.selectQuestTypeForChain(i, chainLength)

                // Adjust difficulty and rewards based on position in chain
                chainParams := baseParams
                chainParams.Difficulty = baseParams.Difficulty + i
                chainParams.PlayerLevel = baseParams.PlayerLevel + (i / 2) // Gradual level scaling

                // Modify seed for each quest while maintaining determinism
                chainParams.Seed = baseParams.Seed + int64(i*1000)

                quest, err := qg.GenerateQuest(ctx, questType, chainParams)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate quest %d in chain: %w", i+1, err)
                }</span>

                // Modify quest title to indicate chain position
                <span class="cov8" title="1">if chainLength &gt; 1 </span><span class="cov8" title="1">{
                        quest.Title = fmt.Sprintf("%s (Part %d)", quest.Title, i+1)
                }</span>

                <span class="cov8" title="1">quests = append(quests, quest)</span>
        }

        <span class="cov8" title="1">qg.logger.WithFields(logrus.Fields{
                "chain_length": chainLength,
                "base_seed":    baseParams.Seed,
        }).Info("Generated quest chain successfully")

        return quests, nil</span>
}

// GenerateObjectives creates quest objectives based on available content
func (qg *QuestGeneratorImpl) GenerateObjectives(ctx context.Context, world *game.World, params QuestParams) ([]QuestObjective, error) <span class="cov8" title="1">{
        objectiveCount := qg.rng.Intn(params.MaxObjectives-params.MinObjectives+1) + params.MinObjectives
        objectives := make([]QuestObjective, 0, objectiveCount)

        for i := 0; i &lt; objectiveCount; i++ </span><span class="cov8" title="1">{
                objType := qg.selectObjectiveType(params.QuestType)
                objective := qg.generateSingleObjective(objType, params, i)
                objectives = append(objectives, objective)
        }</span>

        <span class="cov8" title="1">return objectives, nil</span>
}

// GetType returns the content type this generator produces
func (qg *QuestGeneratorImpl) GetType() ContentType <span class="cov8" title="1">{
        return ContentTypeQuests
}</span>

// GetVersion returns the generator version for compatibility checking
func (qg *QuestGeneratorImpl) GetVersion() string <span class="cov8" title="1">{
        return qg.version
}</span>

// Validate checks if the provided parameters are valid for this generator
func (qg *QuestGeneratorImpl) Validate(params GenerationParams) error <span class="cov8" title="1">{
        if params.Seed == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("seed must be non-zero")
        }</span>

        <span class="cov8" title="1">if params.Difficulty &lt; 1 || params.Difficulty &gt; 20 </span><span class="cov8" title="1">{
                return fmt.Errorf("difficulty must be between 1 and 20, got %d", params.Difficulty)
        }</span>

        <span class="cov8" title="1">if params.PlayerLevel &lt; 1 || params.PlayerLevel &gt; 20 </span><span class="cov8" title="1">{
                return fmt.Errorf("player level must be between 1 and 20, got %d", params.PlayerLevel)
        }</span>

        // Validate quest-specific parameters if provided
        <span class="cov8" title="1">if questParams, ok := params.Constraints["quest_params"].(QuestParams); ok </span><span class="cov8" title="1">{
                if err := qg.validateQuestParams(questParams); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid quest parameters: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateQuestParams validates quest-specific parameters
func (qg *QuestGeneratorImpl) validateQuestParams(params QuestParams) error <span class="cov8" title="1">{
        if params.MinObjectives &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("min objectives must be at least 1, got %d", params.MinObjectives)
        }</span>

        <span class="cov8" title="1">if params.MaxObjectives &lt; params.MinObjectives </span><span class="cov8" title="1">{
                return fmt.Errorf("max objectives (%d) must be &gt;= min objectives (%d)", params.MaxObjectives, params.MinObjectives)
        }</span>

        <span class="cov8" title="1">if params.MaxObjectives &gt; 10 </span><span class="cov8" title="1">{
                return fmt.Errorf("max objectives cannot exceed 10, got %d", params.MaxObjectives)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// generateQuestID creates a unique identifier for the quest
func (qg *QuestGeneratorImpl) generateQuestID(questType QuestType) string <span class="cov8" title="1">{
        timestamp := time.Now().Unix()
        randomSuffix := qg.rng.Intn(10000)
        return fmt.Sprintf("quest_%s_%d_%04d", questType, timestamp, randomSuffix)
}</span>

// generateQuestNarrative creates title and description based on quest type
func (qg *QuestGeneratorImpl) generateQuestNarrative(questType QuestType, params QuestParams) (string, string) <span class="cov8" title="1">{
        templates := qg.getQuestTemplates(questType)
        template := templates[qg.rng.Intn(len(templates))]

        // Apply narrative style modifications
        switch params.Narrative </span>{
        case NarrativeBranching:<span class="cov8" title="1">
                template.Description += " Multiple paths to completion are available."</span>
        case NarrativeOpen:<span class="cov0" title="0">
                template.Description += " Approach this challenge however you see fit."</span>
        case NarrativeEpisodic:<span class="cov0" title="0">
                template.Description += " This is part of a larger ongoing story."</span>
        }

        <span class="cov8" title="1">return template.Title, template.Description</span>
}

// questTemplate represents a template for quest narrative generation
type questTemplate struct {
        Title       string
        Description string
}

// getQuestTemplates returns narrative templates for each quest type
func (qg *QuestGeneratorImpl) getQuestTemplates(questType QuestType) []questTemplate <span class="cov8" title="1">{
        switch questType </span>{
        case QuestTypeFetch:<span class="cov8" title="1">
                return []questTemplate{
                        {
                                Title:       "The Missing Artifact",
                                Description: "A valuable artifact has gone missing and needs to be recovered. Search the area and bring it back safely.",
                        },
                        {
                                Title:       "Gathering Supplies",
                                Description: "Local merchants need specific items gathered from the wilderness. Collect the required materials and return them.",
                        },
                        {
                                Title:       "The Lost Heirloom",
                                Description: "A family heirloom has been lost in dangerous territory. Retrieve it and return it to its rightful owners.",
                        },
                }</span>
        case QuestTypeKill:<span class="cov8" title="1">
                return []questTemplate{
                        {
                                Title:       "Monster Extermination",
                                Description: "Dangerous creatures threaten the local area. Eliminate the specified targets to restore safety.",
                        },
                        {
                                Title:       "Bandit Elimination",
                                Description: "A group of bandits has been terrorizing travelers. Hunt them down and put an end to their activities.",
                        },
                        {
                                Title:       "The Corrupted Beast",
                                Description: "A once-peaceful creature has been corrupted by dark magic. Put it out of its misery to restore balance.",
                        },
                }</span>
        case QuestTypeEscort:<span class="cov8" title="1">
                return []questTemplate{
                        {
                                Title:       "Safe Passage",
                                Description: "An important individual needs safe escort through dangerous territory. Protect them during the journey.",
                        },
                        {
                                Title:       "Merchant Caravan",
                                Description: "A merchant caravan requires protection from bandits and monsters. Ensure they reach their destination safely.",
                        },
                        {
                                Title:       "The Diplomatic Mission",
                                Description: "An ambassador needs protection while traveling to negotiate peace. Guard them against any threats.",
                        },
                }</span>
        case QuestTypeExplore:<span class="cov8" title="1">
                return []questTemplate{
                        {
                                Title:       "Uncharted Territory",
                                Description: "An unexplored region needs to be mapped and surveyed. Document the area and report your findings.",
                        },
                        {
                                Title:       "The Ancient Ruins",
                                Description: "Mysterious ruins have been discovered nearby. Explore them and uncover their secrets.",
                        },
                        {
                                Title:       "Scouting Mission",
                                Description: "Intelligence is needed about enemy movements in the area. Scout the region and gather information.",
                        },
                }</span>
        case QuestTypeDefend:<span class="cov8" title="1">
                return []questTemplate{
                        {
                                Title:       "Hold the Line",
                                Description: "Enemy forces are approaching the settlement. Organize defenses and repel the attack.",
                        },
                        {
                                Title:       "Protecting the Innocent",
                                Description: "Civilians are in danger from an imminent threat. Establish a defensive perimeter and keep them safe.",
                        },
                        {
                                Title:       "The Last Stand",
                                Description: "The final battle approaches. Make your stand and protect everything you hold dear.",
                        },
                }</span>
        case QuestTypePuzzle:<span class="cov8" title="1">
                return []questTemplate{
                        {
                                Title:       "The Ancient Riddle",
                                Description: "An ancient puzzle blocks progress deeper into mysterious ruins. Solve the riddle to proceed.",
                        },
                        {
                                Title:       "The Locked Door",
                                Description: "A complex mechanism bars the way forward. Decipher the pattern and unlock the passage.",
                        },
                        {
                                Title:       "The Scholar's Challenge",
                                Description: "A learned sage has posed an intellectual challenge. Use wit and wisdom to find the solution.",
                        },
                }</span>
        case QuestTypeDelivery:<span class="cov8" title="1">
                return []questTemplate{
                        {
                                Title:       "Urgent Message",
                                Description: "Time-sensitive information must be delivered to its destination. Ensure the message arrives intact.",
                        },
                        {
                                Title:       "Supply Run",
                                Description: "Critical supplies need to be transported to an outpost. Deliver them before they're desperately needed.",
                        },
                        {
                                Title:       "The Secret Package",
                                Description: "A mysterious package requires discrete delivery. Transport it safely without asking questions.",
                        },
                }</span>
        case QuestTypeSurvival:<span class="cov8" title="1">
                return []questTemplate{
                        {
                                Title:       "Against the Elements",
                                Description: "Harsh conditions threaten survival in the wilderness. Endure the challenges and emerge victorious.",
                        },
                        {
                                Title:       "The Gauntlet",
                                Description: "Navigate through a series of deadly traps and hazards. Only the skilled and careful will survive.",
                        },
                        {
                                Title:       "Endurance Test",
                                Description: "Prove your resilience by surviving in hostile territory for a specified duration.",
                        },
                }</span>
        case QuestTypeStory:<span class="cov8" title="1">
                return []questTemplate{
                        {
                                Title:       "The Hero's Journey",
                                Description: "Embark on an epic adventure that will test your courage, wisdom, and strength. The fate of many depends on your choices.",
                        },
                        {
                                Title:       "Unraveling the Mystery",
                                Description: "Strange events have been occurring in the region. Investigate the truth behind the mysterious happenings.",
                        },
                        {
                                Title:       "The Path of Destiny",
                                Description: "Ancient prophecies speak of a chosen one. Discover if you are the one destined to fulfill this role.",
                        },
                }</span>
        default:<span class="cov0" title="0">
                return []questTemplate{
                        {
                                Title:       "Unknown Task",
                                Description: "A mysterious task awaits completion. The details will become clear as you progress.",
                        },
                }</span>
        }
}

// selectQuestTypeForChain chooses appropriate quest types for quest chains
func (qg *QuestGeneratorImpl) selectQuestTypeForChain(position, totalLength int) QuestType <span class="cov8" title="1">{
        questTypes := []QuestType{
                QuestTypeFetch, QuestTypeKill, QuestTypeEscort,
                QuestTypeExplore, QuestTypeDefend, QuestTypeDelivery,
        }

        // First quest should be engaging but not too difficult
        if position == 0 </span><span class="cov8" title="1">{
                simpleTypes := []QuestType{QuestTypeFetch, QuestTypeDelivery, QuestTypeExplore}
                return simpleTypes[qg.rng.Intn(len(simpleTypes))]
        }</span>

        // Final quest should be climactic
        <span class="cov8" title="1">if position == totalLength-1 </span><span class="cov8" title="1">{
                climacticTypes := []QuestType{QuestTypeKill, QuestTypeDefend, QuestTypeStory}
                return climacticTypes[qg.rng.Intn(len(climacticTypes))]
        }</span>

        // Middle quests can be any type
        <span class="cov8" title="1">return questTypes[qg.rng.Intn(len(questTypes))]</span>
}

// selectObjectiveType chooses objective types appropriate for the quest type
func (qg *QuestGeneratorImpl) selectObjectiveType(questType QuestType) string <span class="cov8" title="1">{
        switch questType </span>{
        case QuestTypeFetch:<span class="cov8" title="1">
                types := []string{"collect", "retrieve", "gather"}
                return types[qg.rng.Intn(len(types))]</span>
        case QuestTypeKill:<span class="cov8" title="1">
                types := []string{"eliminate", "defeat", "slay"}
                return types[qg.rng.Intn(len(types))]</span>
        case QuestTypeEscort:<span class="cov8" title="1">
                types := []string{"protect", "escort", "guard"}
                return types[qg.rng.Intn(len(types))]</span>
        case QuestTypeExplore:<span class="cov8" title="1">
                types := []string{"explore", "map", "discover"}
                return types[qg.rng.Intn(len(types))]</span>
        case QuestTypeDefend:<span class="cov8" title="1">
                types := []string{"defend", "protect", "hold"}
                return types[qg.rng.Intn(len(types))]</span>
        case QuestTypePuzzle:<span class="cov8" title="1">
                types := []string{"solve", "decipher", "unlock"}
                return types[qg.rng.Intn(len(types))]</span>
        case QuestTypeDelivery:<span class="cov8" title="1">
                types := []string{"deliver", "transport", "carry"}
                return types[qg.rng.Intn(len(types))]</span>
        case QuestTypeSurvival:<span class="cov8" title="1">
                types := []string{"survive", "endure", "withstand"}
                return types[qg.rng.Intn(len(types))]</span>
        case QuestTypeStory:<span class="cov8" title="1">
                types := []string{"investigate", "discover", "uncover"}
                return types[qg.rng.Intn(len(types))]</span>
        default:<span class="cov8" title="1">
                return "complete"</span>
        }
}

// generateSingleObjective creates a single quest objective
func (qg *QuestGeneratorImpl) generateSingleObjective(objType string, params QuestParams, index int) QuestObjective <span class="cov8" title="1">{
        // Generate quantity based on difficulty and player level
        quantity := qg.calculateObjectiveQuantity(params, objType)

        // Generate target based on objective type
        target := qg.generateObjectiveTarget(objType, params)

        // Create description
        description := qg.generateObjectiveDescription(objType, target, quantity)

        return QuestObjective{
                ID:          fmt.Sprintf("obj_%d_%s", index+1, objType),
                Type:        objType,
                Description: description,
                Target:      target,
                Quantity:    quantity,
                Progress:    0,
                Complete:    false,
                Optional:    qg.shouldBeOptional(index, params),
                Conditions:  make(map[string]interface{}),
        }
}</span>

// calculateObjectiveQuantity determines how many items/enemies/etc are needed
func (qg *QuestGeneratorImpl) calculateObjectiveQuantity(params QuestParams, objType string) int <span class="cov8" title="1">{
        baseQuantities := map[string]int{
                "collect":     3,
                "eliminate":   2,
                "escort":      1,
                "explore":     1,
                "defend":      1,
                "deliver":     1,
                "solve":       1,
                "survive":     1,
                "investigate": 1,
        }

        baseQuantity, exists := baseQuantities[objType]
        if !exists </span><span class="cov8" title="1">{
                baseQuantity = 1
        }</span>

        // Scale based on difficulty and player level
        <span class="cov8" title="1">scalingFactor := 1.0 + (float64(params.Difficulty-1) * 0.1) + (float64(params.PlayerLevel-1) * 0.05)
        scaledQuantity := int(float64(baseQuantity) * scalingFactor)

        // Add some randomization
        variation := qg.rng.Intn(scaledQuantity/2 + 1)
        finalQuantity := scaledQuantity + variation

        // Ensure minimum of 1
        if finalQuantity &lt; 1 </span><span class="cov8" title="1">{
                finalQuantity = 1
        }</span>

        <span class="cov8" title="1">return finalQuantity</span>
}

// generateObjectiveTarget creates appropriate targets for objectives
func (qg *QuestGeneratorImpl) generateObjectiveTarget(objType string, params QuestParams) string <span class="cov8" title="1">{
        switch objType </span>{
        case "collect", "retrieve", "gather":<span class="cov8" title="1">
                items := []string{"ancient coins", "magical herbs", "crystal shards", "rare gems", "lost scrolls"}
                return items[qg.rng.Intn(len(items))]</span>
        case "eliminate", "defeat", "slay":<span class="cov8" title="1">
                enemies := []string{"bandits", "goblins", "wolves", "corrupted beasts", "undead"}
                return enemies[qg.rng.Intn(len(enemies))]</span>
        case "protect", "escort", "guard":<span class="cov8" title="1">
                targets := []string{"merchant", "diplomat", "scholar", "refugee", "noble"}
                return targets[qg.rng.Intn(len(targets))]</span>
        case "explore", "map", "discover":<span class="cov8" title="1">
                locations := []string{"ancient ruins", "hidden caves", "forbidden forest", "mountain pass", "abandoned village"}
                return locations[qg.rng.Intn(len(locations))]</span>
        case "defend", "hold":<span class="cov8" title="1">
                places := []string{"village", "outpost", "bridge", "gate", "sanctuary"}
                return places[qg.rng.Intn(len(places))]</span>
        case "deliver", "transport", "carry":<span class="cov8" title="1">
                items := []string{"important message", "medical supplies", "ancient artifact", "diplomatic papers", "sacred relic"}
                return items[qg.rng.Intn(len(items))]</span>
        case "solve", "decipher", "unlock":<span class="cov8" title="1">
                puzzles := []string{"ancient riddle", "magical lock", "cipher text", "mystic pattern", "forgotten language"}
                return puzzles[qg.rng.Intn(len(puzzles))]</span>
        default:<span class="cov8" title="1">
                return "unknown target"</span>
        }
}

// generateObjectiveDescription creates human-readable objective descriptions
func (qg *QuestGeneratorImpl) generateObjectiveDescription(objType, target string, quantity int) string <span class="cov8" title="1">{
        switch objType </span>{
        case "collect", "retrieve", "gather":<span class="cov8" title="1">
                if quantity == 1 </span><span class="cov8" title="1">{
                        return fmt.Sprintf("Collect %s", target)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("Collect %d %s", quantity, target)</span>
        case "eliminate", "defeat", "slay":<span class="cov8" title="1">
                if quantity == 1 </span><span class="cov8" title="1">{
                        return fmt.Sprintf("Defeat the %s", strings.TrimSuffix(target, "s"))
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("Defeat %d %s", quantity, target)</span>
        case "protect", "escort", "guard":<span class="cov8" title="1">
                return fmt.Sprintf("Safely escort the %s", target)</span>
        case "explore", "map", "discover":<span class="cov8" title="1">
                return fmt.Sprintf("Explore the %s", target)</span>
        case "defend", "hold":<span class="cov8" title="1">
                return fmt.Sprintf("Defend the %s", target)</span>
        case "deliver", "transport", "carry":<span class="cov8" title="1">
                return fmt.Sprintf("Deliver the %s", target)</span>
        case "solve", "decipher", "unlock":<span class="cov8" title="1">
                return fmt.Sprintf("Solve the %s", target)</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("Complete objective involving %s", target)</span>
        }
}

// shouldBeOptional determines if an objective should be optional
func (qg *QuestGeneratorImpl) shouldBeOptional(index int, params QuestParams) bool <span class="cov8" title="1">{
        // First objective is never optional
        if index == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // 20% chance for objectives beyond the first to be optional
        <span class="cov8" title="1">return qg.rng.Float64() &lt; 0.2</span>
}

// generateRewards creates appropriate rewards for the quest
func (qg *QuestGeneratorImpl) generateRewards(questType QuestType, params QuestParams) []game.QuestReward <span class="cov8" title="1">{
        rewards := make([]game.QuestReward, 0, 3)

        // Always include experience reward
        expReward := qg.calculateExperienceReward(params)
        rewards = append(rewards, game.QuestReward{
                Type:  "exp",
                Value: expReward,
        })

        // Usually include gold reward
        if qg.rng.Float64() &lt; 0.8 </span><span class="cov8" title="1">{
                goldReward := qg.calculateGoldReward(params)
                rewards = append(rewards, game.QuestReward{
                        Type:  "gold",
                        Value: goldReward,
                })
        }</span>

        // Chance for item reward based on quest type and reward tier
        <span class="cov8" title="1">if qg.shouldIncludeItemReward(questType, params) </span><span class="cov8" title="1">{
                itemReward := qg.generateItemReward(params)
                rewards = append(rewards, itemReward)
        }</span>

        <span class="cov8" title="1">return rewards</span>
}

// calculateExperienceReward determines experience points for quest completion
func (qg *QuestGeneratorImpl) calculateExperienceReward(params QuestParams) int <span class="cov8" title="1">{
        baseExp := 100
        difficultyMultiplier := float64(params.Difficulty) * 0.5
        levelScaling := float64(params.PlayerLevel) * 1.2

        totalExp := int(float64(baseExp) * (1.0 + difficultyMultiplier + levelScaling))

        // Add some randomization
        variation := qg.rng.Intn(totalExp/4 + 1)
        return totalExp + variation
}</span>

// calculateGoldReward determines gold reward for quest completion
func (qg *QuestGeneratorImpl) calculateGoldReward(params QuestParams) int <span class="cov8" title="1">{
        baseGold := 50
        difficultyMultiplier := float64(params.Difficulty) * 0.3
        levelScaling := float64(params.PlayerLevel) * 0.8

        totalGold := int(float64(baseGold) * (1.0 + difficultyMultiplier + levelScaling))

        // Add some randomization
        variation := qg.rng.Intn(totalGold/3 + 1)
        return totalGold + variation
}</span>

// shouldIncludeItemReward determines if quest should have item rewards
func (qg *QuestGeneratorImpl) shouldIncludeItemReward(questType QuestType, params QuestParams) bool <span class="cov8" title="1">{
        // Higher tier quests more likely to have item rewards
        baseProbability := 0.3

        switch params.RewardTier </span>{
        case RarityUncommon:<span class="cov8" title="1">
                baseProbability = 0.5</span>
        case RarityRare:<span class="cov8" title="1">
                baseProbability = 0.7</span>
        case RarityEpic:<span class="cov0" title="0">
                baseProbability = 0.85</span>
        case RarityLegendary:<span class="cov8" title="1">
                baseProbability = 0.95</span>
        }

        // Some quest types more likely to have items
        <span class="cov8" title="1">switch questType </span>{
        case QuestTypeFetch, QuestTypeKill:<span class="cov8" title="1">
                baseProbability += 0.2</span>
        case QuestTypeStory:<span class="cov8" title="1">
                baseProbability += 0.3</span>
        }

        <span class="cov8" title="1">return qg.rng.Float64() &lt; baseProbability</span>
}

// generateItemReward creates an item reward for the quest
func (qg *QuestGeneratorImpl) generateItemReward(params QuestParams) game.QuestReward <span class="cov8" title="1">{
        // Generate a generic item ID based on reward tier
        itemTypes := []string{"sword", "armor", "ring", "potion", "scroll"}
        itemType := itemTypes[qg.rng.Intn(len(itemTypes))]

        tierSuffix := string(params.RewardTier)
        itemID := fmt.Sprintf("%s_%s_%d", itemType, tierSuffix, qg.rng.Intn(1000))

        return game.QuestReward{
                Type:   "item",
                Value:  1,
                ItemID: itemID,
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package pcg

import (
        "context"
        "fmt"
        "sync"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// Registry manages all registered PCG generators and provides factory methods
// Thread-safe registry following the established locking patterns
type Registry struct {
        mu         sync.RWMutex
        generators map[ContentType]map[string]Generator
        logger     *logrus.Logger
}

// NewRegistry creates a new generator registry
func NewRegistry(logger *logrus.Logger) *Registry <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = logrus.New()
        }</span>

        <span class="cov0" title="0">return &amp;Registry{
                generators: make(map[ContentType]map[string]Generator),
                logger:     logger,
        }</span>
}

// RegisterGenerator registers a new generator with the registry
// Generator names must be unique within their content type
func (r *Registry) RegisterGenerator(name string, generator Generator) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        contentType := generator.GetType()

        // Initialize content type map if needed
        if r.generators[contentType] == nil </span><span class="cov0" title="0">{
                r.generators[contentType] = make(map[string]Generator)
        }</span>

        // Check for duplicate names
        <span class="cov0" title="0">if _, exists := r.generators[contentType][name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("generator '%s' already registered for content type '%s'", name, contentType)
        }</span>

        <span class="cov0" title="0">r.generators[contentType][name] = generator

        r.logger.WithFields(logrus.Fields{
                "generator":    name,
                "content_type": contentType,
                "version":      generator.GetVersion(),
        }).Info("Registered PCG generator")

        return nil</span>
}

// UnregisterGenerator removes a generator from the registry
func (r *Registry) UnregisterGenerator(contentType ContentType, name string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.generators[contentType] == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no generators registered for content type '%s'", contentType)
        }</span>

        <span class="cov0" title="0">if _, exists := r.generators[contentType][name]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("generator '%s' not found for content type '%s'", name, contentType)
        }</span>

        <span class="cov0" title="0">delete(r.generators[contentType], name)

        r.logger.WithFields(logrus.Fields{
                "generator":    name,
                "content_type": contentType,
        }).Info("Unregistered PCG generator")

        return nil</span>
}

// GetGenerator retrieves a specific generator by content type and name
func (r *Registry) GetGenerator(contentType ContentType, name string) (Generator, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        if r.generators[contentType] == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no generators registered for content type '%s'", contentType)
        }</span>

        <span class="cov0" title="0">generator, exists := r.generators[contentType][name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generator '%s' not found for content type '%s'", name, contentType)
        }</span>

        <span class="cov0" title="0">return generator, nil</span>
}

// ListGenerators returns all registered generators for a content type
func (r *Registry) ListGenerators(contentType ContentType) []string <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        if r.generators[contentType] == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov0" title="0">names := make([]string, 0, len(r.generators[contentType]))
        for name := range r.generators[contentType] </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>

        <span class="cov0" title="0">return names</span>
}

// ListAllGenerators returns all registered generators grouped by content type
func (r *Registry) ListAllGenerators() map[ContentType][]string <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        result := make(map[ContentType][]string)
        for contentType, generators := range r.generators </span><span class="cov0" title="0">{
                names := make([]string, 0, len(generators))
                for name := range generators </span><span class="cov0" title="0">{
                        names = append(names, name)
                }</span>
                <span class="cov0" title="0">result[contentType] = names</span>
        }

        <span class="cov0" title="0">return result</span>
}

// GenerateContent creates content using the specified generator
func (r *Registry) GenerateContent(ctx context.Context, contentType ContentType, generatorName string, params GenerationParams) (interface{}, error) <span class="cov0" title="0">{
        generator, err := r.GetGenerator(contentType, generatorName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate parameters before generation
        <span class="cov0" title="0">if err := generator.Validate(params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parameter validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.WithFields(logrus.Fields{
                "generator":    generatorName,
                "content_type": contentType,
                "seed":         params.Seed,
                "difficulty":   params.Difficulty,
        }).Info("Starting content generation")

        // Generate content with timeout handling
        resultChan := make(chan interface{}, 1)
        errorChan := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                result, err := generator.Generate(ctx, params)
                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>
                <span class="cov0" title="0">resultChan &lt;- result</span>
        }()

        <span class="cov0" title="0">select </span>{
        case result := &lt;-resultChan:<span class="cov0" title="0">
                r.logger.WithFields(logrus.Fields{
                        "generator":    generatorName,
                        "content_type": contentType,
                }).Info("Content generation completed successfully")
                return result, nil</span>

        case err := &lt;-errorChan:<span class="cov0" title="0">
                r.logger.WithFields(logrus.Fields{
                        "generator":    generatorName,
                        "content_type": contentType,
                        "error":        err.Error(),
                }).Error("Content generation failed")
                return nil, err</span>

        case &lt;-ctx.Done():<span class="cov0" title="0">
                r.logger.WithFields(logrus.Fields{
                        "generator":    generatorName,
                        "content_type": contentType,
                }).Warn("Content generation cancelled or timed out")
                return nil, ctx.Err()</span>
        }
}

// Factory provides convenient factory methods for content generation
type Factory struct {
        registry *Registry
        logger   *logrus.Logger
}

// NewFactory creates a new factory instance
func NewFactory(registry *Registry, logger *logrus.Logger) *Factory <span class="cov0" title="0">{
        return &amp;Factory{
                registry: registry,
                logger:   logger,
        }
}</span>

// GenerateTerrain generates terrain using the specified generator
func (f *Factory) GenerateTerrain(ctx context.Context, generatorName string, params TerrainParams) (*game.GameMap, error) <span class="cov0" title="0">{
        result, err := f.registry.GenerateContent(ctx, ContentTypeTerrain, generatorName, params.GenerationParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">gameMap, ok := result.(*game.GameMap)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("terrain generator returned unexpected type: %T", result)
        }</span>

        <span class="cov0" title="0">return gameMap, nil</span>
}

// GenerateItems generates items using the specified generator
func (f *Factory) GenerateItems(ctx context.Context, generatorName string, params ItemParams) ([]*game.Item, error) <span class="cov0" title="0">{
        result, err := f.registry.GenerateContent(ctx, ContentTypeItems, generatorName, params.GenerationParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Handle both single items and item arrays
        <span class="cov0" title="0">switch v := result.(type) </span>{
        case *game.Item:<span class="cov0" title="0">
                return []*game.Item{v}, nil</span>
        case []*game.Item:<span class="cov0" title="0">
                return v, nil</span>
        case []game.Item:<span class="cov0" title="0">
                items := make([]*game.Item, len(v))
                for i := range v </span><span class="cov0" title="0">{
                        items[i] = &amp;v[i]
                }</span>
                <span class="cov0" title="0">return items, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("item generator returned unexpected type: %T", result)</span>
        }
}

// GenerateLevel generates a level using the specified generator
func (f *Factory) GenerateLevel(ctx context.Context, generatorName string, params LevelParams) (*game.Level, error) <span class="cov0" title="0">{
        result, err := f.registry.GenerateContent(ctx, ContentTypeLevels, generatorName, params.GenerationParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">level, ok := result.(*game.Level)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("level generator returned unexpected type: %T", result)
        }</span>

        <span class="cov0" title="0">return level, nil</span>
}

// GenerateQuest generates a quest using the specified generator
func (f *Factory) GenerateQuest(ctx context.Context, generatorName string, params QuestParams) (*game.Quest, error) <span class="cov0" title="0">{
        result, err := f.registry.GenerateContent(ctx, ContentTypeQuests, generatorName, params.GenerationParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">quest, ok := result.(*game.Quest)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("quest generator returned unexpected type: %T", result)
        }</span>

        <span class="cov0" title="0">return quest, nil</span>
}

// GetDefaultRegistry returns a registry with default generators registered
func GetDefaultRegistry(logger *logrus.Logger) *Registry <span class="cov0" title="0">{
        registry := NewRegistry(logger)

        // Register default generators (these would be implemented in their respective packages)
        // This demonstrates the registration pattern

        return registry
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package pcg

import (
        "crypto/sha256"
        "encoding/binary"
        "fmt"
        "math/rand"
        "time"
)

// SeedManager provides deterministic seeding for reproducible content generation
// Follows the established deterministic patterns in the existing dice system
type SeedManager struct {
        baseSeed     int64
        contextSeeds map[string]int64
}

// NewSeedManager creates a new seed manager with a base seed
func NewSeedManager(baseSeed int64) *SeedManager <span class="cov8" title="1">{
        if baseSeed == 0 </span><span class="cov8" title="1">{
                baseSeed = time.Now().UnixNano()
        }</span>

        <span class="cov8" title="1">return &amp;SeedManager{
                baseSeed:     baseSeed,
                contextSeeds: make(map[string]int64),
        }</span>
}

// GetBaseSeed returns the base seed used for all generation
func (sm *SeedManager) GetBaseSeed() int64 <span class="cov8" title="1">{
        return sm.baseSeed
}</span>

// DeriveContextSeed creates a deterministic seed for a specific context
// This ensures that the same content type/name combination always produces
// the same seed, enabling reproducible generation across sessions
func (sm *SeedManager) DeriveContextSeed(contentType ContentType, name string) int64 <span class="cov8" title="1">{
        context := fmt.Sprintf("%s:%s", contentType, name)

        if seed, exists := sm.contextSeeds[context]; exists </span><span class="cov8" title="1">{
                return seed
        }</span>

        // Create deterministic seed by hashing base seed + context
        <span class="cov8" title="1">hasher := sha256.New()
        hasher.Write([]byte(fmt.Sprintf("%d:%s", sm.baseSeed, context)))
        hash := hasher.Sum(nil)

        // Convert first 8 bytes of hash to int64
        seed := int64(binary.BigEndian.Uint64(hash[:8]))

        sm.contextSeeds[context] = seed
        return seed</span>
}

// DeriveParameterSeed creates a seed based on generation parameters
// This allows for controlled variation within the same generator context
func (sm *SeedManager) DeriveParameterSeed(baseSeed int64, params GenerationParams) int64 <span class="cov8" title="1">{
        hasher := sha256.New()

        // Include critical parameters that should affect generation
        paramString := fmt.Sprintf("%d:%d:%d",
                baseSeed,
                params.Difficulty,
                params.PlayerLevel)

        // Include any additional constraints that should affect seeding
        for key, value := range params.Constraints </span><span class="cov8" title="1">{
                paramString += fmt.Sprintf(":%s=%v", key, value)
        }</span>

        <span class="cov8" title="1">hasher.Write([]byte(paramString))
        hash := hasher.Sum(nil)

        return int64(binary.BigEndian.Uint64(hash[:8]))</span>
}

// CreateRNG creates a new random number generator with the derived seed
// This provides the same pattern as the existing DiceRoller system
func (sm *SeedManager) CreateRNG(contentType ContentType, name string, params GenerationParams) *rand.Rand <span class="cov8" title="1">{
        contextSeed := sm.DeriveContextSeed(contentType, name)
        finalSeed := sm.DeriveParameterSeed(contextSeed, params)

        return rand.New(rand.NewSource(finalSeed))
}</span>

// CreateSubRNG creates a child RNG for a specific generation phase
// This allows deterministic sub-generation within a larger generation process
func (sm *SeedManager) CreateSubRNG(parentRNG *rand.Rand, phase string) *rand.Rand <span class="cov8" title="1">{
        // Use the parent RNG to get a deterministic seed for the sub-phase
        subSeed := parentRNG.Int63()

        // Hash the phase name with the sub-seed for determinism
        hasher := sha256.New()
        hasher.Write([]byte(fmt.Sprintf("%d:%s", subSeed, phase)))
        hash := hasher.Sum(nil)

        finalSeed := int64(binary.BigEndian.Uint64(hash[:8]))
        return rand.New(rand.NewSource(finalSeed))
}</span>

// SaveableState represents the state that can be saved/loaded for reproducibility
type SaveableState struct {
        BaseSeed     int64            `yaml:"base_seed"`
        ContextSeeds map[string]int64 `yaml:"context_seeds"`
}

// GetSaveableState returns the current state for persistence
func (sm *SeedManager) GetSaveableState() SaveableState <span class="cov8" title="1">{
        return SaveableState{
                BaseSeed:     sm.baseSeed,
                ContextSeeds: sm.contextSeeds,
        }
}</span>

// LoadState restores the seed manager from saved state
func (sm *SeedManager) LoadState(state SaveableState) <span class="cov8" title="1">{
        sm.baseSeed = state.BaseSeed
        sm.contextSeeds = make(map[string]int64)

        for context, seed := range state.ContextSeeds </span><span class="cov8" title="1">{
                sm.contextSeeds[context] = seed
        }</span>
}

// GenerationContext provides context and seeded RNG for generators
type GenerationContext struct {
        RNG     *rand.Rand
        Seed    int64
        Phase   string
        SeedMgr *SeedManager
        SubRNGs map[string]*rand.Rand
}

// NewGenerationContext creates a new generation context
func NewGenerationContext(seedMgr *SeedManager, contentType ContentType, name string, params GenerationParams) *GenerationContext <span class="cov8" title="1">{
        rng := seedMgr.CreateRNG(contentType, name, params)

        return &amp;GenerationContext{
                RNG:     rng,
                Seed:    seedMgr.DeriveContextSeed(contentType, name),
                Phase:   "main",
                SeedMgr: seedMgr,
                SubRNGs: make(map[string]*rand.Rand),
        }
}</span>

// GetSubRNG returns a deterministic sub-RNG for the specified phase
func (gc *GenerationContext) GetSubRNG(phase string) *rand.Rand <span class="cov8" title="1">{
        if subRNG, exists := gc.SubRNGs[phase]; exists </span><span class="cov8" title="1">{
                return subRNG
        }</span>

        <span class="cov8" title="1">subRNG := gc.SeedMgr.CreateSubRNG(gc.RNG, phase)
        gc.SubRNGs[phase] = subRNG
        return subRNG</span>
}

// RollDice provides dice rolling functionality using the context's RNG
// This integrates with the existing dice system patterns
func (gc *GenerationContext) RollDice(sides int) int <span class="cov8" title="1">{
        if sides &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return gc.RNG.Intn(sides) + 1</span>
}

// RollMultipleDice rolls multiple dice and returns individual results
func (gc *GenerationContext) RollMultipleDice(count, sides int) []int <span class="cov8" title="1">{
        results := make([]int, count)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                results[i] = gc.RollDice(sides)
        }</span>
        <span class="cov8" title="1">return results</span>
}

// RollDiceSum rolls multiple dice and returns the sum
func (gc *GenerationContext) RollDiceSum(count, sides int) int <span class="cov8" title="1">{
        total := 0
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                total += gc.RollDice(sides)
        }</span>
        <span class="cov8" title="1">return total</span>
}

// RandomChoice selects a random element from a slice
func (gc *GenerationContext) RandomChoice(choices []string) string <span class="cov8" title="1">{
        if len(choices) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return choices[gc.RNG.Intn(len(choices))]</span>
}

// RandomFloat returns a random float64 between 0.0 and 1.0
func (gc *GenerationContext) RandomFloat() float64 <span class="cov8" title="1">{
        return gc.RNG.Float64()
}</span>

// RandomFloatRange returns a random float64 between min and max
func (gc *GenerationContext) RandomFloatRange(min, max float64) float64 <span class="cov8" title="1">{
        return min + gc.RNG.Float64()*(max-min)
}</span>

// RandomIntRange returns a random int between min and max (inclusive)
func (gc *GenerationContext) RandomIntRange(min, max int) int <span class="cov8" title="1">{
        if min &gt;= max </span><span class="cov8" title="1">{
                return min
        }</span>
        <span class="cov8" title="1">return min + gc.RNG.Intn(max-min+1)</span>
}

// WeightedChoice selects from choices based on weights
func (gc *GenerationContext) WeightedChoice(choices []string, weights []float64) string <span class="cov8" title="1">{
        if len(choices) == 0 || len(choices) != len(weights) </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Calculate total weight
        <span class="cov8" title="1">totalWeight := 0.0
        for _, weight := range weights </span><span class="cov8" title="1">{
                totalWeight += weight
        }</span>

        <span class="cov8" title="1">if totalWeight &lt;= 0 </span><span class="cov8" title="1">{
                return gc.RandomChoice(choices)
        }</span>

        // Random value between 0 and total weight
        <span class="cov8" title="1">randomValue := gc.RNG.Float64() * totalWeight

        // Find the selected choice
        currentWeight := 0.0
        for i, weight := range weights </span><span class="cov8" title="1">{
                currentWeight += weight
                if randomValue &lt;= currentWeight </span><span class="cov8" title="1">{
                        return choices[i]
                }</span>
        }

        // Fallback to last choice
        <span class="cov0" title="0">return choices[len(choices)-1]</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package pcg

import (
        "goldbox-rpg/pkg/game"
        "time"
)

// BiomeType represents different terrain biomes for generation
type BiomeType string

const (
        BiomeForest    BiomeType = "forest"
        BiomeMountain  BiomeType = "mountain"
        BiomeDesert    BiomeType = "desert"
        BiomeSwamp     BiomeType = "swamp"
        BiomeCave      BiomeType = "cave"
        BiomeDungeon   BiomeType = "dungeon"
        BiomeCoastal   BiomeType = "coastal"
        BiomeUrban     BiomeType = "urban"
        BiomeWasteland BiomeType = "wasteland"
)

// RarityTier represents item rarity levels
type RarityTier string

const (
        RarityCommon    RarityTier = "common"
        RarityUncommon  RarityTier = "uncommon"
        RarityRare      RarityTier = "rare"
        RarityEpic      RarityTier = "epic"
        RarityLegendary RarityTier = "legendary"
        RarityArtifact  RarityTier = "artifact"
)

// RoomType represents different types of rooms in generated levels
type RoomType string

const (
        RoomTypeEntrance RoomType = "entrance"
        RoomTypeExit     RoomType = "exit"
        RoomTypeCombat   RoomType = "combat"
        RoomTypeTreasure RoomType = "treasure"
        RoomTypePuzzle   RoomType = "puzzle"
        RoomTypeBoss     RoomType = "boss"
        RoomTypeSecret   RoomType = "secret"
        RoomTypeShop     RoomType = "shop"
        RoomTypeRest     RoomType = "rest"
        RoomTypeTrap     RoomType = "trap"
        RoomTypeStory    RoomType = "story"
)

// CorridorStyle represents different corridor generation approaches
type CorridorStyle string

const (
        CorridorStraight CorridorStyle = "straight"
        CorridorWindy    CorridorStyle = "windy"
        CorridorMaze     CorridorStyle = "maze"
        CorridorOrganic  CorridorStyle = "organic"
        CorridorMinimal  CorridorStyle = "minimal"
)

// LevelTheme represents thematic constraints for level generation
type LevelTheme string

const (
        ThemeClassic    LevelTheme = "classic"
        ThemeHorror     LevelTheme = "horror"
        ThemeNatural    LevelTheme = "natural"
        ThemeMechanical LevelTheme = "mechanical"
        ThemeMagical    LevelTheme = "magical"
        ThemeUndead     LevelTheme = "undead"
        ThemeElemental  LevelTheme = "elemental"
)

// QuestType represents different categories of quests
type QuestType string

const (
        QuestTypeFetch    QuestType = "fetch"
        QuestTypeKill     QuestType = "kill"
        QuestTypeEscort   QuestType = "escort"
        QuestTypeExplore  QuestType = "explore"
        QuestTypeDefend   QuestType = "defend"
        QuestTypePuzzle   QuestType = "puzzle"
        QuestTypeDelivery QuestType = "delivery"
        QuestTypeSurvival QuestType = "survival"
        QuestTypeStory    QuestType = "story"
)

// NarrativeType represents different story generation styles
type NarrativeType string

const (
        NarrativeLinear    NarrativeType = "linear"
        NarrativeBranching NarrativeType = "branching"
        NarrativeOpen      NarrativeType = "open"
        NarrativeEpisodic  NarrativeType = "episodic"
)

// ConnectivityLevel represents how connected terrain features should be
type ConnectivityLevel string

const (
        ConnectivityNone     ConnectivityLevel = "none"
        ConnectivityLow      ConnectivityLevel = "low"
        ConnectivityMinimal  ConnectivityLevel = "minimal"
        ConnectivityModerate ConnectivityLevel = "moderate"
        ConnectivityHigh     ConnectivityLevel = "high"
        ConnectivityComplete ConnectivityLevel = "complete"
)

// TerrainFeature represents special features that can be included in terrain
type TerrainFeature string

const (
        FeatureWater            TerrainFeature = "water"
        FeatureMountain         TerrainFeature = "mountain"
        FeatureForest           TerrainFeature = "forest"
        FeatureCave             TerrainFeature = "cave"
        FeatureRuins            TerrainFeature = "ruins"
        FeatureRoad             TerrainFeature = "road"
        FeatureBridge           TerrainFeature = "bridge"
        FeatureTown             TerrainFeature = "town"
        FeatureShrine           TerrainFeature = "shrine"
        FeatureStalactites      TerrainFeature = "stalactites"
        FeatureUndergroundRiver TerrainFeature = "underground_river"
        FeatureSecretDoors      TerrainFeature = "secret_doors"
        FeatureTraps            TerrainFeature = "traps"
        FeatureTrees            TerrainFeature = "trees"
        FeatureStreams          TerrainFeature = "streams"
        FeatureCliffs           TerrainFeature = "cliffs"
        FeatureCrevasses        TerrainFeature = "crevasses"
        FeatureBogs             TerrainFeature = "bogs"
        FeatureVines            TerrainFeature = "vines"
        FeatureDunes            TerrainFeature = "dunes"
        FeatureOasis            TerrainFeature = "oasis"
)

// ItemSetType represents collections of related items
type ItemSetType string

const (
        ItemSetArmor    ItemSetType = "armor"
        ItemSetWeapons  ItemSetType = "weapons"
        ItemSetJewelry  ItemSetType = "jewelry"
        ItemSetTools    ItemSetType = "tools"
        ItemSetConsumab ItemSetType = "consumables"
        ItemSetMagical  ItemSetType = "magical"
        ItemSetCrafting ItemSetType = "crafting"
)

// Rectangle represents a rectangular area for spatial operations
type Rectangle struct {
        X, Y          int // Top-left corner coordinates
        Width, Height int // Dimensions
}

// Contains checks if a position is within the rectangle
func (r Rectangle) Contains(x, y int) bool <span class="cov8" title="1">{
        return x &gt;= r.X &amp;&amp; x &lt; r.X+r.Width &amp;&amp; y &gt;= r.Y &amp;&amp; y &lt; r.Y+r.Height
}</span>

// Intersects checks if this rectangle intersects with another
func (r Rectangle) Intersects(other Rectangle) bool <span class="cov8" title="1">{
        return r.X &lt; other.X+other.Width &amp;&amp;
                r.X+r.Width &gt; other.X &amp;&amp;
                r.Y &lt; other.Y+other.Height &amp;&amp;
                r.Y+r.Height &gt; other.Y
}</span>

// RoomLayout represents the layout of a generated room
type RoomLayout struct {
        ID         string                 `yaml:"id"`         // Unique room identifier
        Type       RoomType               `yaml:"type"`       // Room type classification
        Bounds     Rectangle              `yaml:"bounds"`     // Room dimensions and position
        Tiles      [][]game.Tile          `yaml:"tiles"`      // Room tile data
        Doors      []game.Position        `yaml:"doors"`      // Door/entrance positions
        Features   []RoomFeature          `yaml:"features"`   // Special room features
        Difficulty int                    `yaml:"difficulty"` // Challenge rating
        Properties map[string]interface{} `yaml:"properties"` // Additional room data
        Connected  []string               `yaml:"connected"`  // IDs of connected rooms
}

// Corridor represents a connection between rooms
type Corridor struct {
        ID       string            `yaml:"id"`       // Unique corridor identifier
        Start    game.Position     `yaml:"start"`    // Starting position
        End      game.Position     `yaml:"end"`      // Ending position
        Path     []game.Position   `yaml:"path"`     // Corridor path tiles
        Width    int               `yaml:"width"`    // Corridor width
        Style    CorridorStyle     `yaml:"style"`    // Generation style used
        Features []CorridorFeature `yaml:"features"` // Special corridor features
}

// RoomFeature represents special features within rooms
type RoomFeature struct {
        Type       string                 `yaml:"type"`       // Feature type (chest, altar, etc.)
        Position   game.Position          `yaml:"position"`   // Location within room
        Properties map[string]interface{} `yaml:"properties"` // Feature-specific data
}

// CorridorFeature represents special features within corridors
type CorridorFeature struct {
        Type       string                 `yaml:"type"`       // Feature type (trap, secret door, etc.)
        Position   game.Position          `yaml:"position"`   // Location within corridor
        Properties map[string]interface{} `yaml:"properties"` // Feature-specific data
}

// ItemTemplate represents a template for procedural item generation
type ItemTemplate struct {
        BaseType   string                `yaml:"base_type"`   // Base item type (sword, armor, etc.)
        NameParts  []string              `yaml:"name_parts"`  // Name generation components
        StatRanges map[string]StatRange  `yaml:"stat_ranges"` // Stat generation ranges
        Properties []string              `yaml:"properties"`  // Possible item properties
        Enchants   []EnchantmentTemplate `yaml:"enchants"`    // Available enchantments
        Materials  []string              `yaml:"materials"`   // Possible materials
        Rarities   []RarityTier          `yaml:"rarities"`    // Applicable rarity tiers
}

// StatRange represents a range for procedural stat generation
type StatRange struct {
        Min     int     `yaml:"min"`     // Minimum value
        Max     int     `yaml:"max"`     // Maximum value
        Scaling float64 `yaml:"scaling"` // Level scaling factor
}

// EnchantmentTemplate represents a template for procedural enchantments
type EnchantmentTemplate struct {
        Name         string                 `yaml:"name"`         // Enchantment name
        Type         string                 `yaml:"type"`         // Enchantment type
        MinLevel     int                    `yaml:"min_level"`    // Minimum required level
        MaxLevel     int                    `yaml:"max_level"`    // Maximum applicable level
        Effects      []game.Effect          `yaml:"effects"`      // Enchantment effects
        Restrictions map[string]interface{} `yaml:"restrictions"` // Usage restrictions
}

// QuestObjective represents a single quest objective
type QuestObjective struct {
        ID          string                 `yaml:"id"`          // Unique objective ID
        Type        string                 `yaml:"type"`        // Objective type
        Description string                 `yaml:"description"` // Human-readable description
        Target      string                 `yaml:"target"`      // Target entity/location
        Quantity    int                    `yaml:"quantity"`    // Required quantity
        Progress    int                    `yaml:"progress"`    // Current progress
        Complete    bool                   `yaml:"complete"`    // Completion status
        Optional    bool                   `yaml:"optional"`    // Whether objective is optional
        Conditions  map[string]interface{} `yaml:"conditions"`  // Completion conditions
}

// Faction-related types

// FactionType represents different categories of factions
type FactionType string

const (
        FactionTypeMilitary  FactionType = "military"
        FactionTypeEconomic  FactionType = "economic"
        FactionTypeReligious FactionType = "religious"
        FactionTypeCriminal  FactionType = "criminal"
        FactionTypeScholarly FactionType = "scholarly"
        FactionTypePolitical FactionType = "political"
        FactionTypeMercenary FactionType = "mercenary"
        FactionTypeMagical   FactionType = "magical"
)

// RelationshipStatus represents the diplomatic status between factions
type RelationshipStatus string

const (
        RelationStatusAllied   RelationshipStatus = "allied"
        RelationStatusFriendly RelationshipStatus = "friendly"
        RelationStatusNeutral  RelationshipStatus = "neutral"
        RelationStatusTense    RelationshipStatus = "tense"
        RelationStatusHostile  RelationshipStatus = "hostile"
        RelationStatusWar      RelationshipStatus = "war"
)

// ResourceType represents different types of resources factions can control (already exists in world.go)

// TerritoryType represents different types of faction territories
type TerritoryType string

const (
        TerritoryTypeCapital     TerritoryType = "capital"
        TerritoryTypeCity        TerritoryType = "city"
        TerritoryTypeOutpost     TerritoryType = "outpost"
        TerritoryTypeFortress    TerritoryType = "fortress"
        TerritoryTypeTradingPost TerritoryType = "trading_post"
        TerritoryTypeResource    TerritoryType = "resource"
)

// ConflictType represents different types of conflicts between factions
type ConflictType string

const (
        ConflictTypeTrade      ConflictType = "trade"
        ConflictTypeTerritory  ConflictType = "territory"
        ConflictTypeReligious  ConflictType = "religious"
        ConflictTypeResource   ConflictType = "resource"
        ConflictTypeSuccession ConflictType = "succession"
        ConflictTypeRevenge    ConflictType = "revenge"
)

// DifficultyProgression already exists in dungeon.go as a struct

// PlotType already exists in narrative.go

// Faction-related structures

// Faction represents a political/social organization
type Faction struct {
        ID         string                 `json:"id"`
        Name       string                 `json:"name"`
        Type       FactionType            `json:"type"`
        Government GovernmentType         `json:"government"`
        Ideology   string                 `json:"ideology"`
        Power      int                    `json:"power"`
        Wealth     int                    `json:"wealth"`
        Military   int                    `json:"military"`
        Influence  int                    `json:"influence"`
        Stability  float64                `json:"stability"`
        Goals      []string               `json:"goals"`
        Resources  []ResourceType         `json:"resources"`
        Leaders    []*FactionLeader       `json:"leaders"`
        Properties map[string]interface{} `json:"properties"`
}

// FactionLeader represents a leader within a faction
type FactionLeader struct {
        ID         string                 `json:"id"`
        Name       string                 `json:"name"`
        Title      string                 `json:"title"`
        Age        int                    `json:"age"`
        Traits     []string               `json:"traits"`
        Loyalty    float64                `json:"loyalty"`
        Competence float64                `json:"competence"`
        Influence  float64                `json:"influence"`
        Properties map[string]interface{} `json:"properties"`
}

// FactionRelationship represents diplomatic relations between two factions
type FactionRelationship struct {
        ID          string                 `json:"id"`
        Faction1ID  string                 `json:"faction1_id"`
        Faction2ID  string                 `json:"faction2_id"`
        Status      RelationshipStatus     `json:"status"`
        Opinion     float64                `json:"opinion"`     // -1.0 to 1.0
        TrustLevel  float64                `json:"trust_level"` // 0.0 to 1.0
        TradeLevel  float64                `json:"trade_level"` // 0.0 to 1.0
        Hostility   float64                `json:"hostility"`   // 0.0 to 1.0
        History     []string               `json:"history"`
        LastChanged time.Time              `json:"last_changed"`
        Properties  map[string]interface{} `json:"properties"`
}

// Territory represents a geographic area controlled by a faction
type Territory struct {
        ID           string                 `json:"id"`
        Name         string                 `json:"name"`
        Type         TerritoryType          `json:"type"`
        ControllerID string                 `json:"controller_id"`
        Position     game.Position          `json:"position"`
        Size         int                    `json:"size"`
        Population   int                    `json:"population"`
        Defenses     int                    `json:"defenses"`
        Resources    []ResourceType         `json:"resources"`
        Strategic    bool                   `json:"strategic"`
        Properties   map[string]interface{} `json:"properties"`
}

// TradeDeal represents economic agreements between factions
type TradeDeal struct {
        ID         string                 `json:"id"`
        Name       string                 `json:"name"`
        Faction1ID string                 `json:"faction1_id"`
        Faction2ID string                 `json:"faction2_id"`
        Resource1  ResourceType           `json:"resource1"`
        Resource2  ResourceType           `json:"resource2"`
        Volume1    int                    `json:"volume1"`
        Volume2    int                    `json:"volume2"`
        Duration   int                    `json:"duration"` // Duration in days
        Profit1    int                    `json:"profit1"`
        Profit2    int                    `json:"profit2"`
        Active     bool                   `json:"active"`
        Properties map[string]interface{} `json:"properties"`
}

// Conflict represents ongoing conflicts between factions
type Conflict struct {
        ID         string                 `json:"id"`
        Name       string                 `json:"name"`
        Type       ConflictType           `json:"type"`
        Factions   []string               `json:"factions"`
        Cause      string                 `json:"cause"`
        Intensity  float64                `json:"intensity"` // 0.0 to 1.0
        Duration   int                    `json:"duration"`  // Duration in days
        Territory  string                 `json:"territory"` // Disputed territory ID
        Resolution string                 `json:"resolution"`
        Active     bool                   `json:"active"`
        Properties map[string]interface{} `json:"properties"`
}

// GeneratedFactionSystem represents a complete faction system
type GeneratedFactionSystem struct {
        ID            string                 `json:"id"`
        Name          string                 `json:"name"`
        Factions      []*Faction             `json:"factions"`
        Relationships []*FactionRelationship `json:"relationships"`
        Territories   []*Territory           `json:"territories"`
        TradeDeals    []*TradeDeal           `json:"trade_deals"`
        Conflicts     []*Conflict            `json:"conflicts"`
        Metadata      map[string]interface{} `json:"metadata"`
        Generated     time.Time              `json:"generated"`
}

// FactionParams provides faction-specific generation parameters
type FactionParams struct {
        GenerationParams   `yaml:",inline"`
        FactionCount       int     `yaml:"faction_count"`       // Number of factions to generate
        MinPower           int     `yaml:"min_power"`           // Minimum faction power level
        MaxPower           int     `yaml:"max_power"`           // Maximum faction power level
        ConflictLevel      float64 `yaml:"conflict_level"`      // Overall conflict intensity (0.0-1.0)
        EconomicFocus      float64 `yaml:"economic_focus"`      // Economic activity emphasis (0.0-1.0)
        MilitaryFocus      float64 `yaml:"military_focus"`      // Military emphasis (0.0-1.0)
        CulturalFocus      float64 `yaml:"cultural_focus"`      // Cultural/religious emphasis (0.0-1.0)
        TerritoryCount     int     `yaml:"territory_count"`     // Number of territories per faction
        TradeVolume        float64 `yaml:"trade_volume"`        // Overall trade activity (0.0-1.0)
        PoliticalStability float64 `yaml:"political_stability"` // Overall political stability (0.0-1.0)
}

// CharacterType represents different categories of NPCs
type CharacterType string

const (
        CharacterTypeGeneric  CharacterType = "generic"  // General purpose NPC
        CharacterTypeMerchant CharacterType = "merchant" // Shop keeper or trader
        CharacterTypeGuard    CharacterType = "guard"    // Security or military
        CharacterTypeNoble    CharacterType = "noble"    // Aristocracy or leadership
        CharacterTypePeasant  CharacterType = "peasant"  // Common folk or laborers
        CharacterTypeCrafter  CharacterType = "crafter"  // Artisan or specialist
        CharacterTypeCleric   CharacterType = "cleric"   // Religious figure
        CharacterTypeMage     CharacterType = "mage"     // Magic user or scholar
        CharacterTypeRogue    CharacterType = "rogue"    // Thief or scoundrel
        CharacterTypeBard     CharacterType = "bard"     // Entertainer or storyteller
)

// BackgroundType represents character background categories
type BackgroundType string

const (
        BackgroundUrban      BackgroundType = "urban"      // City dweller
        BackgroundRural      BackgroundType = "rural"      // Countryside origin
        BackgroundNomadic    BackgroundType = "nomadic"    // Travel-oriented background
        BackgroundNoble      BackgroundType = "noble"      // Aristocratic upbringing
        BackgroundCriminal   BackgroundType = "criminal"   // Unlawful background
        BackgroundMilitary   BackgroundType = "military"   // Armed forces background
        BackgroundReligious  BackgroundType = "religious"  // Religious/monastic background
        BackgroundScholar    BackgroundType = "scholar"    // Academic background
        BackgroundWilderness BackgroundType = "wilderness" // Outdoor/survival background
)

// SocialClass represents character's social standing
type SocialClass string

const (
        SocialClassSlave    SocialClass = "slave"    // Lowest social position
        SocialClassSerf     SocialClass = "serf"     // Bound peasant
        SocialClassPeasant  SocialClass = "peasant"  // Free commoner
        SocialClassCrafter  SocialClass = "crafter"  // Skilled artisan
        SocialClassMerchant SocialClass = "merchant" // Trade class
        SocialClassGentry   SocialClass = "gentry"   // Minor nobility
        SocialClassNoble    SocialClass = "noble"    // Aristocracy
        SocialClassRoyalty  SocialClass = "royalty"  // Ruling class
)

// AgeRange represents character age categories
type AgeRange string

const (
        AgeRangeChild      AgeRange = "child"       // Young character (5-12)
        AgeRangeAdolescent AgeRange = "adolescent"  // Teenage character (13-17)
        AgeRangeYoungAdult AgeRange = "young_adult" // Young adult (18-25)
        AgeRangeAdult      AgeRange = "adult"       // Mature adult (26-40)
        AgeRangeMiddleAged AgeRange = "middle_aged" // Middle-aged (41-60)
        AgeRangeElderly    AgeRange = "elderly"     // Elderly character (61+)
        AgeRangeAncient    AgeRange = "ancient"     // Very old character (special cases)
)

// NPCGroupType represents different types of NPC groups
type NPCGroupType string

const (
        NPCGroupFamily    NPCGroupType = "family"    // Related family members
        NPCGroupGuards    NPCGroupType = "guards"    // Security patrol or unit
        NPCGroupMerchants NPCGroupType = "merchants" // Trading group or caravan
        NPCGroupCultists  NPCGroupType = "cultists"  // Religious or cult group
        NPCGroupBandits   NPCGroupType = "bandits"   // Criminal organization
        NPCGroupScholars  NPCGroupType = "scholars"  // Academic or research group
        NPCGroupCrafters  NPCGroupType = "crafters"  // Guild or workshop group
)

// PersonalityTrait represents individual personality characteristics
type PersonalityTrait struct {
        Name        string  `json:"name"`        // Trait name (e.g., "brave", "greedy")
        Intensity   float64 `json:"intensity"`   // Trait strength (0.0-1.0)
        Description string  `json:"description"` // Descriptive text
}

// Motivation represents character goals and drives
type Motivation struct {
        Type        string  `json:"type"`        // Motivation category (power, wealth, love, etc.)
        Target      string  `json:"target"`      // What the motivation is directed toward
        Intensity   float64 `json:"intensity"`   // How strongly motivated (0.0-1.0)
        Description string  `json:"description"` // Detailed description
}

// PersonalityProfile represents a complete character personality system
type PersonalityProfile struct {
        Traits      []PersonalityTrait `json:"traits"`      // Individual personality traits
        Motivations []Motivation       `json:"motivations"` // Character goals and drives
        Alignment   string             `json:"alignment"`   // Moral alignment
        Temperament string             `json:"temperament"` // General disposition
        Values      []string           `json:"values"`      // What the character values most
        Fears       []string           `json:"fears"`       // Character's primary fears
        Speech      SpeechPattern      `json:"speech"`      // How the character speaks
}

// SpeechPattern represents how a character communicates
type SpeechPattern struct {
        Formality   string   `json:"formality"`   // Level of formality (formal, casual, crude)
        Vocabulary  string   `json:"vocabulary"`  // Complexity level (simple, moderate, complex)
        Accent      string   `json:"accent"`      // Regional or cultural accent
        Mannerisms  []string `json:"mannerisms"`  // Speech habits or quirks
        Catchphrase string   `json:"catchphrase"` // Signature phrase (optional)
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package pcg

import (
        "fmt"
        "strings"

        "goldbox-rpg/pkg/game"
)

// ValidationResult represents the result of content validation
type ValidationResult struct {
        Valid    bool     `yaml:"valid"`
        Errors   []string `yaml:"errors"`
        Warnings []string `yaml:"warnings"`
}

// IsValid returns true if validation passed without errors
func (vr *ValidationResult) IsValid() bool <span class="cov0" title="0">{
        return vr.Valid &amp;&amp; len(vr.Errors) == 0
}</span>

// HasWarnings returns true if there are validation warnings
func (vr *ValidationResult) HasWarnings() bool <span class="cov0" title="0">{
        return len(vr.Warnings) &gt; 0
}</span>

// AddError adds an error to the validation result
func (vr *ValidationResult) AddError(message string) <span class="cov0" title="0">{
        vr.Errors = append(vr.Errors, message)
        vr.Valid = false
}</span>

// AddWarning adds a warning to the validation result
func (vr *ValidationResult) AddWarning(message string) <span class="cov0" title="0">{
        vr.Warnings = append(vr.Warnings, message)
}</span>

// Merge combines another validation result into this one
func (vr *ValidationResult) Merge(other *ValidationResult) <span class="cov0" title="0">{
        vr.Errors = append(vr.Errors, other.Errors...)
        vr.Warnings = append(vr.Warnings, other.Warnings...)
        if !other.Valid </span><span class="cov0" title="0">{
                vr.Valid = false
        }</span>
}

// Validator provides validation for generated content
type Validator struct {
        strictMode bool
}

// NewValidator creates a new content validator
func NewValidator(strictMode bool) *Validator <span class="cov0" title="0">{
        return &amp;Validator{
                strictMode: strictMode,
        }
}</span>

// ValidateGenerationParams validates common generation parameters
func (v *Validator) ValidateGenerationParams(params GenerationParams) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        // Validate seed (any int64 value is acceptable)

        // Validate difficulty range
        if params.Difficulty &lt; 1 || params.Difficulty &gt; 20 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("difficulty must be between 1 and 20, got %d", params.Difficulty))
        }</span>

        // Validate player level
        <span class="cov0" title="0">if params.PlayerLevel &lt; 1 || params.PlayerLevel &gt; 20 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("player level must be between 1 and 20, got %d", params.PlayerLevel))
        }</span>

        // Validate timeout
        <span class="cov0" title="0">if params.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                result.AddWarning("timeout not specified or invalid, generation may run indefinitely")
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateTerrainParams validates terrain-specific parameters
func (v *Validator) ValidateTerrainParams(params TerrainParams) *ValidationResult <span class="cov0" title="0">{
        result := v.ValidateGenerationParams(params.GenerationParams)

        // Validate biome type
        validBiomes := []BiomeType{
                BiomeForest, BiomeMountain, BiomeDesert, BiomeSwamp,
                BiomeCave, BiomeDungeon, BiomeCoastal, BiomeUrban, BiomeWasteland,
        }

        valid := false
        for _, validBiome := range validBiomes </span><span class="cov0" title="0">{
                if params.BiomeType == validBiome </span><span class="cov0" title="0">{
                        valid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid biome type: %s", params.BiomeType))
        }</span>

        // Validate density
        <span class="cov0" title="0">if params.Density &lt; 0.0 || params.Density &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("density must be between 0.0 and 1.0, got %f", params.Density))
        }</span>

        // Validate water level
        <span class="cov0" title="0">if params.WaterLevel &lt; 0.0 || params.WaterLevel &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("water level must be between 0.0 and 1.0, got %f", params.WaterLevel))
        }</span>

        // Validate roughness
        <span class="cov0" title="0">if params.Roughness &lt; 0.0 || params.Roughness &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("roughness must be between 0.0 and 1.0, got %f", params.Roughness))
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateItemParams validates item-specific parameters
func (v *Validator) ValidateItemParams(params ItemParams) *ValidationResult <span class="cov0" title="0">{
        result := v.ValidateGenerationParams(params.GenerationParams)

        // Validate rarity tiers
        validRarities := []RarityTier{
                RarityCommon, RarityUncommon, RarityRare,
                RarityEpic, RarityLegendary, RarityArtifact,
        }

        // Check minimum rarity
        minValid := false
        for _, validRarity := range validRarities </span><span class="cov0" title="0">{
                if params.MinRarity == validRarity </span><span class="cov0" title="0">{
                        minValid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !minValid </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid minimum rarity: %s", params.MinRarity))
        }</span>

        // Check maximum rarity
        <span class="cov0" title="0">maxValid := false
        for _, validRarity := range validRarities </span><span class="cov0" title="0">{
                if params.MaxRarity == validRarity </span><span class="cov0" title="0">{
                        maxValid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !maxValid </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid maximum rarity: %s", params.MaxRarity))
        }</span>

        // Validate enchantment rate
        <span class="cov0" title="0">if params.EnchantmentRate &lt; 0.0 || params.EnchantmentRate &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("enchantment rate must be between 0.0 and 1.0, got %f", params.EnchantmentRate))
        }</span>

        // Validate unique chance
        <span class="cov0" title="0">if params.UniqueChance &lt; 0.0 || params.UniqueChance &gt; 1.0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("unique chance must be between 0.0 and 1.0, got %f", params.UniqueChance))
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateLevelParams validates level-specific parameters
func (v *Validator) ValidateLevelParams(params LevelParams) *ValidationResult <span class="cov0" title="0">{
        result := v.ValidateGenerationParams(params.GenerationParams)

        // Validate room counts
        if params.MinRooms &lt; 1 </span><span class="cov0" title="0">{
                result.AddError("minimum rooms must be at least 1")
        }</span>

        <span class="cov0" title="0">if params.MaxRooms &lt; params.MinRooms </span><span class="cov0" title="0">{
                result.AddError("maximum rooms must be greater than or equal to minimum rooms")
        }</span>

        <span class="cov0" title="0">if params.MaxRooms &gt; 100 </span><span class="cov0" title="0">{
                result.AddWarning("maximum rooms is very high, generation may be slow")
        }</span>

        // Validate secret rooms
        <span class="cov0" title="0">if params.SecretRooms &lt; 0 </span><span class="cov0" title="0">{
                result.AddError("secret rooms cannot be negative")
        }</span>

        <span class="cov0" title="0">if params.SecretRooms &gt; params.MaxRooms/2 </span><span class="cov0" title="0">{
                result.AddWarning("high number of secret rooms relative to total rooms")
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateGameMap validates a generated game map
func (v *Validator) ValidateGameMap(gameMap *game.GameMap) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        if gameMap == nil </span><span class="cov0" title="0">{
                result.AddError("game map is nil")
                return result
        }</span>

        // Validate dimensions
        <span class="cov0" title="0">if gameMap.Width &lt;= 0 || gameMap.Height &lt;= 0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid map dimensions: %dx%d", gameMap.Width, gameMap.Height))
        }</span>

        // Validate tiles array
        <span class="cov0" title="0">if len(gameMap.Tiles) != gameMap.Height </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("tiles array height mismatch: expected %d, got %d", gameMap.Height, len(gameMap.Tiles)))
        }</span>

        <span class="cov0" title="0">for y, row := range gameMap.Tiles </span><span class="cov0" title="0">{
                if len(row) != gameMap.Width </span><span class="cov0" title="0">{
                        result.AddError(fmt.Sprintf("tiles array width mismatch at row %d: expected %d, got %d", y, gameMap.Width, len(row)))
                }</span>
        }

        // Check for walkable path connectivity if in strict mode
        <span class="cov0" title="0">if v.strictMode </span><span class="cov0" title="0">{
                if !v.validateMapConnectivity(gameMap) </span><span class="cov0" title="0">{
                        result.AddError("map lacks proper connectivity between walkable areas")
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ValidateItem validates a generated item
func (v *Validator) ValidateItem(item *game.Item) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        if item == nil </span><span class="cov0" title="0">{
                result.AddError("item is nil")
                return result
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if strings.TrimSpace(item.ID) == "" </span><span class="cov0" title="0">{
                result.AddError("item ID cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(item.Name) == "" </span><span class="cov0" title="0">{
                result.AddError("item name cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(item.Type) == "" </span><span class="cov0" title="0">{
                result.AddError("item type cannot be empty")
        }</span>

        // Validate value
        <span class="cov0" title="0">if item.Value &lt; 0 </span><span class="cov0" title="0">{
                result.AddError("item value cannot be negative")
        }</span>

        // Validate weight
        <span class="cov0" title="0">if item.Weight &lt; 0 </span><span class="cov0" title="0">{
                result.AddError("item weight cannot be negative")
        }</span>

        // Validate armor class for armor items
        <span class="cov0" title="0">if item.Type == "armor" &amp;&amp; item.AC &lt;= 0 </span><span class="cov0" title="0">{
                result.AddWarning("armor item has zero or negative AC")
        }</span>

        // Validate damage for weapon items
        <span class="cov0" title="0">if item.Type == "weapon" &amp;&amp; strings.TrimSpace(item.Damage) == "" </span><span class="cov0" title="0">{
                result.AddWarning("weapon item has no damage specification")
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ValidateLevel validates a generated level
func (v *Validator) ValidateLevel(level *game.Level) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        if level == nil </span><span class="cov0" title="0">{
                result.AddError("level is nil")
                return result
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if strings.TrimSpace(level.ID) == "" </span><span class="cov0" title="0">{
                result.AddError("level ID cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(level.Name) == "" </span><span class="cov0" title="0">{
                result.AddError("level name cannot be empty")
        }</span>

        // Validate dimensions
        <span class="cov0" title="0">if level.Width &lt;= 0 || level.Height &lt;= 0 </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("invalid level dimensions: %dx%d", level.Width, level.Height))
        }</span>

        // Validate tiles array
        <span class="cov0" title="0">if len(level.Tiles) != level.Height </span><span class="cov0" title="0">{
                result.AddError(fmt.Sprintf("tiles array height mismatch: expected %d, got %d", level.Height, len(level.Tiles)))
        }</span>

        <span class="cov0" title="0">for y, row := range level.Tiles </span><span class="cov0" title="0">{
                if len(row) != level.Width </span><span class="cov0" title="0">{
                        result.AddError(fmt.Sprintf("tiles array width mismatch at row %d: expected %d, got %d", y, level.Width, len(row)))
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// ValidateQuest validates a generated quest
func (v *Validator) ValidateQuest(quest *game.Quest) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{Valid: true}

        if quest == nil </span><span class="cov0" title="0">{
                result.AddError("quest is nil")
                return result
        }</span>

        <span class="cov0" title="0">v.validateQuestFields(quest, result)
        v.validateQuestStatus(quest, result)
        v.validateQuestCollections(quest, result)

        return result</span>
}

// validateQuestFields validates the required string fields of a quest
func (v *Validator) validateQuestFields(quest *game.Quest, result *ValidationResult) <span class="cov0" title="0">{
        if strings.TrimSpace(quest.ID) == "" </span><span class="cov0" title="0">{
                result.AddError("quest ID cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(quest.Title) == "" </span><span class="cov0" title="0">{
                result.AddError("quest title cannot be empty")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(quest.Description) == "" </span><span class="cov0" title="0">{
                result.AddError("quest description cannot be empty")
        }</span>
}

// validateQuestStatus validates the quest status against allowed values
func (v *Validator) validateQuestStatus(quest *game.Quest, result *ValidationResult) <span class="cov0" title="0">{
        validStatuses := []game.QuestStatus{
                game.QuestNotStarted, game.QuestActive,
                game.QuestCompleted, game.QuestFailed,
        }

        for _, validStatus := range validStatuses </span><span class="cov0" title="0">{
                if quest.Status == validStatus </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">result.AddError(fmt.Sprintf("invalid quest status: %v", quest.Status))</span>
}

// validateQuestCollections validates quest objectives and rewards collections
func (v *Validator) validateQuestCollections(quest *game.Quest, result *ValidationResult) <span class="cov0" title="0">{
        if len(quest.Objectives) == 0 </span><span class="cov0" title="0">{
                result.AddWarning("quest has no objectives")
        }</span>

        <span class="cov0" title="0">if len(quest.Rewards) == 0 </span><span class="cov0" title="0">{
                result.AddWarning("quest has no rewards")
        }</span>
}

// validateMapConnectivity checks if walkable areas in the map are properly connected
func (v *Validator) validateMapConnectivity(gameMap *game.GameMap) bool <span class="cov0" title="0">{
        if !v.isValidMapDimensions(gameMap) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">walkableTiles := v.findWalkableTiles(gameMap)
        if len(walkableTiles) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">reachableCount := v.performConnectivityFloodFill(gameMap, walkableTiles[0])
        return reachableCount == len(walkableTiles)</span>
}

// isValidMapDimensions checks if the game map has valid dimensions
func (v *Validator) isValidMapDimensions(gameMap *game.GameMap) bool <span class="cov0" title="0">{
        return gameMap.Width &gt; 0 &amp;&amp; gameMap.Height &gt; 0
}</span>

// findWalkableTiles discovers all walkable positions in the game map
func (v *Validator) findWalkableTiles(gameMap *game.GameMap) []game.Position <span class="cov0" title="0">{
        walkableTiles := make([]game.Position, 0)
        for y := 0; y &lt; gameMap.Height; y++ </span><span class="cov0" title="0">{
                for x := 0; x &lt; gameMap.Width; x++ </span><span class="cov0" title="0">{
                        if gameMap.Tiles[y][x].Walkable </span><span class="cov0" title="0">{
                                walkableTiles = append(walkableTiles, game.Position{X: x, Y: y})
                        }</span>
                }
        }
        <span class="cov0" title="0">return walkableTiles</span>
}

// performConnectivityFloodFill uses flood fill algorithm to count reachable walkable tiles
func (v *Validator) performConnectivityFloodFill(gameMap *game.GameMap, startPos game.Position) int <span class="cov0" title="0">{
        visited := make(map[game.Position]bool)
        queue := []game.Position{startPos}
        visited[startPos] = true
        reachableCount := 1

        directions := v.getCardinalDirections()

        for len(queue) &gt; 0 </span><span class="cov0" title="0">{
                current := queue[0]
                queue = queue[1:]

                adjacentPositions := v.getAdjacentWalkablePositions(gameMap, current, directions, visited)
                for _, pos := range adjacentPositions </span><span class="cov0" title="0">{
                        visited[pos] = true
                        queue = append(queue, pos)
                        reachableCount++
                }</span>
        }

        <span class="cov0" title="0">return reachableCount</span>
}

// getCardinalDirections returns the four cardinal movement directions
func (v *Validator) getCardinalDirections() []game.Position <span class="cov0" title="0">{
        return []game.Position{
                {X: 0, Y: -1}, // North
                {X: 1, Y: 0},  // East
                {X: 0, Y: 1},  // South
                {X: -1, Y: 0}, // West
        }
}</span>

// getAdjacentWalkablePositions finds all unvisited walkable positions adjacent to current position
func (v *Validator) getAdjacentWalkablePositions(gameMap *game.GameMap, current game.Position, directions []game.Position, visited map[game.Position]bool) []game.Position <span class="cov0" title="0">{
        var adjacent []game.Position

        for _, dir := range directions </span><span class="cov0" title="0">{
                next := game.Position{
                        X: current.X + dir.X,
                        Y: current.Y + dir.Y,
                }

                if v.isValidPosition(gameMap, next) &amp;&amp; !visited[next] &amp;&amp; gameMap.Tiles[next.Y][next.X].Walkable </span><span class="cov0" title="0">{
                        adjacent = append(adjacent, next)
                }</span>
        }

        <span class="cov0" title="0">return adjacent</span>
}

// isValidPosition checks if a position is within the map boundaries
func (v *Validator) isValidPosition(gameMap *game.GameMap, pos game.Position) bool <span class="cov0" title="0">{
        return pos.X &gt;= 0 &amp;&amp; pos.X &lt; gameMap.Width &amp;&amp; pos.Y &gt;= 0 &amp;&amp; pos.Y &lt; gameMap.Height
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package pcg

import (
        "context"
        "fmt"
        "math"
        "math/rand"
        "time"

        "goldbox-rpg/pkg/game"

        "github.com/sirupsen/logrus"
)

// WorldGenerator creates overworld maps with regions, settlements, and travel networks
// Uses spatial indexing for efficient placement and pathfinding
type WorldGenerator struct {
        version string
        logger  *logrus.Logger
        rng     *rand.Rand
}

// GeneratedWorld represents a complete overworld campaign setting
type GeneratedWorld struct {
        ID          string                 `json:"id"`
        Name        string                 `json:"name"`
        Width       int                    `json:"width"`
        Height      int                    `json:"height"`
        Regions     []*Region              `json:"regions"`
        Settlements []*Settlement          `json:"settlements"`
        TravelPaths []*TravelPath          `json:"travel_paths"`
        Landmarks   []*Landmark            `json:"landmarks"`
        Climate     ClimateType            `json:"climate"`
        Metadata    map[string]interface{} `json:"metadata"`
        Generated   time.Time              `json:"generated"`
}

// Region represents a geographical area with specific characteristics
type Region struct {
        ID         string                 `json:"id"`
        Name       string                 `json:"name"`
        Bounds     Rectangle              `json:"bounds"`
        Biome      BiomeType              `json:"biome"`
        Difficulty int                    `json:"difficulty"`
        Resources  []ResourceType         `json:"resources"`
        Climate    ClimateType            `json:"climate"`
        Population int                    `json:"population"`
        Features   []RegionFeature        `json:"features"`
        Properties map[string]interface{} `json:"properties"`
}

// Settlement represents a town, city, or other inhabited location
type Settlement struct {
        ID          string                 `json:"id"`
        Name        string                 `json:"name"`
        Position    game.Position          `json:"position"`
        Type        SettlementType         `json:"type"`
        Population  int                    `json:"population"`
        Government  GovernmentType         `json:"government"`
        Economy     EconomyType            `json:"economy"`
        Defenses    DefenseLevel           `json:"defenses"`
        Services    []ServiceType          `json:"services"`
        TradeRoutes []string               `json:"trade_routes"`
        Connections []string               `json:"connections"`
        RegionID    string                 `json:"region_id"`
        Properties  map[string]interface{} `json:"properties"`
}

// TravelPath represents roads, rivers, and other travel routes
type TravelPath struct {
        ID         string                 `json:"id"`
        Name       string                 `json:"name"`
        Type       PathType               `json:"type"`
        Points     []game.Position        `json:"points"`
        From       string                 `json:"from"`
        To         string                 `json:"to"`
        Difficulty int                    `json:"difficulty"`
        TravelTime int                    `json:"travel_time"`
        Hazards    []HazardType           `json:"hazards"`
        Properties map[string]interface{} `json:"properties"`
}

// Landmark represents significant geographical or man-made features
type Landmark struct {
        ID          string                 `json:"id"`
        Name        string                 `json:"name"`
        Position    game.Position          `json:"position"`
        Type        LandmarkType           `json:"type"`
        Importance  int                    `json:"importance"`
        Description string                 `json:"description"`
        Properties  map[string]interface{} `json:"properties"`
}

// Enums for world generation types

type ClimateType string

const (
        ClimateTemperate ClimateType = "temperate"
        ClimateArctic    ClimateType = "arctic"
        ClimateTropical  ClimateType = "tropical"
        ClimateArid      ClimateType = "arid"
        ClimateMountain  ClimateType = "mountain"
)

type SettlementType string

const (
        SettlementHamlet    SettlementType = "hamlet"
        SettlementVillage   SettlementType = "village"
        SettlementTown      SettlementType = "town"
        SettlementCity      SettlementType = "city"
        SettlementCapital   SettlementType = "capital"
        SettlementFortress  SettlementType = "fortress"
        SettlementMonastery SettlementType = "monastery"
        SettlementOutpost   SettlementType = "outpost"
)

type GovernmentType string

const (
        GovernmentMonarchy  GovernmentType = "monarchy"
        GovernmentRepublic  GovernmentType = "republic"
        GovernmentTheocracy GovernmentType = "theocracy"
        GovernmentMilitary  GovernmentType = "military"
        GovernmentTribal    GovernmentType = "tribal"
        GovernmentAnarchy   GovernmentType = "anarchy"
)

type EconomyType string

const (
        EconomyAgriculture EconomyType = "agriculture"
        EconomyMining      EconomyType = "mining"
        EconomyTrading     EconomyType = "trading"
        EconomyFishing     EconomyType = "fishing"
        EconomyCrafting    EconomyType = "crafting"
        EconomyMagical     EconomyType = "magical"
)

type DefenseLevel string

const (
        DefenseNone     DefenseLevel = "none"
        DefensePalisade DefenseLevel = "palisade"
        DefenseWalls    DefenseLevel = "walls"
        DefenseFortress DefenseLevel = "fortress"
        DefenseCastle   DefenseLevel = "castle"
        DefenseMagical  DefenseLevel = "magical"
)

type ServiceType string

const (
        ServiceInn        ServiceType = "inn"
        ServiceTavern     ServiceType = "tavern"
        ServiceShop       ServiceType = "shop"
        ServiceBlacksmith ServiceType = "blacksmith"
        ServiceTemple     ServiceType = "temple"
        ServiceMage       ServiceType = "mage"
        ServiceHealer     ServiceType = "healer"
        ServiceStables    ServiceType = "stables"
        ServiceBank       ServiceType = "bank"
        ServiceLibrary    ServiceType = "library"
)

type PathType string

const (
        PathRoad   PathType = "road"
        PathTrail  PathType = "trail"
        PathRiver  PathType = "river"
        PathSea    PathType = "sea"
        PathBridge PathType = "bridge"
        PathTunnel PathType = "tunnel"
)

type HazardType string

const (
        HazardBandits   HazardType = "bandits"
        HazardMonsters  HazardType = "monsters"
        HazardWeather   HazardType = "weather"
        HazardTerrain   HazardType = "terrain"
        HazardMagical   HazardType = "magical"
        HazardPolitical HazardType = "political"
)

type LandmarkType string

const (
        LandmarkMountain LandmarkType = "mountain"
        LandmarkRuins    LandmarkType = "ruins"
        LandmarkForest   LandmarkType = "forest"
        LandmarkLake     LandmarkType = "lake"
        LandmarkDesert   LandmarkType = "desert"
        LandmarkVolcano  LandmarkType = "volcano"
        LandmarkTower    LandmarkType = "tower"
        LandmarkBridge   LandmarkType = "bridge"
        LandmarkShrine   LandmarkType = "shrine"
)

type ResourceType string

const (
        ResourceIron     ResourceType = "iron"
        ResourceGold     ResourceType = "gold"
        ResourceGems     ResourceType = "gems"
        ResourceWood     ResourceType = "wood"
        ResourceStone    ResourceType = "stone"
        ResourceMagicite ResourceType = "magicite"
        ResourceFood     ResourceType = "food"
        ResourceWater    ResourceType = "water"
)

type RegionFeature string

const (
        FeatureRiver       RegionFeature = "river"
        FeatureMountains   RegionFeature = "mountains"
        FeatureForestArea  RegionFeature = "forest"
        FeatureDesertArea  RegionFeature = "desert"
        FeatureSwampArea   RegionFeature = "swamp"
        FeatureMagicalZone RegionFeature = "magical_zone"
        FeatureBattlefield RegionFeature = "battlefield"
)

// WorldParams provides world-specific generation parameters
type WorldParams struct {
        GenerationParams  `yaml:",inline"`
        WorldWidth        int               `yaml:"world_width"`        // Width of the world map
        WorldHeight       int               `yaml:"world_height"`       // Height of the world map
        RegionCount       int               `yaml:"region_count"`       // Number of regions to generate
        SettlementCount   int               `yaml:"settlement_count"`   // Target number of settlements
        LandmarkCount     int               `yaml:"landmark_count"`     // Number of major landmarks
        Climate           ClimateType       `yaml:"climate"`            // Overall world climate
        Connectivity      ConnectivityLevel `yaml:"connectivity"`       // Travel route density
        PopulationDensity float64           `yaml:"population_density"` // Overall population density
        MagicLevel        int               `yaml:"magic_level"`        // Prevalence of magic (1-10)
        DangerLevel       int               `yaml:"danger_level"`       // Overall danger level
}

// NewWorldGenerator creates a new world generator
func NewWorldGenerator(logger *logrus.Logger) *WorldGenerator <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                logger = logrus.New()
        }</span>

        <span class="cov8" title="1">return &amp;WorldGenerator{
                version: "1.0.0",
                logger:  logger,
                rng:     rand.New(rand.NewSource(time.Now().UnixNano())),
        }</span>
}

// Generate creates a complete overworld campaign setting
// Implements Generator interface for PCG system integration
func (wg *WorldGenerator) Generate(ctx context.Context, params GenerationParams) (interface{}, error) <span class="cov8" title="1">{
        worldParams, ok := params.Constraints["world_params"].(WorldParams)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid parameters for world generation: expected world_params in constraints")
        }</span>

        // Validate parameters before generation
        <span class="cov8" title="1">if err := wg.Validate(params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parameter validation failed: %w", err)
        }</span>

        // Initialize RNG with provided seed for deterministic generation
        <span class="cov8" title="1">wg.rng = rand.New(rand.NewSource(params.Seed))

        wg.logger.WithFields(logrus.Fields{
                "world_width":  worldParams.WorldWidth,
                "world_height": worldParams.WorldHeight,
                "regions":      worldParams.RegionCount,
                "settlements":  worldParams.SettlementCount,
        }).Info("generating overworld campaign setting")

        world, err := wg.generateWorld(ctx, params, worldParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("world generation failed: %w", err)
        }</span>

        <span class="cov8" title="1">wg.logger.WithField("world_id", world.ID).Info("world generation completed")
        return world, nil</span>
}

// generateWorld creates the complete world structure
func (wg *WorldGenerator) generateWorld(ctx context.Context, params GenerationParams, worldParams WorldParams) (*GeneratedWorld, error) <span class="cov8" title="1">{
        world := &amp;GeneratedWorld{
                ID:          fmt.Sprintf("world_%d", wg.rng.Int63()),
                Name:        wg.generateWorldName(worldParams.Climate),
                Width:       worldParams.WorldWidth,
                Height:      worldParams.WorldHeight,
                Regions:     make([]*Region, 0),
                Settlements: make([]*Settlement, 0),
                TravelPaths: make([]*TravelPath, 0),
                Landmarks:   make([]*Landmark, 0),
                Climate:     worldParams.Climate,
                Metadata:    make(map[string]interface{}),
                Generated:   time.Now(),
        }

        // Step 1: Generate regions using spatial partitioning
        if err := wg.generateRegions(world, worldParams); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("region generation failed: %w", err)
        }</span>

        // Step 2: Place landmarks strategically
        <span class="cov8" title="1">if err := wg.generateLandmarks(world, worldParams); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("landmark generation failed: %w", err)
        }</span>

        // Step 3: Generate settlements with spatial distribution
        <span class="cov8" title="1">if err := wg.generateSettlements(world, worldParams); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("settlement generation failed: %w", err)
        }</span>

        // Step 4: Create travel network connecting settlements
        <span class="cov8" title="1">if err := wg.generateTravelNetwork(world, worldParams); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("travel network generation failed: %w", err)
        }</span>

        // Step 5: Add metadata for debugging and validation
        <span class="cov8" title="1">world.Metadata["total_population"] = wg.calculateTotalPopulation(world)
        world.Metadata["trade_route_count"] = len(world.TravelPaths)
        world.Metadata["generation_seed"] = params.Seed

        return world, nil</span>
}

// generateRegions creates geographical regions using spatial partitioning
func (wg *WorldGenerator) generateRegions(world *GeneratedWorld, params WorldParams) error <span class="cov8" title="1">{
        // Use simple grid-based partitioning for initial implementation
        regionWidth := world.Width / int(math.Sqrt(float64(params.RegionCount)))
        regionHeight := world.Height / int(math.Sqrt(float64(params.RegionCount)))

        regionID := 0
        for y := 0; y &lt; world.Height; y += regionHeight </span><span class="cov8" title="1">{
                for x := 0; x &lt; world.Width; x += regionWidth </span><span class="cov8" title="1">{
                        if regionID &gt;= params.RegionCount </span><span class="cov0" title="0">{
                                break</span>
                        }

                        // Adjust last region to cover remaining area
                        <span class="cov8" title="1">width := regionWidth
                        height := regionHeight
                        if x+width &gt; world.Width </span><span class="cov0" title="0">{
                                width = world.Width - x
                        }</span>
                        <span class="cov8" title="1">if y+height &gt; world.Height </span><span class="cov0" title="0">{
                                height = world.Height - y
                        }</span>

                        <span class="cov8" title="1">region := &amp;Region{
                                ID:         fmt.Sprintf("region_%d", regionID),
                                Name:       wg.generateRegionName(regionID),
                                Bounds:     Rectangle{X: x, Y: y, Width: width, Height: height},
                                Biome:      wg.chooseBiome(params.Climate),
                                Difficulty: 1 + wg.rng.Intn(params.DangerLevel),
                                Resources:  wg.generateResources(),
                                Climate:    params.Climate,
                                Population: wg.rng.Intn(10000) + 1000,
                                Features:   wg.generateRegionFeatures(),
                                Properties: make(map[string]interface{}),
                        }

                        world.Regions = append(world.Regions, region)
                        regionID++</span>
                }
                <span class="cov8" title="1">if regionID &gt;= params.RegionCount </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// generateLandmarks places significant features across the world
func (wg *WorldGenerator) generateLandmarks(world *GeneratedWorld, params WorldParams) error <span class="cov8" title="1">{
        for i := 0; i &lt; params.LandmarkCount; i++ </span><span class="cov8" title="1">{
                landmark := &amp;Landmark{
                        ID:          fmt.Sprintf("landmark_%d", i),
                        Name:        wg.generateLandmarkName(),
                        Position:    game.Position{X: wg.rng.Intn(world.Width), Y: wg.rng.Intn(world.Height)},
                        Type:        wg.chooseLandmarkType(),
                        Importance:  1 + wg.rng.Intn(5),
                        Description: wg.generateLandmarkDescription(),
                        Properties:  make(map[string]interface{}),
                }

                world.Landmarks = append(world.Landmarks, landmark)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// generateSettlements places settlements with proper spacing and context
func (wg *WorldGenerator) generateSettlements(world *GeneratedWorld, params WorldParams) error <span class="cov8" title="1">{
        minDistance := 10 // Minimum distance between settlements

        for i := 0; i &lt; params.SettlementCount; i++ </span><span class="cov8" title="1">{
                var position game.Position
                attempts := 0
                maxAttempts := 100

                // Find position with proper spacing
                for attempts &lt; maxAttempts </span><span class="cov8" title="1">{
                        position = game.Position{
                                X: wg.rng.Intn(world.Width),
                                Y: wg.rng.Intn(world.Height),
                        }

                        // Check distance to existing settlements
                        validPosition := true
                        for _, existing := range world.Settlements </span><span class="cov8" title="1">{
                                distance := wg.calculateDistance(position, existing.Position)
                                if distance &lt; minDistance </span><span class="cov8" title="1">{
                                        validPosition = false
                                        break</span>
                                }
                        }

                        <span class="cov8" title="1">if validPosition </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">attempts++</span>
                }

                <span class="cov8" title="1">if attempts &gt;= maxAttempts </span><span class="cov0" title="0">{
                        wg.logger.Warn("could not find valid position for settlement after max attempts")
                        continue</span>
                }

                // Find which region contains this settlement
                <span class="cov8" title="1">regionID := wg.findRegionForPosition(world, position)

                settlement := &amp;Settlement{
                        ID:          fmt.Sprintf("settlement_%d", i),
                        Name:        wg.generateSettlementName(),
                        Position:    position,
                        Type:        wg.chooseSettlementType(params.PopulationDensity),
                        Population:  wg.calculateSettlementPopulation(params.PopulationDensity),
                        Government:  wg.chooseGovernmentType(),
                        Economy:     wg.chooseEconomyType(),
                        Defenses:    wg.chooseDefenseLevel(params.DangerLevel),
                        Services:    wg.generateServices(),
                        TradeRoutes: make([]string, 0),
                        Connections: make([]string, 0),
                        RegionID:    regionID,
                        Properties:  make(map[string]interface{}),
                }

                world.Settlements = append(world.Settlements, settlement)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// generateTravelNetwork creates roads and paths connecting settlements
func (wg *WorldGenerator) generateTravelNetwork(world *GeneratedWorld, params WorldParams) error <span class="cov8" title="1">{
        // Connect each settlement to its nearest neighbors
        for _, settlement := range world.Settlements </span><span class="cov8" title="1">{
                nearestNeighbors := wg.findNearestSettlements(world, settlement, 3)

                for _, neighbor := range nearestNeighbors </span><span class="cov8" title="1">{
                        // Check if connection already exists
                        connectionExists := false
                        for _, existing := range world.TravelPaths </span><span class="cov8" title="1">{
                                if (existing.From == settlement.ID &amp;&amp; existing.To == neighbor.ID) ||
                                        (existing.From == neighbor.ID &amp;&amp; existing.To == settlement.ID) </span><span class="cov8" title="1">{
                                        connectionExists = true
                                        break</span>
                                }
                        }

                        <span class="cov8" title="1">if !connectionExists </span><span class="cov8" title="1">{
                                path := wg.createTravelPath(settlement, neighbor)
                                world.TravelPaths = append(world.TravelPaths, path)

                                // Update settlement connections
                                settlement.Connections = append(settlement.Connections, neighbor.ID)
                                neighbor.Connections = append(neighbor.Connections, settlement.ID)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// Helper methods

func (wg *WorldGenerator) generateWorldName(climate ClimateType) string <span class="cov8" title="1">{
        prefixes := map[ClimateType][]string{
                ClimateTemperate: {"Green", "Fair", "Golden", "Pleasant"},
                ClimateArctic:    {"Frozen", "White", "Frost", "Ice"},
                ClimateTropical:  {"Verdant", "Lush", "Steam", "Jungle"},
                ClimateArid:      {"Sand", "Burning", "Dry", "Sun"},
                ClimateMountain:  {"High", "Stone", "Peak", "Ridge"},
        }

        suffixes := []string{"Realm", "Lands", "Domain", "Kingdom", "Territory", "Expanse"}

        prefix := prefixes[climate][wg.rng.Intn(len(prefixes[climate]))]
        suffix := suffixes[wg.rng.Intn(len(suffixes))]

        return fmt.Sprintf("%s %s", prefix, suffix)
}</span>

func (wg *WorldGenerator) generateRegionName(id int) string <span class="cov8" title="1">{
        prefixes := []string{"North", "South", "East", "West", "Central", "Upper", "Lower", "Inner", "Outer"}
        suffixes := []string{"Reach", "March", "Vale", "Moor", "Waste", "Wood", "Hold", "Shire", "Gate"}

        prefix := prefixes[wg.rng.Intn(len(prefixes))]
        suffix := suffixes[wg.rng.Intn(len(suffixes))]

        return fmt.Sprintf("%s %s", prefix, suffix)
}</span>

func (wg *WorldGenerator) generateSettlementName() string <span class="cov8" title="1">{
        prefixes := []string{"Stone", "Iron", "Gold", "Silver", "Wood", "River", "Hill", "Vale", "Red", "White"}
        suffixes := []string{"ford", "burg", "ton", "ham", "stead", "haven", "bridge", "gate", "port", "mill"}

        prefix := prefixes[wg.rng.Intn(len(prefixes))]
        suffix := suffixes[wg.rng.Intn(len(suffixes))]

        return fmt.Sprintf("%s%s", prefix, suffix)
}</span>

func (wg *WorldGenerator) generateLandmarkName() string <span class="cov8" title="1">{
        adjectives := []string{"Ancient", "Forgotten", "Lost", "Sacred", "Cursed", "Hidden", "Great", "Old"}
        nouns := []string{"Tower", "Ruins", "Mountain", "Forest", "Lake", "Bridge", "Shrine", "Monument"}

        adj := adjectives[wg.rng.Intn(len(adjectives))]
        noun := nouns[wg.rng.Intn(len(nouns))]

        return fmt.Sprintf("%s %s", adj, noun)
}</span>

func (wg *WorldGenerator) generateLandmarkDescription() string <span class="cov8" title="1">{
        descriptions := []string{
                "A mysterious structure of unknown origin",
                "Ancient ruins from a forgotten civilization",
                "A place of natural beauty and wonder",
                "Remnants of a great battle fought long ago",
                "A sacred site revered by local inhabitants",
                "A geographical feature visible from great distances",
        }

        return descriptions[wg.rng.Intn(len(descriptions))]
}</span>

func (wg *WorldGenerator) chooseBiome(climate ClimateType) BiomeType <span class="cov8" title="1">{
        biomeWeights := map[ClimateType]map[BiomeType]int{
                ClimateTemperate: {BiomeForest: 40, BiomeMountain: 20, BiomeCoastal: 20, BiomeUrban: 20},
                ClimateArctic:    {BiomeMountain: 60, BiomeForest: 20, BiomeWasteland: 20},
                ClimateTropical:  {BiomeForest: 50, BiomeSwamp: 30, BiomeCoastal: 20},
                ClimateArid:      {BiomeDesert: 70, BiomeMountain: 20, BiomeWasteland: 10},
                ClimateMountain:  {BiomeMountain: 80, BiomeForest: 20},
        }

        return wg.weightedRandomBiome(biomeWeights[climate])
}</span>

func (wg *WorldGenerator) weightedRandomBiome(weights map[BiomeType]int) BiomeType <span class="cov8" title="1">{
        totalWeight := 0
        for _, weight := range weights </span><span class="cov8" title="1">{
                totalWeight += weight
        }</span>

        <span class="cov8" title="1">randomValue := wg.rng.Intn(totalWeight)
        currentWeight := 0

        for biome, weight := range weights </span><span class="cov8" title="1">{
                currentWeight += weight
                if randomValue &lt; currentWeight </span><span class="cov8" title="1">{
                        return biome
                }</span>
        }

        <span class="cov0" title="0">return BiomeForest</span> // fallback
}

func (wg *WorldGenerator) generateResources() []ResourceType <span class="cov8" title="1">{
        allResources := []ResourceType{ResourceIron, ResourceGold, ResourceGems, ResourceWood, ResourceStone, ResourceMagicite, ResourceFood, ResourceWater}
        resourceCount := 1 + wg.rng.Intn(4)

        resources := make([]ResourceType, 0, resourceCount)
        for i := 0; i &lt; resourceCount; i++ </span><span class="cov8" title="1">{
                resource := allResources[wg.rng.Intn(len(allResources))]
                // Avoid duplicates
                found := false
                for _, existing := range resources </span><span class="cov8" title="1">{
                        if existing == resource </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        resources = append(resources, resource)
                }</span>
        }

        <span class="cov8" title="1">return resources</span>
}

func (wg *WorldGenerator) generateRegionFeatures() []RegionFeature <span class="cov8" title="1">{
        allFeatures := []RegionFeature{FeatureRiver, FeatureMountains, FeatureForestArea, FeatureDesertArea, FeatureSwampArea, FeatureMagicalZone, FeatureBattlefield}
        featureCount := wg.rng.Intn(3) + 1

        features := make([]RegionFeature, 0, featureCount)
        for i := 0; i &lt; featureCount; i++ </span><span class="cov8" title="1">{
                feature := allFeatures[wg.rng.Intn(len(allFeatures))]
                features = append(features, feature)
        }</span>

        <span class="cov8" title="1">return features</span>
}

func (wg *WorldGenerator) chooseLandmarkType() LandmarkType <span class="cov8" title="1">{
        types := []LandmarkType{LandmarkMountain, LandmarkRuins, LandmarkForest, LandmarkLake, LandmarkDesert, LandmarkVolcano, LandmarkTower, LandmarkBridge, LandmarkShrine}
        return types[wg.rng.Intn(len(types))]
}</span>

func (wg *WorldGenerator) chooseSettlementType(populationDensity float64) SettlementType <span class="cov8" title="1">{
        // Higher population density = more likely to have larger settlements
        roll := wg.rng.Float64() * populationDensity

        if roll &gt; 0.8 </span><span class="cov8" title="1">{
                return SettlementCity
        }</span> else<span class="cov8" title="1"> if roll &gt; 0.6 </span><span class="cov8" title="1">{
                return SettlementTown
        }</span> else<span class="cov8" title="1"> if roll &gt; 0.4 </span><span class="cov8" title="1">{
                return SettlementVillage
        }</span> else<span class="cov8" title="1"> {
                return SettlementHamlet
        }</span>
}

func (wg *WorldGenerator) calculateSettlementPopulation(populationDensity float64) int <span class="cov8" title="1">{
        basePopulation := int(100 * populationDensity)
        variation := wg.rng.Intn(basePopulation)
        return basePopulation + variation
}</span>

func (wg *WorldGenerator) chooseGovernmentType() GovernmentType <span class="cov8" title="1">{
        types := []GovernmentType{GovernmentMonarchy, GovernmentRepublic, GovernmentTheocracy, GovernmentMilitary, GovernmentTribal, GovernmentAnarchy}
        return types[wg.rng.Intn(len(types))]
}</span>

func (wg *WorldGenerator) chooseEconomyType() EconomyType <span class="cov8" title="1">{
        types := []EconomyType{EconomyAgriculture, EconomyMining, EconomyTrading, EconomyFishing, EconomyCrafting, EconomyMagical}
        return types[wg.rng.Intn(len(types))]
}</span>

func (wg *WorldGenerator) chooseDefenseLevel(dangerLevel int) DefenseLevel <span class="cov8" title="1">{
        // Higher danger level = better defenses
        roll := wg.rng.Intn(10) + dangerLevel

        if roll &gt; 15 </span><span class="cov0" title="0">{
                return DefenseCastle
        }</span> else<span class="cov8" title="1"> if roll &gt; 12 </span><span class="cov0" title="0">{
                return DefenseFortress
        }</span> else<span class="cov8" title="1"> if roll &gt; 8 </span><span class="cov8" title="1">{
                return DefenseWalls
        }</span> else<span class="cov8" title="1"> if roll &gt; 5 </span><span class="cov8" title="1">{
                return DefensePalisade
        }</span> else<span class="cov8" title="1"> {
                return DefenseNone
        }</span>
}

func (wg *WorldGenerator) generateServices() []ServiceType <span class="cov8" title="1">{
        allServices := []ServiceType{ServiceInn, ServiceTavern, ServiceShop, ServiceBlacksmith, ServiceTemple, ServiceMage, ServiceHealer, ServiceStables, ServiceBank, ServiceLibrary}
        serviceCount := 2 + wg.rng.Intn(4)

        services := make([]ServiceType, 0, serviceCount)
        for i := 0; i &lt; serviceCount; i++ </span><span class="cov8" title="1">{
                service := allServices[wg.rng.Intn(len(allServices))]
                services = append(services, service)
        }</span>

        <span class="cov8" title="1">return services</span>
}

func (wg *WorldGenerator) calculateDistance(pos1, pos2 game.Position) int <span class="cov8" title="1">{
        dx := pos1.X - pos2.X
        dy := pos1.Y - pos2.Y
        return int(math.Sqrt(float64(dx*dx + dy*dy)))
}</span>

func (wg *WorldGenerator) findRegionForPosition(world *GeneratedWorld, position game.Position) string <span class="cov8" title="1">{
        for _, region := range world.Regions </span><span class="cov8" title="1">{
                if region.Bounds.Contains(position.X, position.Y) </span><span class="cov8" title="1">{
                        return region.ID
                }</span>
        }
        <span class="cov8" title="1">return "unknown"</span>
}

func (wg *WorldGenerator) findNearestSettlements(world *GeneratedWorld, settlement *Settlement, count int) []*Settlement <span class="cov8" title="1">{
        type settlementDistance struct {
                settlement *Settlement
                distance   int
        }

        distances := make([]settlementDistance, 0, len(world.Settlements))

        for _, other := range world.Settlements </span><span class="cov8" title="1">{
                if other.ID != settlement.ID </span><span class="cov8" title="1">{
                        distance := wg.calculateDistance(settlement.Position, other.Position)
                        distances = append(distances, settlementDistance{other, distance})
                }</span>
        }

        // Sort by distance
        <span class="cov8" title="1">for i := 0; i &lt; len(distances)-1; i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(distances); j++ </span><span class="cov8" title="1">{
                        if distances[i].distance &gt; distances[j].distance </span><span class="cov8" title="1">{
                                distances[i], distances[j] = distances[j], distances[i]
                        }</span>
                }
        }

        // Return up to 'count' nearest settlements
        <span class="cov8" title="1">result := make([]*Settlement, 0, count)
        for i := 0; i &lt; count &amp;&amp; i &lt; len(distances); i++ </span><span class="cov8" title="1">{
                result = append(result, distances[i].settlement)
        }</span>

        <span class="cov8" title="1">return result</span>
}

func (wg *WorldGenerator) createTravelPath(from, to *Settlement) *TravelPath <span class="cov8" title="1">{
        distance := wg.calculateDistance(from.Position, to.Position)

        return &amp;TravelPath{
                ID:         fmt.Sprintf("path_%s_%s", from.ID, to.ID),
                Name:       fmt.Sprintf("Road from %s to %s", from.Name, to.Name),
                Type:       PathRoad,
                Points:     []game.Position{from.Position, to.Position}, // Simplified straight line
                From:       from.ID,
                To:         to.ID,
                Difficulty: 1 + wg.rng.Intn(3),
                TravelTime: distance / 10, // Simplified travel time calculation
                Hazards:    wg.generatePathHazards(),
                Properties: make(map[string]interface{}),
        }
}</span>

func (wg *WorldGenerator) generatePathHazards() []HazardType <span class="cov8" title="1">{
        allHazards := []HazardType{HazardBandits, HazardMonsters, HazardWeather, HazardTerrain, HazardMagical, HazardPolitical}
        hazardCount := wg.rng.Intn(3) // 0-2 hazards per path

        hazards := make([]HazardType, 0, hazardCount)
        for i := 0; i &lt; hazardCount; i++ </span><span class="cov8" title="1">{
                hazard := allHazards[wg.rng.Intn(len(allHazards))]
                hazards = append(hazards, hazard)
        }</span>

        <span class="cov8" title="1">return hazards</span>
}

func (wg *WorldGenerator) calculateTotalPopulation(world *GeneratedWorld) int <span class="cov8" title="1">{
        total := 0
        for _, settlement := range world.Settlements </span><span class="cov8" title="1">{
                total += settlement.Population
        }</span>
        <span class="cov8" title="1">return total</span>
}

// Interface compliance methods

// GetType returns the content type this generator produces
func (wg *WorldGenerator) GetType() ContentType <span class="cov8" title="1">{
        return ContentTypeTerrain // Using existing content type for world generation
}</span>

// GetVersion returns the generator version for compatibility
func (wg *WorldGenerator) GetVersion() string <span class="cov8" title="1">{
        return wg.version
}</span>

// Validate checks if the provided parameters are valid
func (wg *WorldGenerator) Validate(params GenerationParams) error <span class="cov8" title="1">{
        worldParams, ok := params.Constraints["world_params"].(WorldParams)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid parameters: expected world_params in constraints")
        }</span>

        <span class="cov8" title="1">if worldParams.WorldWidth &lt; 50 || worldParams.WorldWidth &gt; 1000 </span><span class="cov8" title="1">{
                return fmt.Errorf("world width must be between 50 and 1000, got %d", worldParams.WorldWidth)
        }</span>

        <span class="cov8" title="1">if worldParams.WorldHeight &lt; 50 || worldParams.WorldHeight &gt; 1000 </span><span class="cov0" title="0">{
                return fmt.Errorf("world height must be between 50 and 1000, got %d", worldParams.WorldHeight)
        }</span>

        <span class="cov8" title="1">if worldParams.RegionCount &lt; 1 || worldParams.RegionCount &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("region count must be between 1 and 100, got %d", worldParams.RegionCount)
        }</span>

        <span class="cov8" title="1">if worldParams.SettlementCount &lt; 1 || worldParams.SettlementCount &gt; 500 </span><span class="cov0" title="0">{
                return fmt.Errorf("settlement count must be between 1 and 500, got %d", worldParams.SettlementCount)
        }</span>

        <span class="cov8" title="1">if worldParams.PopulationDensity &lt; 0.1 || worldParams.PopulationDensity &gt; 10.0 </span><span class="cov8" title="1">{
                return fmt.Errorf("population density must be between 0.1 and 10.0, got %f", worldParams.PopulationDensity)
        }</span>

        <span class="cov8" title="1">if worldParams.MagicLevel &lt; 1 || worldParams.MagicLevel &gt; 10 </span><span class="cov8" title="1">{
                return fmt.Errorf("magic level must be between 1 and 10, got %d", worldParams.MagicLevel)
        }</span>

        <span class="cov8" title="1">if worldParams.DangerLevel &lt; 1 || worldParams.DangerLevel &gt; 20 </span><span class="cov0" title="0">{
                return fmt.Errorf("danger level must be between 1 and 20, got %d", worldParams.DangerLevel)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
